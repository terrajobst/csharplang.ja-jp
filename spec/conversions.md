---
ms.openlocfilehash: 4d6d28a3127bc701867afe157aa5496377a06f69
ms.sourcegitcommit: 63d276488c9770a565fd787020783ffc1d2af9d6
ms.translationtype: MT
ms.contentlocale: ja-JP
ms.lasthandoff: 12/05/2019
ms.locfileid: "74868005"
---
# <a name="conversions"></a>変換

***変換***を使用すると、式を特定の型として扱うことができます。 変換によって、指定された型の式が別の型として処理されるか、型のない式が型を取得する可能性があります。 変換は***暗黙的***または***明示的***に行うことができます。これにより、明示的なキャストが必要かどうかが決まります。 たとえば、型 `int` から型 `long` への変換は暗黙的に行われるため、型 `int` の式は暗黙的に型 `long`として扱うことができます。 型 `long` から `int`型への逆の変換は明示的であるため、明示的なキャストが必要です。

```csharp
int a = 123;
long b = a;         // implicit conversion from int to long
int c = (int) b;    // explicit conversion from long to int
```

一部の変換は、言語によって定義されます。 プログラムでは、独自の変換 ([ユーザー定義の変換](conversions.md#user-defined-conversions)) を定義することもできます。

## <a name="implicit-conversions"></a>暗黙の変換

次の変換は、暗黙的な変換として分類されます。

*  Id 変換
*  暗黙の数値変換
*  暗黙的な列挙変換
*  暗黙的な挿入文字列の変換
*  暗黙の null 許容型変換
*  Null リテラル変換
*  暗黙の参照変換
*  ボックス化変換
*  暗黙の動的変換
*  暗黙の定数式の変換
*  ユーザー定義の暗黙的な変換
*  匿名関数の変換
*  メソッドグループの変換

暗黙の型変換は、関数メンバー呼び出し ([動的なオーバーロード解決のコンパイル時のチェック](expressions.md#compile-time-checking-of-dynamic-overload-resolution))、キャスト式 ([キャスト式](expressions.md#cast-expressions))、代入 ([代入演算子](expressions.md#assignment-operators)) など、さまざまな状況で発生する可能性があります。

定義済みの暗黙的な変換は常に成功し、例外がスローされることはありません。 適切に設計されたユーザー定義の暗黙的な変換でも、これらの特性が示されます。

変換のために、型 `object` と `dynamic` は同等と見なされます。

ただし、動的変換 ([暗黙の動的](conversions.md#implicit-dynamic-conversions)変換と[明示的な動的](conversions.md#explicit-dynamic-conversions)変換) は `dynamic` 型の式 ([動的型](types.md#the-dynamic-type)) にのみ適用されます。

### <a name="identity-conversion"></a>Id 変換

Id 変換は、任意の型から同じ型に変換します。 この変換は、既に必要な型を持つエンティティをその型に変換できるようにするために存在します。

*  `object` と `dynamic` は同等と見なされるため、`object` と `dynamic`間の id 変換と、`dynamic` のすべての出現箇所を `object`に置き換える場合の構築された型の間の id 変換があります。

### <a name="implicit-numeric-conversions"></a>暗黙の数値変換

暗黙的な数値変換は次のとおりです。

*  `sbyte` から `short`、`int`、`long`、`float`、`double`、`decimal`になります。
*  `byte` から `short`、`ushort`、`int`、`uint`、`long`、`ulong`、`float`、`double`、`decimal`になります。
*  `short` から `int`、`long`、`float`、`double`、`decimal`になります。
*  `ushort` から `int`、`uint`、`long`、`ulong`、`float`、`double`、`decimal`になります。
*  `int` から `long`、`float`、`double`、または `decimal`になります。
*  `uint` から `long`、`ulong`、`float`、`double`、`decimal`になります。
*  `long` から `float`、`double`、または `decimal`。
*  `ulong` から `float`、`double`、または `decimal`。
*  `char` から `ushort`、`int`、`uint`、`long`、`ulong`、`float`、`double`、`decimal`になります。
*  `float` から `double`。

`int`、`uint`、`long`、または `ulong` から `float` への変換または `long` への変換は、精度の低下を招く可能性がありますが、マグニチュードが失われることはありません。 その他の暗黙的な数値変換では、情報が失われることはありません。

`char` 型への暗黙的な変換は行われないため、他の整数型の値は `char` 型に自動的に変換されません。

### <a name="implicit-enumeration-conversions"></a>暗黙的な列挙変換

暗黙的な列挙型変換では、 *decimal_integer_literal* `0` を任意の*enum_type*に変換し、基になる型が*enum_type*であるすべての*nullable_type*に変換できます。 後者の場合、変換は、基になる*enum_type*に変換し、結果をラップすることによって評価されます ([null 許容型](types.md#nullable-types))。

### <a name="implicit-interpolated-string-conversions"></a>暗黙的な挿入文字列の変換

暗黙的な補間文字列変換は、 *interpolated_string_expression* (挿入[文字列](expressions.md#interpolated-strings)) を `System.IFormattable` または `System.FormattableString` (`System.IFormattable`を実装) に変換することを許可します。

この変換が適用された場合、文字列値は挿入文字列からは構成されません。 代わりに、「挿入[文字列](expressions.md#interpolated-strings)」で詳しく説明されているように、`System.FormattableString` のインスタンスが作成されます。

### <a name="implicit-nullable-conversions"></a>暗黙の null 許容型変換

Null 非許容の値型に対して動作する定義済みの暗黙的な変換は、これらの型の null 許容形式でも使用できます。 Null 非許容の値型から null 非許容の値 `T`型に変換する、定義済みの暗黙的な id および数値変換については、次の暗黙的な null 許容の変換が存在します。 `S`

*  `S?` から `T?`への暗黙的な変換です。
*  `S` から `T?`への暗黙的な変換です。

`S` から `T` への基になる変換に基づく null 許容型の暗黙的な変換の評価は次のように行われます。

*  Null 許容型変換が `S?` から `T?`の場合は、次のようになります。
    * ソース値が null (`HasValue` プロパティが false) の場合、結果は `T?`型の null 値になります。
    * それ以外の場合、変換は `S?` から `S`へのラップ解除として評価された後、`S` から `T`への基になる変換と、`T` から `T?`へのラップ ([Null 許容型](types.md#nullable-types)) が行われます。

*  Null 許容型変換が `S` から `T?`に対して行われる場合、変換は `S` から `T` の基になる変換として評価され、その後、`T` から `T?`へのラップが行われます。

### <a name="null-literal-conversions"></a>Null リテラル変換

`null` リテラルから null 許容型への暗黙的な変換が存在します。 この変換では、null 許容型の null 値 (null[許容型](types.md#nullable-types)) が生成されます。

### <a name="implicit-reference-conversions"></a>暗黙の参照変換

暗黙の参照変換は次のとおりです。

*  任意の*reference_type*から `object` して `dynamic`します。
*  任意の*class_type* `S` から任意の*class_type* `T`への `S` は、`T`から派生しています。
*  任意の*class_type* `S` から、`S` が `T`を実装している*interface_type* `T`。
*  任意の*interface_type* `S` から任意の*interface_type* `T`への `S` は、`T`から派生しています。
*  要素型が `T` の*array_type* `S` から、次のすべてが満たされていれば、要素型が `TE`の*array_type*に `SE` ます。
    * `S` と `T` は要素の型のみが異なります。 言い換えると、`S` と `T` の次元数が同じになります。
    * `SE` と `TE` は両方とも*reference_type*です。
    * `SE` から `TE`への暗黙的な参照変換が存在します。
*  任意の*array_type*から `System.Array` とそれが実装するインターフェイス。
*  `S` から `T`への暗黙的な id または参照の変換がある場合は、1次元配列型から `System.Collections.Generic.IList<T>` とその基本インターフェイスを `S[]` します。
*  任意の*delegate_type*から `System.Delegate` とそれが実装するインターフェイス。
*  Null リテラルから任意の*reference_type*にします。
*  *Reference_type* `T0` への暗黙的な id または参照の変換がある場合は、任意の*reference_type*から*reference_type* `T`、`T0` には `T`への id 変換が含まれています。
*  インターフェイスまたはデリゲート型への暗黙的な id または参照の変換がある場合は、任意の*reference_type*からインターフェイスまたはデリゲート型に `T`、`T0` および `T0` が `T`への分散変換可能 ([変位変換](interfaces.md#variance-conversion)) になります。
*  参照型として認識されている型パラメーターを使用する暗黙的な変換。 型パラメーターを使用する暗黙的な変換の詳細については、「[型パラメーターに関連する暗黙的な変換](conversions.md#implicit-conversions-involving-type-parameters)」を参照してください。

暗黙の参照変換とは*reference_type*の間の変換であり、常に成功することが証明されるため、実行時のチェックは必要ありません。

暗黙的または明示的な参照変換では、変換するオブジェクトの参照 id は変更されません。 つまり、参照変換によって参照の型が変更されても、参照先のオブジェクトの型または値が変更されることはありません。

### <a name="boxing-conversions"></a>ボックス化変換

ボックス化変換は、 *value_type*を参照型に暗黙的に変換することを許可します。 ボックス化変換は、すべての*non_nullable_value_type*から `object` と `dynamic`に、 *interface_type*によって実装されている任意の*non_nullable_value_type*に対して `System.ValueType` およびに対して行われます。 さらに、 *enum_type*は `System.Enum`型に変換できます。

基になる*non_nullable_value_type*から参照型へのボックス変換が存在する場合にのみ、 *nullable_type*から参照型へのボックス変換が存在します。

値型には、インターフェイス型へのボックス変換が `I0` ある場合は `I` インターフェイス型へのボックス変換があり、`I0` には `I`への id 変換が含まれています。

値型には、インターフェイス型またはデリゲート `I0` 型へのボックス変換がある場合は `I` インターフェイス型へのボックス変換があり、`I0` は `I`への変位変換 ([変位変換](interfaces.md#variance-conversion)) があります。

*Non_nullable_value_type*の値のボックス化では、オブジェクトインスタンスを割り当て、そのインスタンスに*value_type*値をコピーします。 構造体は、すべての構造体 ([継承](structs.md#inheritance)) の基本クラスであるため `System.ValueType`型にボックス化できます。

*Nullable_type*の値をボックス化すると、次のように処理されるようになります。

*  ソース値が null (`HasValue` プロパティが false) の場合、結果はターゲット型の null 参照になります。
*  それ以外の場合、結果は、ソース値のラップ解除とボックス化によって生成されるボックス化された `T` への参照になります。

ボックス化変換の詳細については、「[ボックス化変換](types.md#boxing-conversions)」を参照してください。

### <a name="implicit-dynamic-conversions"></a>暗黙の動的変換

`dynamic` 型の式から `T`任意の型への暗黙の動的変換が存在します。 変換は動的にバインドされます ([動的バインド](expressions.md#dynamic-binding))。つまり、`T`する式の実行時の型から、実行時に暗黙的な変換がシークされます。 変換が見つからない場合は、実行時例外がスローされます。

この暗黙的な変換は、暗黙的な変換では例外が発生しないと[いう暗黙の変換の開始](conversions.md#implicit-conversions)時のアドバイスには違反していることに注意してください。 ただし、これは変換自体ではなく、例外を発生させる変換の*検索*です。 実行時例外のリスクは、動的バインドの使用に固有のものです。 変換の動的バインドが望ましくない場合は、式を最初に `object`に変換し、次に目的の型に変換できます。

暗黙の動的変換の例を次に示します。

```csharp
object o  = "object"
dynamic d = "dynamic";

string s1 = o; // Fails at compile-time -- no conversion exists
string s2 = d; // Compiles and succeeds at run-time
int i     = d; // Compiles but fails at run-time -- no conversion exists
```

`s2` と `i` の割り当てには、暗黙的な動的変換が使用されます。この場合、操作のバインドは実行時まで中断されます。 実行時には、暗黙的な変換は、`d` -- `string` の実行時の型から対象の型にシークされます。 `string` への変換は見つかりましたが、`int`はありません。

### <a name="implicit-constant-expression-conversions"></a>暗黙の定数式の変換

暗黙の定数式の変換では、次の変換が許可されます。

*  `int` 型の*constant_expression* ([定数式](expressions.md#constant-expressions)) は、 *`short`* の値が変換先の型の範囲内にある場合に、型 `sbyte`、`byte`、`ushort`、`uint`、`ulong`、または constant_expression に変換できます。
*  *Constant_expression*の値が負でない場合は、型 `long` の*constant_expression*を `ulong`型に変換できます。

### <a name="implicit-conversions-involving-type-parameters"></a>型パラメーターを含む暗黙の型変換

指定された型パラメーター `T`には、次の暗黙的な変換が存在します。

*  `T` から、有効な基本クラス `C`、`T` から `C`の任意の基底クラス、`T` によって実装されている任意のインターフェイスに `C`ます。 実行時に `T` が値型の場合、変換はボックス化変換として実行されます。 それ以外の場合、暗黙的な参照変換または id 変換として変換が実行されます。
*  `T` から、`T`の有効なインターフェイスセット内の `I` インターフェイス型と、`T` から `I`の任意の基本インターフェイスになります。 実行時に `T` が値型の場合、変換はボックス化変換として実行されます。 それ以外の場合、暗黙的な参照変換または id 変換として変換が実行されます。
*  `T` から型パラメーター `U`には、`T` が `U` ([型パラメーターの制約](classes.md#type-parameter-constraints)) に依存しています。 実行時に `U` が値型の場合、`T` と `U` は必ず同じ型であり、変換は実行されません。 それ以外の場合、`T` が値型の場合、変換はボックス化変換として実行されます。 それ以外の場合、暗黙的な参照変換または id 変換として変換が実行されます。
*  Null リテラルから `T`に、指定された `T` は参照型であることがわかっています。
*  参照型への暗黙的な変換が含まれている場合、`T` から参照型への変換が `I` 場合 `S0` および `S0` には `S`への id 変換が含まれます。 実行時には、`S0`への変換と同じ方法で変換が実行されます。
*  インターフェイス型またはデリゲート `I0` 型への暗黙的な変換が含まれている場合は、`T` からインターフェイス型に `I` します。また、`I0` は `I` ([変位変換](interfaces.md#variance-conversion)) に変換可能です。 実行時に `T` が値型の場合、変換はボックス化変換として実行されます。 それ以外の場合、暗黙的な参照変換または id 変換として変換が実行されます。

`T` が参照型 ([型パラメーターの制約](classes.md#type-parameter-constraints)) であることがわかっている場合、上記の変換はすべて暗黙の参照変換 ([暗黙の参照変換](conversions.md#implicit-reference-conversions)) として分類されます。 `T` が参照型でないことがわかっている場合、上記の変換はボックス化変換 ([ボックス化変換](conversions.md#boxing-conversions)) として分類されます。

### <a name="user-defined-implicit-conversions"></a>ユーザー定義の暗黙的な変換

ユーザー定義の暗黙の変換は、省略可能な標準の暗黙的な変換で構成され、その後にユーザー定義の暗黙的な変換演算子の実行が続き、その後に省略可能な標準の暗黙的な変換が続きます。 ユーザー定義の暗黙の変換を評価するための正確な規則については、「[ユーザー定義の暗黙的な変換の処理](conversions.md#processing-of-user-defined-implicit-conversions)」を参照してください。

### <a name="anonymous-function-conversions-and-method-group-conversions"></a>匿名関数の変換とメソッドグループの変換

匿名関数とメソッドグループには、それ自体の型はありませんが、デリゲート型または式ツリー型に暗黙的に変換される場合があります。 匿名関数の変換の詳細については、「[匿名関数の変換](conversions.md#anonymous-function-conversions)」および「メソッドグループの変換」の「メソッドグループの変換」を参照し[てください。](conversions.md#method-group-conversions)

## <a name="explicit-conversions"></a>明示的な変換

次の変換は、明示的な変換として分類されます。

*  すべての暗黙的な変換。
*  明示的な数値変換。
*  明示的な列挙変換。
*  明示的な null 許容型変換。
*  明示的な参照変換。
*  明示的なインターフェイス変換。
*  変換のボックス化を解除します。
*  明示的な動的変換
*  ユーザー定義の明示的な変換。

明示的な変換は、キャスト式 ([キャスト式](expressions.md#cast-expressions)) で行うことができます。

明示的な変換のセットには、すべての暗黙的な変換が含まれます。 これは、冗長なキャスト式が許可されることを意味します。

暗黙的な変換ではない明示的な変換とは、常に成功することがわかっていることがわかっている変換、情報を失う可能性がある変換、および明示的に異なる型のドメイン間での変換です。表し.

### <a name="explicit-numeric-conversions"></a>明示的な数値変換

明示的な数値変換は、 *numeric_type*から別の*numeric_type*への変換であり、暗黙的な数値変換 ([暗黙的な数値](conversions.md#implicit-numeric-conversions)変換) はまだ存在しません。

*  `sbyte` から `byte`、`ushort`、`uint`、`ulong`、`char`になります。
*  `byte` から `sbyte` と `char`になります。
*  `short` から `sbyte`、`byte`、`ushort`、`uint`、`ulong`、`char`になります。
*  `ushort` から `sbyte`、`byte`、`short`、または `char`になります。
*  `int` から `sbyte`、`byte`、`short`、`ushort`、`uint`、`ulong`、`char`になります。
*  `uint` から `sbyte`、`byte`、`short`、`ushort`、`int`、`char`になります。
*  `long` から `sbyte`、`byte`、`short`、`ushort`、`int`、`uint`、`ulong`、`char`になります。
*  `ulong` から `sbyte`、`byte`、`short`、`ushort`、`int`、`uint`、`long`、`char`になります。
*  `char` から `sbyte`、`byte`、または `short`。
*  `float` から `sbyte`、`byte`、`short`、`ushort`、`int`、`uint`、`long`、`ulong`、`char`、`decimal`になります。
*  `double` から `sbyte`、`byte`、`short`、`ushort`、`int`、`uint`、`long`、`ulong`、`char`、`float`、`decimal`になります。
*  `decimal` から `sbyte`、`byte`、`short`、`ushort`、`int`、`uint`、`long`、`ulong`、`char`、`float`、`double`になります。

明示的な変換には暗黙的な数値変換と明示的な数値変換がすべて含まれているため、キャスト式 ([cast 式](expressions.md#cast-expressions)) を使用して任意の*numeric_type*から他の任意の*numeric_type*に変換することは常に可能です。

明示的な数値変換によって情報が失われるか、例外がスローされる可能性があります。 明示的な数値変換は、次のように処理されます。

*  整数型から別の整数型への変換では、変換が行われるオーバーフローチェックコンテキスト ([checked および unchecked 演算子](expressions.md#the-checked-and-unchecked-operators)) によって処理が異なります。
    * `checked` のコンテキストでは、ソースオペランドの値が変換先の型の範囲内にある場合、変換は成功しますが、ソースオペランドの値が変換先の型の範囲外である場合は、`System.OverflowException` をスローします。
    * `unchecked` のコンテキストでは、変換は常に成功し、次のように進行します。
        * 変換元の型が変換先の型より大きい場合、変換元の値はその "余分な" 最上位ビットを破棄することで切り詰められます。 結果は変換先の型の値として扱われます。
        * 変換元の型が変換先の型より小さい場合、変換元の値は変換先の型と同じサイズになるように符号かゼロが拡張されます。 変換元の型に符号が付いている場合は符号拡張が利用され、符号が付いていない場合はゼロ拡張が利用されます。 結果は変換先の型の値として扱われます。
        * 変換元の型が変換先の型と同じサイズの場合、変換元の値は変換先の型の値として扱われます。
*  `decimal` から整数型への変換では、変換元の値が、最も近い整数値に0方向に丸められます。この整数値は変換の結果になります。 結果の整数値が変換先の型の範囲外になると、`System.OverflowException` がスローされます。
*  `float` または `double` から整数型への変換の場合、処理は、変換が行われるオーバーフローチェックコンテキスト ([checked および unchecked 演算子](expressions.md#the-checked-and-unchecked-operators)) に依存します。
    * `checked` のコンテキストでは、変換は次のように行われます。
        * オペランドの値が NaN または無限の場合は、`System.OverflowException` がスローされます。
        * それ以外の場合、ソースオペランドは0方向に最も近い整数値に丸められます。 この整数値が変換先の型の範囲内にある場合、この値は変換の結果になります。
        * それ以外の場合は、`System.OverflowException` がスローされます。
    * `unchecked` のコンテキストでは、変換は常に成功し、次のように進行します。
        * オペランドの値が NaN または無限の場合、変換の結果は、変換先の型の指定されていない値になります。
        * それ以外の場合、ソースオペランドは0方向に最も近い整数値に丸められます。 この整数値が変換先の型の範囲内にある場合、この値は変換の結果になります。
        * それ以外の場合、変換の結果は、変換先の型の指定されていない値になります。
*  `double` から `float`への変換では、`double` 値は最も近い `float` 値に丸められます。 `double` 値が小さすぎて `float`として表現できない場合、結果は正のゼロまたは負のゼロになります。 `double` 値が大きすぎて `float`として表現できない場合、結果は正の無限大または負の無限大になります。 `double` 値が NaN の場合、結果も NaN になります。
*  `float` または `double` から `decimal`への変換では、変換元の値が `decimal` 表現に変換され、必要に応じて28進数の小数点以下の最も近い数値に丸められます ([10 進数型](types.md#the-decimal-type))。 ソース値が小さすぎて `decimal`として表現できない場合、結果は0になります。 ソース値が NaN、無限大、または大きすぎて `decimal`として表すことができない場合は、`System.OverflowException` がスローされます。
*  `decimal` から `float` または `double`への変換では、`decimal` 値は最も近い `double` または `float` 値に丸められます。 この変換によって精度が失われる場合がありますが、例外がスローされることはありません。

### <a name="explicit-enumeration-conversions"></a>明示的な列挙変換

明示的な列挙変換は次のとおりです。

*  `sbyte`、`byte`、`short`、`ushort`、`int`、`uint`、`long`、`ulong`、`char`、`float`、`double`、`decimal` を任意の*enum_type*にします。
*  任意の*enum_type*から `sbyte`、`byte`、`short`、`ushort`、`int`、`uint`、`long`、`ulong`、`char`、`float`、`double`、`decimal`になります。
*  任意の*enum_type*から他の*enum_type*に。

2つの型の間の明示的な列挙型変換は、参加している*enum_type*を*enum_type*の基になる型として扱い、結果の型間で暗黙的または明示的な数値変換を実行することによって処理されます。 たとえば、および基になる型が `int`の*enum_type* `E` 場合、`E` から `byte` への変換は、`int` から `byte`への明示的な数値変換 ([明示的](conversions.md#explicit-numeric-conversions)な数値変換) として処理され、`byte` から `E` への変換は暗黙的な数値変換 ([暗黙的](conversions.md#implicit-numeric-conversions)な数値変換) として処理されます。

### <a name="explicit-nullable-conversions"></a>明示的な null 許容変換

***明示的な null 許容***型変換では、null 非許容の値型に対して動作する定義済みの明示的な変換が許可され、これらの型の null 許容形式でも使用できます。 Null 非許容値 `S` 型から `T` null 非許容の値型への変換を行う定義済みの明示的な変換 ([id 変換](conversions.md#identity-conversion)、[暗黙的な数値変換](conversions.md#implicit-numeric-conversions)、[暗黙的な列挙変換](conversions.md#implicit-enumeration-conversions)、[明示的な数値変換](conversions.md#explicit-numeric-conversions)、明示的な[列挙](conversions.md#explicit-enumeration-conversions)変換) には、次の null 許容変換が存在します。

*  `S?` から `T?`への明示的な変換。
*  `S` から `T?`への明示的な変換。
*  `S?` から `T`への明示的な変換。

`S` から `T` への基になる変換に基づく null 許容型変換の評価は次のように行われます。

*  Null 許容型変換が `S?` から `T?`の場合は、次のようになります。
    * ソース値が null (`HasValue` プロパティが false) の場合、結果は `T?`型の null 値になります。
    * それ以外の場合、変換は `S?` から `S`へのラップ解除として評価された後、`S` から `T`への基になる変換と、その後に `T` から `T?`へのラップが行われます。
*  Null 許容型変換が `S` から `T?`に対して行われる場合、変換は `S` から `T` の基になる変換として評価され、その後、`T` から `T?`へのラップが行われます。
*  Null 許容型変換が `S?` から `T`に対して行われる場合、変換は `S?` から `S` のラップ解除として評価され、その後に `S` から `T`への基になる変換が行われます。

Null 許容値のラップを解除しようとすると、値が `null`場合に例外がスローされることに注意してください。

### <a name="explicit-reference-conversions"></a>明示的な参照変換

明示的な参照変換は次のとおりです。

*  `object` から、他の*reference_type*に `dynamic` します。
*  任意の*class_type* `S` から任意の*class_type* `T`への `S` は、`T`の基本クラスです。
*  任意の*class_type* `S` から任意の*interface_type* `T`への `S` はシールされていませんが、`S` は実装されていません。
*  任意の*interface_type* `T`*class_type* `S` から、`T` を実装 `T` がシールされていない、または指定されている場合は、`S`を実装します。
*  任意の*interface_type* `S` から、`S` は `T`から派生したものではなく、任意の*interface_type* `T`になります。
*  要素型が `T` の*array_type* `S` から、次のすべてが満たされていれば、要素型が `TE`の*array_type*に `SE` ます。
    * `S` と `T` は要素の型のみが異なります。 言い換えると、`S` と `T` の次元数が同じになります。
    * `SE` と `TE` は両方とも*reference_type*です。
    * `SE` から `TE`への明示的な参照変換が存在します。
*  `System.Array` と、それが実装するインターフェイスから、任意の*array_type*にします。
*  `S` から `T`への明示的な参照変換がある場合は、1次元配列型から `System.Collections.Generic.IList<T>` とその基本インターフェイスを `S[]` します。
*  `S` から `T`への明示的な id または参照の変換がある場合は、`System.Collections.Generic.IList<S>` とその基本インターフェイスから、`T[]`にします。
*  `System.Delegate` と、それが実装するインターフェイスから、任意の*delegate_type*にします。
*  参照型から参照型への明示的な参照変換がある場合は `T` 参照型から参照型への明示的な参照変換があり、`T0` には `T`の id 変換がある場合は `T0`。
*  参照型からインターフェイスまたはデリゲート型への明示的な参照変換が含まれている場合 `T`、その型がインターフェイスまたはデリゲート `T0` 型への明示的な参照変換を持っている場合、または `T0` が `T` に変換可能であるか `T` に変換可能かどうかを示します ([分散変換](interfaces.md#variance-conversion))。
*  `D<S1...Sn>` から `D<T1...Tn>` `D<X1...Xn>` が汎用デリゲート型である場合、`D<S1...Sn>` は `D<T1...Tn>`との互換性がないか、`Xi` の型パラメーター `D` ごとに次のようになります。
    * `Xi` が不変の場合、`Si` は `Ti`と同じになります。
    * `Xi` が共変の場合は、`Si` から `Ti`への暗黙的または明示的な id または参照の変換が存在します。
    * `Xi` が反変の場合、`Si` と `Ti` は両方とも同じか、または両方の参照型になります。
*  参照型として認識されている型パラメーターを使用する明示的な変換。 型パラメーターを使用する明示的な変換の詳細については、「型パラメーターを使用した[明示的な変換](conversions.md#explicit-conversions-involving-type-parameters)」を参照してください。

明示的な参照変換とは、それらが正しいことを確認するためにランタイムチェックを必要とする参照型間の変換です。

実行時に明示的な参照変換を成功させるには、ソースオペランドの値が `null`であるか、またはソースオペランドによって参照されるオブジェクトの実際の型が、暗黙的な参照変換 ([暗黙の参照](conversions.md#implicit-reference-conversions)変換) またはボックス化変換 ([ボックス](conversions.md#boxing-conversions)化変換) によって対象の型に変換できる型である必要があります。 明示的な参照変換が失敗すると、`System.InvalidCastException` がスローされます。

暗黙的または明示的な参照変換では、変換するオブジェクトの参照 id は変更されません。 つまり、参照変換によって参照の型が変更されても、参照先のオブジェクトの型または値が変更されることはありません。

### <a name="unboxing-conversions"></a>ボックス化解除

ボックス化解除変換は、参照型を明示的に*value_type*に変換することを許可します。 ボックス化解除変換は、型 `object`、`dynamic` および `System.ValueType` から任意の*non_nullable_value_type*に、任意の*interface_type*から*non_nullable_value_type*を実装する任意の*interface_type*に変換されます。 さらに、型 `System.Enum` を任意の*enum_type*にボックス化解除できます。

参照型から*nullable_type*の基になる*non_nullable_value_type*にアンボックス変換が存在する場合、参照型から*nullable_type*へのアンボックス変換が存在します。

インターフェイス `I0` 型からのアンボックス変換があり、`I0` が `I`への id 変換を持っている場合、`S` 値型には、インターフェイス型から `I` のボックス化変換があります。

インターフェイス型またはデリゲート `I0` 型からのアンボックス変換がある場合、または `I0` が `I` に対して分散変換可能であるか、`I` に変換可能かどうか `I0` ([変位変換](interfaces.md#variance-conversion)) である場合、値型 `S` は、インターフェイス型からのボックス化変換を `I` ます。

ボックス化解除操作は、最初にオブジェクトインスタンスが、指定された*value_type*のボックス化された値であることを確認し、次にインスタンスから値をコピーすることで構成されます。 *Nullable_type*への null 参照のボックス化を解除すると、 *nullable_type*の null 値が生成されます。 構造体は、すべての構造体 ([継承](structs.md#inheritance)) の基本クラスであるため、`System.ValueType`型からのボックス化を解除できます。

ボックス化解除変換の詳細については、「[ボックス化変換](types.md#unboxing-conversions)」を参照してください。

### <a name="explicit-dynamic-conversions"></a>明示的な動的変換

明示的な動的変換は、`dynamic` 型の式から `T`任意の型に存在します。 変換は動的にバインドされます ([動的バインド](expressions.md#dynamic-binding))。これは、`T`する式の実行時の型から、実行時に明示的な変換が行われることを意味します。 変換が見つからない場合は、実行時例外がスローされます。

変換の動的バインドが望ましくない場合は、式を最初に `object`に変換し、次に目的の型に変換できます。

次のクラスが定義されているとします。
```csharp
class C
{
    int i;

    public C(int i) { this.i = i; }

    public static explicit operator C(string s) 
    {
        return new C(int.Parse(s));
    }
}
```

明示的な動的変換の例を次に示します。
```csharp
object o  = "1";
dynamic d = "2";

var c1 = (C)o; // Compiles, but explicit reference conversion fails
var c2 = (C)d; // Compiles and user defined conversion succeeds
```

`o` から `C` への最適な変換は、明示的な参照変換としてコンパイル時に検出されます。 これは、実際には `"1"` が `C`ではないため、実行時に失敗します。 ただし、`d` から `C` への変換は、明示的な動的変換として実行時に中断されます。実行時には、`d` -- の実行時の型から `string` へのユーザー定義の変換が検出され、成功します。

### <a name="explicit-conversions-involving-type-parameters"></a>型パラメーターを含む明示的な変換

指定された型パラメーター `T`には、次の明示的な変換が存在します。

*  `T` の有効な基本クラス `C` から、`C` の任意の基底クラスから `T`に `T` します。 実行時に `T` が値型の場合、変換はボックス化解除変換として実行されます。 それ以外の場合は、明示的な参照変換または id 変換として変換が実行されます。
*  任意のインターフェイス型から `T`します。 実行時に `T` が値型の場合、変換はボックス化解除変換として実行されます。 それ以外の場合は、明示的な参照変換または id 変換として変換が実行されます。
*  `T` から `I`への暗黙的な変換は行われていませんが、指定されたすべての*interface_type* `I` に `T` ます。 実行時に `T` が値型の場合、変換はボックス化変換として実行され、その後に明示的な参照変換が行われます。 それ以外の場合は、明示的な参照変換または id 変換として変換が実行されます。
*  型パラメーターから `T`への `U` は、`T` が `U` ([型パラメーターの制約](classes.md#type-parameter-constraints)) に依存しています。 実行時に `U` が値型の場合、`T` と `U` は必ず同じ型であり、変換は実行されません。 それ以外の場合、`T` が値型の場合、変換はボックス化解除変換として実行されます。 それ以外の場合は、明示的な参照変換または id 変換として変換が実行されます。

`T` が参照型であることがわかっている場合、上記の変換はすべて、明示的な参照変換 ([明示的な参照変換](conversions.md#explicit-reference-conversions)) として分類されます。 `T` が参照型でないことがわかっている場合、上記の変換は、ボックス化解除変換 ([ボックス化解除](conversions.md#unboxing-conversions)) として分類されます。

上記のルールでは、制約のない型パラメーターから非インターフェイス型への直接明示的な変換は許可されていません。 このルールの理由は、混乱を防ぎ、そのような変換のセマンティクスを明確にするためです。 たとえば、次のような宣言があるとします。
```csharp
class X<T>
{
    public static long F(T t) {
        return (long)t;                // Error 
    }
}
```

`t` から `int` への直接的な明示的な変換が許可されている場合は、`X<int>.F(7)` が `7L`を返すことが簡単であると考えられます。 ただし、標準の数値変換は、バインド時に型が数値であることがわかっている場合にのみ考慮されるため、そうではありません。 このようなセマンティクスを明確にするために、上記の例を記述する必要があります。
```csharp
class X<T>
{
    public static long F(T t) {
        return (long)(object)t;        // Ok, but will only work when T is long
    }
}
```

このコードはコンパイルされるようになりましたが、実行時に `X<int>.F(7)` を実行すると、ボックス化された `int` を `long`に直接変換できないため、例外がスローされます。

### <a name="user-defined-explicit-conversions"></a>ユーザー定義の明示的な変換

ユーザー定義の明示的な変換は、省略可能な標準の明示的な変換で構成され、その後にユーザー定義の暗黙的または明示的な変換演算子を実行した後に、別のオプションで標準の明示的な変換を実行します。 ユーザー定義の明示的な変換を評価するための正確な規則については、「[ユーザー定義の明示的な変換の処理](conversions.md#processing-of-user-defined-explicit-conversions)」を参照してください。

## <a name="standard-conversions"></a>標準変換

標準変換は、ユーザー定義の変換の一部として発生する可能性のある定義済みの変換です。

### <a name="standard-implicit-conversions"></a>標準の暗黙的な変換

次の暗黙の変換は、標準の暗黙的な変換として分類されます。

*  Id 変換 ([id 変換](conversions.md#identity-conversion))
*  暗黙の数値変換 ([暗黙的な数値変換](conversions.md#implicit-numeric-conversions))
*  暗黙の null 許容変換 (暗黙の null[許容](conversions.md#implicit-nullable-conversions)変換)
*  暗黙の参照変換 ([暗黙的な参照変換](conversions.md#implicit-reference-conversions))
*  ボックス化変換 ([ボックス化変換](conversions.md#boxing-conversions))
*  暗黙の定数式の変換 ([暗黙の動的変換](conversions.md#implicit-dynamic-conversions))
*  型パラメーターを含む暗黙の型変換 ([型パラメーターを含む暗黙](conversions.md#implicit-conversions-involving-type-parameters)の型変換)

標準の暗黙の変換は、明示的にユーザー定義の暗黙的な変換を除外します。

### <a name="standard-explicit-conversions"></a>標準の明示的な変換

標準の明示的な変換は、すべての標準の暗黙的な変換に加え、逆の標準の暗黙的な変換が存在する明示的な変換のサブセットを加えたものです。 言い換えると、標準の暗黙的な変換が型 `A` から `B`型に存在する場合は、型 `A` から型 `B` および型の `B` への標準の明示的な変換が存在します。

## <a name="user-defined-conversions"></a>ユーザー定義の変換

C#定義済みの暗黙的な変換と明示的な変換を、***ユーザー定義の変換***によって拡張できるようにします。 ユーザー定義の変換は、クラスおよび構造体型の変換演算子 ([変換演算子](classes.md#conversion-operators)) を宣言することによって導入されます。

### <a name="permitted-user-defined-conversions"></a>許可されたユーザー定義変換

C#特定のユーザー定義変換のみを宣言できます。 特に、既存の暗黙的または明示的な変換を再定義することはできません。

指定されたソース型 `S` とターゲット型 `T`の場合、`S` または `T` が null 許容型である場合は、`S0` と `T0` がその基になる型を参照するようにします。それ以外の場合、`S0` と `T0` はそれぞれ `S` と `T` になります。 クラスまたは構造体は、次のすべての条件を満たす場合にのみ、ソース `S` 型からターゲット `T` 型への変換を宣言することができます。

*  `S0` と `T0` の種類は異なります。
*  `S0` または `T0` は、演算子の宣言が行われるクラスまたは構造体の型です。
*  `S0` も `T0` も*interface_type*ではありません。
*  ユーザー定義の変換を除外すると、`S` から `T` または `T` から `S`への変換は存在しません。

ユーザー定義の変換に適用される制限については、「[変換演算子](classes.md#conversion-operators)」で詳しく説明します。

### <a name="lifted-conversion-operators"></a>リフト変換演算子

Null 非許容の値 `S` 型から null 非許容の値 `T`型に変換するユーザー定義の変換演算子を指定した場合、`S?` から `T?`に変換するリフトされた***変換演算子***が存在します。 このリフトされた変換演算子は、`S?` から `S` へのラップ解除を実行します。その後、`S` から `T` へのユーザー定義変換と、`T` から `T?`へのラップが実行されます。ただし、null 値 `S?` は null 値 `T?`に直接変換されます。

リフトされた変換演算子には、基になるユーザー定義変換演算子と同じ暗黙的または明示的な分類があります。 "ユーザー定義変換" という用語は、ユーザー定義変換演算子とリフト変換演算子の両方を使用する場合に適用されます。

### <a name="evaluation-of-user-defined-conversions"></a>ユーザー定義変換の評価

ユーザー定義の変換は、***ソース型***と呼ばれる型の値を、***ターゲット型***と呼ばれる別の型に変換します。 ユーザー定義の変換の評価では、特定のソースとターゲットの種類に対して***最も限定的***なユーザー定義変換演算子が検索されます。 この決定は、次のいくつかの手順に分かれています。

*  ユーザー定義の変換演算子が考慮されるクラスと構造体のセットを検索します。 このセットは、ソースの型とその基本クラス、およびターゲットの型とその基本クラスで構成されます (クラスと構造体のみがユーザー定義の演算子を宣言できること、および非クラス型には基底クラスがないという暗黙の想定があります)。 この手順では、ソースまたはターゲットのどちらかの型が*nullable_type*の場合、基になる型が代わりに使用されます。
*  この一連の型から、適用可能なユーザー定義およびリフト変換演算子を決定します。 変換演算子を適用できるようにするには、ソース型から演算子のオペランド型への標準変換 ([標準](conversions.md#standard-conversions)変換) を実行できる必要があります。また、演算子の結果型からターゲット型への標準変換を実行できる必要があります。
*  適用可能なユーザー定義演算子のセットから、明確に特定できる演算子を決定します。 一般的に、最も具体的な演算子は、変換元の型に対してオペランドの型が "最も近い" 演算子で、結果の型が対象の型に "最も近い" になります。 ユーザー定義の変換演算子は、リフト変換演算子よりも優先されます。 特定のユーザー定義変換演算子を設定するための正確な規則は、次のセクションで定義されています。

最も限定的なユーザー定義変換演算子が特定されたら、ユーザー定義変換の実際の実行では、次の3つの手順が必要になります。

*  最初に、必要に応じて、変換元の型からユーザー定義またはリフトされた変換演算子のオペランドの型への標準変換を実行します。
*  次に、ユーザー定義変換演算子またはリフト変換演算子を呼び出して変換を実行します。
*  最後に、必要に応じて、ユーザー定義またはリフトされた変換演算子の結果型から対象の型への標準変換を実行します。

ユーザー定義の変換の評価では、複数のユーザー定義変換演算子またはリフト変換演算子は必要ありません。 言い換えると、型 `S` から型 `T` への変換では、最初に `S` から `X` へのユーザー定義変換が実行され、次に `X` から `T`へのユーザー定義変換が実行されることはありません。

ユーザー定義の暗黙的または明示的な変換の評価の正確な定義については、次のセクションで説明します。 定義では、次の用語が使用されます。

*  標準の暗黙的な変換 ([標準の暗黙的な変換](conversions.md#standard-implicit-conversions)) が型 `A` から `B`型に存在する場合、`A` も `B` も*interface_type****に含ま***れていないと、`A` が `B`***を包含し***ていると言います。
*  型のセットの中で***最も外側***にある型は、セット内の他のすべての型を含む1つの型です。 1つの型に他のすべての型が含まれていない場合、そのセットには最も外側の型がありません。 より直観的な用語では、最も外側の型は、セット内の "最大" 型です。これは、他の型を暗黙的に変換できる1つの型です。
*  型のセットの中で***最も内側***にある型は、セット内の他のすべての型に包含されている型です。 他のすべての型に包含されている型がない場合は、そのセットに最も包含されていない型はありません。 より直観的な用語では、最も包含されている型は、セット内の "最小" 型です。これは、他の型に暗黙的に変換できる1つの型です。

### <a name="processing-of-user-defined-implicit-conversions"></a>ユーザー定義の暗黙的な変換の処理

型 `S` から型 `T` へのユーザー定義の暗黙的な変換は、次のように処理されます。

*  `S0` と `T0`の種類を決定します。 `S` または `T` が null 許容型である場合、`S0` と `T0` はその基になる型です。それ以外の場合は、`S0` と `T0` がそれぞれ `S` と `T` になります。
*  ユーザー定義の変換演算子が考慮される型のセット (`D`) を検索します。 このセットは、`S0` (`S0` がクラスまたは構造体である場合)、`S0` の基本クラス (`S0` がクラスの場合)、`T0` (`T0` がクラスまたは構造体の場合) で構成されます。
*  適用可能なユーザー定義およびリフト変換演算子のセットを検索し、`U`します。 このセットは、`S` を含む型から `T`に含まれる型への変換を行う `D` のクラスまたは構造体によって宣言された、ユーザー定義の、リフトされた暗黙の変換演算子で構成されます。 `U` が空の場合、変換は定義されていないため、コンパイル時エラーが発生します。
*  `U`内の演算子の最も具体的なソースの種類である `SX`を検索します。
    * `U` 内のいずれかの演算子が `S`から変換される場合、`SX` は `S`ます。
    * それ以外の場合、`SX` は `U`内の演算子のソースの種類の組み合わせにおいて最も包含されている型です。 最も包含されている型が1つだけ見つからない場合、変換はあいまいで、コンパイル時エラーが発生します。
*  `U`内の演算子の最も具体的な対象の型である `TX`を検索します。
    * `U` のいずれかの演算子が `T`に変換される場合、`TX` は `T`ます。
    * それ以外の場合、`TX` は、`U`内の演算子の対象の型を組み合わせたセット内で最も外側にある型になります。 最も外側の型が1つだけ見つからない場合、変換はあいまいで、コンパイル時エラーが発生します。
*  最も具体的な変換演算子を見つけます。
    * `SX` から `TX`に変換するユーザー定義の変換演算子を1つだけ含む `U` 場合は、これが最も具体的な変換演算子です。
    * それ以外の `U` 場合、`SX` から `TX`に変換するリフト変換演算子が1つだけ含まれている場合は、これが最も具体的な変換演算子になります。
    * それ以外の場合、変換はあいまいで、コンパイル時エラーが発生します。
*  最後に、変換を適用します。
    * `S` が `SX`ない場合は、`S` から `SX` への標準の暗黙的な変換が実行されます。
    * `SX` から `TX`に変換するために、最も具体的な変換演算子が呼び出されます。
    * `TX` が `T`ない場合は、`TX` から `T` への標準の暗黙的な変換が実行されます。

### <a name="processing-of-user-defined-explicit-conversions"></a>ユーザー定義の明示的な変換の処理

`S` 型から `T` 型へのユーザー定義の明示的な変換は、次のように処理されます。

*  `S0` と `T0`の種類を決定します。 `S` または `T` が null 許容型である場合、`S0` と `T0` はその基になる型です。それ以外の場合は、`S0` と `T0` がそれぞれ `S` と `T` になります。
*  ユーザー定義の変換演算子が考慮される型のセット (`D`) を検索します。 このセットは、`S0` (`S0` がクラスまたは構造体である場合)、`S0` の基本クラス (`S0` がクラスの場合)、`T0` (`T0` がクラスまたは構造体の場合)、`T0` の基本クラス (`T0` がクラスの場合) で構成されます。
*  適用可能なユーザー定義およびリフト変換演算子のセットを検索し、`U`します。 このセットは、`S` によって包含または包含されている型を `T`によって包含または包含されている型に変換する、`D` のクラスまたは構造体によって宣言された、ユーザー定義の、リフトされた暗黙的または明示的な変換演算子で構成されます。 `U` が空の場合、変換は定義されていないため、コンパイル時エラーが発生します。
*  `U`内の演算子の最も具体的なソースの種類である `SX`を検索します。
    * `U` 内のいずれかの演算子が `S`から変換される場合、`SX` は `S`ます。
    * それ以外の場合、`U` 内のいずれかの演算子が `S`を含む型から変換される場合、`SX` は、それらの演算子のソース型の組み合わせで最も包含されている型になります。 最も包含されていない型が見つからない場合は、変換があいまいになり、コンパイル時エラーが発生します。
    * それ以外の場合、`SX` は `U`内の演算子のソースの種類の組み合わせにおいて最も外側の型になります。 最も外側の型が1つだけ見つからない場合、変換はあいまいで、コンパイル時エラーが発生します。
*  `U`内の演算子の最も具体的な対象の型である `TX`を検索します。
    * `U` のいずれかの演算子が `T`に変換される場合、`TX` は `T`ます。
    * それ以外の場合、`U` 内のいずれかの演算子が `T`によって包含されている型に変換される場合、`TX` は、それらの演算子の対象となる型の組み合わせのセット内で最も外側の型になります。 最も外側の型が1つだけ見つからない場合、変換はあいまいで、コンパイル時エラーが発生します。
    * それ以外の場合、`TX` は、`U`内の演算子の対象となる型の組み合わせで最も包含される型です。 最も包含されていない型が見つからない場合は、変換があいまいになり、コンパイル時エラーが発生します。
*  最も具体的な変換演算子を見つけます。
    * `SX` から `TX`に変換するユーザー定義の変換演算子を1つだけ含む `U` 場合は、これが最も具体的な変換演算子です。
    * それ以外の `U` 場合、`SX` から `TX`に変換するリフト変換演算子が1つだけ含まれている場合は、これが最も具体的な変換演算子になります。
    * それ以外の場合、変換はあいまいで、コンパイル時エラーが発生します。
*  最後に、変換を適用します。
    * `S` が `SX`ない場合は、`S` から `SX` への標準の明示的な変換が実行されます。
    * `SX` から `TX`に変換するために、ユーザー定義の最も限定的な変換演算子が呼び出されます。
    * `TX` が `T`ない場合は、`TX` から `T` への標準の明示的な変換が実行されます。

## <a name="anonymous-function-conversions"></a>匿名関数の変換

*Anonymous_method_expression*または*lambda_expression*は、匿名関数 ([匿名関数式](expressions.md#anonymous-function-expressions)) として分類されます。 式に型がありませんが、互換性のあるデリゲート型または式ツリー型に暗黙的に変換できます。 具体的には、匿名関数 `F` は、指定された `D` デリゲート型と互換性があります。

*  `F` に*anonymous_function_signature*が含まれている場合は、`D` と `F` のパラメーターの数が同じになります。
*  `F` に*anonymous_function_signature*が含まれていない場合、`D` のパラメーターに `out` parameter 修飾子が指定されていない限り、`D` には任意の型の0個以上のパラメーターを含めることができます。
*  `F` に明示的に型指定されたパラメーターリストがある場合、`D` 内の各パラメーターの型と修飾子は `F`内の対応するパラメーターと同じになります。
*  `F` に暗黙的に型指定されたパラメーターリストがある場合、`D` には `ref` または `out` パラメーターがありません。
*  `F` の本体が式であり、`D` が `void` の戻り値の型であるか、または `F` が非同期であり、`D` の戻り値の型が `Task`である場合、`F` の本体*は、`D`(* [式ステートメント](statements.md#expression-statements)) として許可される有効な式 (wrt[式](expressions.md)) になります。
*  `F` の本体がステートメントブロックであり、`D` が `void` の戻り値の型を持っている場合、または `F` が非同期で、`D` の戻り値の型が `Task`の場合、`F` の本体は有効なステートメントブロック (wrt [block](statements.md#blocks)) で、`D`ステートメントで式が指定されていません。
*  `F` の本体が式であり *、`F` が*非同期ではなく、`D` の戻り値の `T`型が void でない場合、*または*`F` が async で、`D` が戻り値の型 `Task<T>`の場合、`F` の本体は、暗黙的に `D`に変換できる有効な式 (wrt[式](expressions.md)) になります。
*  `F` の本体がステートメントブロックで、`F` が非同期*ではなく*、`D` が void 以外の戻り値の型 `T`の場合、*または*`F` が async で `D` が戻り値の型 `Task<T>`である場合、`F` の各パラメーターに `D`の対応するパラメーターの型が指定されている場合、`F` の本体は到達できないエンドポイントを持つ有効なステートメントブロック (wrt [block](statements.md#blocks)) です。この場合、各 `return` ステートメントは、暗黙的に変換可能な式を指定します。

簡潔にするために、このセクションでは、タスクの種類 `Task` および `Task<T>` ([非同期関数](classes.md#async-functions)) に短い形式を使用します。

ラムダ式 `F` は、`F` がデリゲート型 `D`と互換性がある場合に `Expression<D>` 式ツリー型と互換性があります。 これは匿名メソッドには適用されず、ラムダ式にのみ適用されることに注意してください。

特定のラムダ式は、式のツリー型に変換できません。変換が*存在*する場合でも、コンパイル時に失敗します。 ラムダ式の場合は、次のようになります。

*  *ブロック*本体がある
*  単純型または複合型の代入演算子を含んでいます
*  動的にバインドされた式を含む
*  非同期

次の例では、汎用デリゲート `Func<A,R>` 型を使用します。これは、型 `A` の引数を受け取り、`R`型の値を返す関数を表します。
```csharp
delegate R Func<A,R>(A arg);
```

割り当て
```csharp
Func<int,int> f1 = x => x + 1;                 // Ok

Func<int,double> f2 = x => x + 1;              // Ok

Func<double,int> f3 = x => x + 1;              // Error

Func<int, Task<int>> f4 = async x => x + 1;    // Ok
```
各匿名関数のパラメーターと戻り値の型は、匿名関数が割り当てられている変数の型によって決まります。

最初の代入は、匿名関数をデリゲート `Func<int,int>` 型に正常に変換します。これは、`x` に型 `int`が指定されている場合、`x+1` は型 `int`に暗黙的に変換できる有効な式であるためです。

同様に、2番目の代入は、匿名関数をデリゲート `Func<int,double>` 型に正常に変換します。これは、`x+1` (型 `int`) の結果が暗黙的に型 `double`に変換可能であるためです。

ただし、3番目の代入はコンパイル時エラーになります。これは、`x` に型 `double`が指定されている場合、`x+1` (型 `double`) の結果が型 `int`に暗黙的に変換可能ではないためです。

4番目の代入は、匿名の非同期関数をデリゲート型 `Func<int, Task<int>>` に正常に変換します。これは、`x+1` (型 `int`) の結果が、タスクの種類 `Task<int>`の `int` 結果の型に暗黙的に変換できるためです。

匿名関数は、オーバーロードの解決に影響を与える可能性があり、型の推定に関与します。 詳細については、「[関数メンバー](expressions.md#function-members) 」を参照してください。

### <a name="evaluation-of-anonymous-function-conversions-to-delegate-types"></a>デリゲート型への匿名関数変換の評価

匿名関数をデリゲート型に変換すると、匿名関数を参照するデリゲートインスタンスと、評価時にアクティブであるキャプチャされた外部変数の (空の場合もありますが) セットが生成されます。 デリゲートが呼び出されると、匿名関数の本体が実行されます。 本文内のコードは、デリゲートによって参照されるキャプチャされた外部変数のセットを使用して実行されます。

匿名関数から生成されたデリゲートの呼び出しリストには、1つのエントリが含まれます。 デリゲートの正確なターゲットオブジェクトとターゲットメソッドは指定されていません。 特に、デリゲートのターゲットオブジェクトが `null`、外側の関数メンバーの `this` 値、またはその他のオブジェクトであるかどうかは指定されていません。

同じ (場合によっては空の) キャプチャされた外部変数インスタンスを同じデリゲート型に対して同じ匿名関数から変換すると、同じデリゲートインスタンスを返すことができます (ただし、必須ではありません)。 ここでは、意味的に同じ用語が使用されています。これは、匿名関数の実行によって、同じ引数を指定した場合と同じ効果が生成されることを意味します。 この規則は、次のようなコードを最適化することを許可します。

```csharp
delegate double Function(double x);

class Test
{
    static double[] Apply(double[] a, Function f) {
        double[] result = new double[a.Length];
        for (int i = 0; i < a.Length; i++) result[i] = f(a[i]);
        return result;
    }

    static void F(double[] a, double[] b) {
        a = Apply(a, (double x) => Math.Sin(x));
        b = Apply(b, (double y) => Math.Sin(y));
        ...
    }
}
```

2つの匿名関数デリゲートは、キャプチャされた外部変数と同じ (空の) セットを持つため、匿名関数は意味が同じであるため、コンパイラはデリゲートが同じターゲットメソッドを参照することを許可します。 実際には、コンパイラは、両方の匿名関数式からまったく同じデリゲートインスタンスを返すことができます。

### <a name="evaluation-of-anonymous-function-conversions-to-expression-tree-types"></a>式ツリー型への匿名関数変換の評価

匿名関数から式ツリー型への変換では、式ツリー ([式ツリー型](types.md#expression-tree-types)) が生成されます。 より正確には、匿名関数の変換を評価すると、匿名関数自体の構造を表すオブジェクト構造の構築につながります。 式ツリーの正確な構造と、それを作成するための正確なプロセスは、実装が定義されています。

### <a name="implementation-example"></a>実装例

このセクションでは、他C#の構造体の観点から、匿名関数の変換を実装する方法について説明します。 ここで説明する実装は、Microsoft C#コンパイラで使用されているのと同じ原則に基づいていますが、必須の実装ではなく、可能な唯一の方法でもあります。 ここでは、式ツリーへの変換について簡単に説明します。正確なセマンティクスは、この仕様の範囲外です。

このセクションの残りの部分では、さまざまな特性を持つ匿名関数を含むコードの例をいくつか示します。 各例では、他のC#コンストラクトのみを使用するコードへの対応する変換が提供されています。 この例では、識別子 `D` は、次のデリゲート型を表すことによって想定されています。
```csharp
public delegate void D();
```

匿名関数の最も単純な形式は、外部変数をキャプチャする関数です。
```csharp
class Test
{
    static void F() {
        D d = () => { Console.WriteLine("test"); };
    }
}
```

これは、匿名関数のコードが配置される、コンパイラによって生成された静的メソッドを参照するデリゲートのインスタンス化に変換できます。
```csharp
class Test
{
    static void F() {
        D d = new D(__Method1);
    }

    static void __Method1() {
        Console.WriteLine("test");
    }
}
```

次の例では、匿名関数は `this`のインスタンスメンバーを参照します。
```csharp
class Test
{
    int x;

    void F() {
        D d = () => { Console.WriteLine(x); };
    }
}
```

これは、匿名関数のコードを含む、コンパイラによって生成されるインスタンスメソッドに変換できます。
```csharp
class Test
{
    int x;

    void F() {
        D d = new D(__Method1);
    }

    void __Method1() {
        Console.WriteLine(x);
    }
}
```

この例では、匿名関数はローカル変数をキャプチャします。
```csharp
class Test
{
    void F() {
        int y = 123;
        D d = () => { Console.WriteLine(y); };
    }
}
```

ローカル変数の有効期間は、少なくとも匿名関数デリゲートの有効期間に拡張する必要があります。 これは、コンパイラによって生成されるクラスのフィールドにローカル変数を "hoisting" することによって実現できます。 ローカル変数 ([ローカル変数のインスタンス化](expressions.md#instantiation-of-local-variables)) のインスタンス化は、コンパイラによって生成されたクラスのインスタンスの作成に対応し、ローカル変数へのアクセスは、コンパイラによって生成されるクラスのインスタンス内のフィールドへのアクセスに対応します。 さらに、匿名関数は、コンパイラによって生成されるクラスのインスタンスメソッドになります。
```csharp
class Test
{
    void F() {
        __Locals1 __locals1 = new __Locals1();
        __locals1.y = 123;
        D d = new D(__locals1.__Method1);
    }

    class __Locals1
    {
        public int y;

        public void __Method1() {
            Console.WriteLine(y);
        }
    }
}
```

最後に、次の匿名関数は、`this`、および有効期間が異なる2つのローカル変数をキャプチャします。
```csharp
class Test
{
    int x;

    void F() {
        int y = 123;
        for (int i = 0; i < 10; i++) {
            int z = i * 2;
            D d = () => { Console.WriteLine(x + y + z); };
        }
    }
}
```

ここでは、別のブロックのローカル変数が独立した有効期間を持つことができるように、ローカルがキャプチャされた各ステートメントブロックに対して、コンパイラによって生成されるクラスが作成されます。 `__Locals2`のインスタンス (内部ステートメントブロックに対してコンパイラによって生成されるクラス) には、ローカル変数 `z` と `__Locals1`のインスタンスを参照するフィールドが含まれています。  `__Locals1`のインスタンス (外側のステートメントブロックに対してコンパイラによって生成されるクラス) には、ローカル変数 `y` と、外側の関数メンバーの `this` を参照するフィールドが含まれています。 これらのデータ構造を使用すると、`__Local2`のインスタンスを介してキャプチャされたすべての外部変数にアクセスできます。そのため、匿名関数のコードは、そのクラスのインスタンスメソッドとして実装できます。

```csharp
class Test
{
    void F() {
        __Locals1 __locals1 = new __Locals1();
        __locals1.__this = this;
        __locals1.y = 123;
        for (int i = 0; i < 10; i++) {
            __Locals2 __locals2 = new __Locals2();
            __locals2.__locals1 = __locals1;
            __locals2.z = i * 2;
            D d = new D(__locals2.__Method1);
        }
    }

    class __Locals1
    {
        public Test __this;
        public int y;
    }

    class __Locals2
    {
        public __Locals1 __locals1;
        public int z;

        public void __Method1() {
            Console.WriteLine(__locals1.__this.x + __locals1.y + z);
        }
    }
}
```

ここでは、ローカル変数をキャプチャするために使用するのと同じ手法を、匿名関数を式ツリーに変換するときにも使用できます。コンパイラによって生成されたオブジェクトへの参照は式ツリーに格納でき、ローカル変数へのアクセスは次のようになります。これらのオブジェクトに対するフィールドアクセスとして表されます。 この方法の利点は、"リフトされた" ローカル変数をデリゲートと式ツリーの間で共有できることです。

## <a name="method-group-conversions"></a>メソッドグループの変換

メソッドグループ ([式の分類](expressions.md#expression-classifications)) から互換性のあるデリゲート型への暗黙の変換 ([暗黙](conversions.md#implicit-conversions)の変換) が存在します。 デリゲート型 `D` と、メソッドグループとして分類される式 `E` が指定されている場合、次に示すように、`E` のパラメーターの型と修飾子を使用して構築された引数リストに、`D`が通常の形式 ([適用可能な関数メンバー](expressions.md#applicable-function-member)) に適用可能なメソッドが少なくとも1つ含まれている場合は、`D` `E` から

メソッドグループからデリゲート `D` 型への変換のコンパイル時アプリケーション `E` については、次の説明を参照してください。 `E` から `D` への暗黙的な変換が存在しても、変換のコンパイル時のアプリケーションがエラーなしで成功するとは限りません。

*  フォーム `E(A)`のメソッド呼び出し ([メソッド](expressions.md#method-invocations)の呼び出し) に対応する1つのメソッド `M` が選択されていますが、次のように変更されています。
    * 引数リスト `A` は式のリストであり、それぞれが変数として分類され、`D`の*formal_parameter_list*内の対応するパラメーターの型と修飾子 (`ref` または `out`) を使用します。
    * 考慮される候補メソッドは、通常の形式 ([適用可能な関数メンバー](expressions.md#applicable-function-member)) で適用可能なメソッドのみであり、拡張フォームにのみ適用されるものではありません。
*  [メソッド呼び出し](expressions.md#method-invocations)のアルゴリズムによってエラーが発生した場合、コンパイル時エラーが発生します。 それ以外の場合、`D` と同じ数のパラメーターを持ち、変換が存在していると見なされる `M`、1つの最適なメソッドが生成されます。
*  選択されたメソッド `M` は、デリゲート型 `D`と互換性がある ([デリゲート互換性](delegates.md#delegate-compatibility)) 必要があります。そうでない場合は、コンパイル時エラーが発生します。
*  選択したメソッド `M` がインスタンスメソッドの場合、`E` に関連付けられたインスタンス式によって、デリゲートのターゲットオブジェクトが決定されます。
*  選択したメソッド M が、インスタンス式でのメンバーアクセスによって示される拡張メソッドである場合、そのインスタンス式によって、デリゲートのターゲットオブジェクトが決定されます。
*  変換の結果は `D`型の値になります。つまり、選択したメソッドとターゲットオブジェクトを参照する新しく作成されたデリゲートです。
*  [メソッド呼び出し](expressions.md#method-invocations)のアルゴリズムがインスタンスメソッドを検出できず、拡張メソッドの呼び出し ([拡張メソッド](expressions.md#extension-method-invocations)の呼び出し) として `E(A)` の呼び出しの処理に成功する場合は、このプロセスによって、拡張メソッドへのデリゲートの作成につながる可能性があることに注意してください。 このように作成されたデリゲートは、拡張メソッドとその最初の引数をキャプチャします。

次の例は、メソッドグループの変換を示しています。
```csharp
delegate string D1(object o);

delegate object D2(string s);

delegate object D3();

delegate string D4(object o, params object[] a);

delegate string D5(int i);

class Test
{
    static string F(object o) {...}

    static void G() {
        D1 d1 = F;            // Ok
        D2 d2 = F;            // Ok
        D3 d3 = F;            // Error -- not applicable
        D4 d4 = F;            // Error -- not applicable in normal form
        D5 d5 = F;            // Error -- applicable but not compatible

    }
}
```

`d1` への代入は、メソッドグループ `F` を `D1`型の値に暗黙的に変換します。

`d2` への代入は、弱い派生型 (反変) のパラメーター型と、より派生した (共変の) 戻り値の型を持つメソッドへのデリゲートを作成する方法を示しています。

`d3` への代入は、メソッドが適用されない場合に変換が存在しないことを示します。

`d4` への割り当ては、メソッドを通常の形式で適用する方法を示しています。

`d5` への代入は、デリゲートとメソッドのパラメーターと戻り値の型が参照型に対してのみ異なることを許可する方法を示しています。

他の暗黙的な変換および明示的な変換と同様に、cast 演算子を使用してメソッドグループの変換を明示的に実行できます。 この例では、
```csharp
object obj = new EventHandler(myDialog.OkClick);
```
書き込みが可能
```csharp
object obj = (EventHandler)myDialog.OkClick;
```

メソッドグループは、オーバーロードの解決に影響を与える可能性があり、型の推定に関与します。 詳細については、「[関数メンバー](expressions.md#function-members) 」を参照してください。

メソッドグループの変換の実行時の評価は、次のように行われます。

*  コンパイル時に選択されたメソッドがインスタンスメソッドである場合、またはインスタンスメソッドとしてアクセスされる拡張メソッドである場合は、デリゲートのターゲットオブジェクトは `E`に関連付けられたインスタンス式から決定されます。
    * インスタンス式が評価されます。 この評価によって例外が発生した場合、それ以上の手順は実行されません。
    * インスタンス式が*reference_type*の場合、インスタンス式によって計算された値が対象オブジェクトになります。 選択したメソッドがインスタンスメソッドで、ターゲットオブジェクトが `null`場合、`System.NullReferenceException` がスローされ、それ以上の手順は実行されません。
    * インスタンス式が*value_type*の場合は、値をオブジェクトに変換するボックス化操作 ([ボックス化変換](types.md#boxing-conversions)) が実行され、このオブジェクトが対象オブジェクトになります。
*  それ以外の場合は、選択したメソッドが静的メソッド呼び出しの一部になり、デリゲートのターゲットオブジェクトが `null`されます。
*  `D` デリゲート型の新しいインスタンスが割り当てられます。 新しいインスタンスの割り当てに使用できるメモリが不足している場合は、`System.OutOfMemoryException` がスローされ、それ以上の手順は実行されません。
*  新しいデリゲートインスタンスは、コンパイル時に決定されたメソッドへの参照と、上記で計算されたターゲットオブジェクトへの参照を使用して初期化されます。
