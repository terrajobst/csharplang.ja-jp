---
ms.openlocfilehash: 088c4a77cecde490c556c44c239a3496f896582e
ms.sourcegitcommit: 4ddf18d000734c1b6d0a48127bf338086fc3f2c3
ms.translationtype: MT
ms.contentlocale: ja-JP
ms.lasthandoff: 11/05/2019
ms.locfileid: "73616140"
---
# <a name="types"></a>種類

C#言語の型は、***値型***と***参照型***の2つの主なカテゴリに分類されます。 値型と参照型は、どちらも1つ以上の***型パラメーター***を受け取る***ジェネリック型***にすることができます。 型パラメーターは、値型と参照型の両方を指定できます。

```antlr
type
    : value_type
    | reference_type
    | type_parameter
    | type_unsafe
    ;
```

型の最後のカテゴリであるポインターは、アンセーフコードでのみ使用できます。 これについては、「[ポインター型](unsafe-code.md#pointer-types)」で詳しく説明します。

値型は参照型とは異なり、値型の変数はデータを直接含んでいるのに対し、参照型の変数はデータへの***参照***を格納します。後者は***オブジェクト***と呼ばれます。 参照型を使用すると、2つの変数が同じオブジェクトを参照する可能性があります。したがって、ある変数に対する操作が、もう一方の変数によって参照されるオブジェクトに影響を与える可能性があります。 値型の場合、それぞれの変数にはデータの独自のコピーがあり、一方の変数に対する操作がもう一方に影響を与えることはできません。

C#の型システムは、任意の型の値をオブジェクトとして扱うことができるように統合されています。 C# における型はすべて、直接的または間接的に `object` クラス型から派生し、`object` はすべての型の究極の基底クラスです。 参照型の値は、値を単純に `object` 型としてみなすことによってオブジェクトとして扱われます。 値型の値は、ボックス化とボックス化解除の操作 ([ボックス化およびボックス化解除](types.md#boxing-and-unboxing)) を実行することで、オブジェクトとして扱われます。

## <a name="value-types"></a>値型

値型は、構造体型または列挙型のいずれかです。 C#***単純型***と呼ばれる定義済みの構造体型のセットを提供します。 単純型は、予約語によって識別されます。

```antlr
value_type
    : struct_type
    | enum_type
    ;

struct_type
    : type_name
    | simple_type
    | nullable_type
    ;

simple_type
    : numeric_type
    | 'bool'
    ;

numeric_type
    : integral_type
    | floating_point_type
    | 'decimal'
    ;

integral_type
    : 'sbyte'
    | 'byte'
    | 'short'
    | 'ushort'
    | 'int'
    | 'uint'
    | 'long'
    | 'ulong'
    | 'char'
    ;

floating_point_type
    : 'float'
    | 'double'
    ;

nullable_type
    : non_nullable_value_type '?'
    ;

non_nullable_value_type
    : type
    ;

enum_type
    : type_name
    ;
```

参照型の変数とは異なり、値型の変数には、値の型が null 許容型である場合にのみ `null` 値を含めることができます。  Null 非許容の値型ごとに、同じ値のセットと `null`値を示す、対応する null 許容値型があります。

値型の変数への代入では、割り当てられている値のコピーが作成されます。 これは、参照によって識別されるオブジェクトではなく、参照をコピーする参照型の変数への代入とは異なります。

### <a name="the-systemvaluetype-type"></a>ValueType 型

すべての値型はクラス `System.ValueType`から暗黙的に継承します。このクラスはクラス `object`から継承されます。 型を値型から派生させることはできません。したがって、値型は暗黙的にシールされます ([シールクラス](classes.md#sealed-classes))。

`System.ValueType` はそれ自体が*value_type*ではないことに注意してください。 代わりに、すべての*value_type*が自動的に派生する*class_type*です。

### <a name="default-constructors"></a>既定のコンストラクター

すべての値型は、***既定のコンストラクター***と呼ばれる、パラメーターなしのパブリックなインスタンスコンストラクターを暗黙的に宣言します。 既定のコンストラクターは、値型の***既定値***として認識される、ゼロで初期化されたインスタンスを返します。

*  すべての*simple_type*s について、既定値は、すべてのゼロのビットパターンによって生成される値です。
    * `sbyte`、`byte`、`short`、`ushort`、`int`、`uint`、`long`、`ulong`の場合、既定値は `0`です。
    * `char`の場合、既定値は `'\x0000'`です。
    * `float`の場合、既定値は `0.0f`です。
    * `double`の場合、既定値は `0.0d`です。
    * `decimal`の場合、既定値は `0.0m`です。
    * `bool`の場合、既定値は `false`です。
*  *Enum_type* `E`の場合、既定値は `0``E`型に変換されます。
*  *Struct_type*の既定値は、すべての値の型フィールドを既定値に設定し、すべての参照型フィールドを `null`に設定することによって生成される値です。
*  *Nullable_type*の場合、既定値は `HasValue` プロパティが false で、`Value` プロパティが定義されていないインスタンスです。 既定値は null 許容型の***null 値***とも呼ばれます。

他のインスタンスコンストラクターと同様に、値型の既定のコンストラクターは `new` 演算子を使用して呼び出されます。 効率上の理由から、実装によってコンストラクター呼び出しが生成されるようにするための要件はありません。 次の例では、変数 `i` と `j` がどちらも0に初期化されています。

```csharp
class A
{
    void F() {
        int i = 0;
        int j = new int();
    }
}
```

すべての値型には暗黙的にパラメーターなしのインスタンスコンストラクターがあるため、パラメーターなしのコンストラクターの明示的な宣言を struct 型に含めることはできません。 ただし、構造体型では、パラメーター化されたインスタンスコンストラクター ([コンストラクター](structs.md#constructors)) を宣言できます。

### <a name="struct-types"></a>構造体の型

構造体型は、定数、フィールド、メソッド、プロパティ、インデクサー、演算子、インスタンスコンストラクター、静的コンストラクター、および入れ子にされた型を宣言できる値型です。 構造体型の宣言については、「 [struct 宣言](structs.md#struct-declarations)」を参照してください。

### <a name="simple-types"></a>単純型

C#***単純型***と呼ばれる定義済みの構造体型のセットを提供します。 単純型は予約語によって識別されますが、これらの予約語は、次の表で説明するように、`System` 名前空間の定義済みの構造体型のエイリアスにすぎません。


| __予約語__ | __エイリアスを持つ型__ |
|-------------------|------------------|
| `sbyte`           | `System.SByte`   | 
| `byte`            | `System.Byte`    | 
| `short`           | `System.Int16`   | 
| `ushort`          | `System.UInt16`  | 
| `int`             | `System.Int32`   | 
| `uint`            | `System.UInt32`  | 
| `long`            | `System.Int64`   | 
| `ulong`           | `System.UInt64`  | 
| `char`            | `System.Char`    | 
| `float`           | `System.Single`  | 
| `double`          | `System.Double`  | 
| `bool`            | `System.Boolean` | 
| `decimal`         | `System.Decimal` | 

単純型は構造体型のエイリアスであるため、すべての単純型にメンバーが含まれます。 たとえば、`int` には `System.Int32` で宣言されたメンバーと `System.Object`から継承されたメンバーがあり、次のステートメントを使用できます。

```csharp
int i = int.MaxValue;           // System.Int32.MaxValue constant
string s = i.ToString();        // System.Int32.ToString() instance method
string t = 123.ToString();      // System.Int32.ToString() instance method
```

単純型は、ある追加の操作を許可している点で、他の構造体型とは異なります。

*  ほとんどの単純型では、*リテラル*([リテラル](lexical-structure.md#literals)) を記述することによって値を作成できます。 たとえば、`123` は `int` 型のリテラルで、`'a'` は `char`型のリテラルです。 C#は、一般に構造体型のリテラルのプロビジョニングを行いません。また、他の構造体型の既定以外の値は、最終的にこれらの構造体型のインスタンスコンストラクターを使用して作成されます。
*  式のオペランドがすべて単純型定数である場合、コンパイラはコンパイル時に式を評価することができます。 このような式は、 *constant_expression* ([定数式](expressions.md#constant-expressions)) と呼ばれます。 他の構造体型によって定義された演算子を含む式は、定数式とは見なされません。
*  `const` 宣言を使用すると、単純型 ([定数](classes.md#constants)) の定数を宣言できます。 他の構造体型の定数を使用することはできませんが、`static readonly` のフィールドでも同様の効果が得られます。
*  単純型を含む変換は、他の構造体型によって定義された変換演算子の評価に参加できますが、ユーザー定義の変換演算子は、別のユーザー定義演算子の評価に参加することはできません ([の評価ユーザー定義の変換](conversions.md#evaluation-of-user-defined-conversions))。

### <a name="integral-types"></a>整数型

C#では、`sbyte`、`byte`、`short`、`ushort`、`int`、`uint`、`long`、`ulong`、`char`の9つの整数型がサポートされています。 整数型には、次のサイズと値の範囲があります。

*  `sbyte` 型は、-128 ~ 127 の値を持つ符号付き8ビット整数を表します。
*  `byte` 型は、0 ~ 255 の値を持つ符号なし8ビット整数を表します。
*  `short` 型は、-32768 ~ 32767 の値を持つ符号付き16ビット整数を表します。
*  `ushort` 型は、0 ~ 65535 の値を持つ符号なし16ビット整数を表します。
*  `int` 型は、-2147483648 から2147483647までの値を持つ符号付き32ビット整数を表します。
*  `uint` 型は、0 ~ 4294967295 の値を持つ符号なし32ビット整数を表します。
*  `long` 型は、-9223372036854775808 ~ 9223372036854775807 の値を持つ符号付き64ビット整数を表します。
*  `ulong` 型は、0 ~ 18446744073709551615 の値を持つ符号なし64ビット整数を表します。
*  `char` 型は、0 ~ 65535 の値を持つ符号なし16ビット整数を表します。 `char` 型に使用できる値のセットは、Unicode 文字セットに対応しています。 `char` には `ushort`と同じ表現がありますが、1つの型で許可されているすべての操作が他方で許可されているわけではありません。

整数型の単項演算子および二項演算子は、常に、符号付き32ビット精度、符号なし32ビット精度、符号付き64ビット精度、符号なし64ビット精度で動作します。

*  単項演算子 `+` と `~` 演算子の場合、オペランドは `T`型に変換されます。ここで、`T` は、オペランドのすべての使用可能な値を完全に表すことができる `int`、`uint`、`long`、および `ulong` の最初のものです。 この操作は `T`型の有効桁数を使用して実行され、結果の型は `T`になります。
*  単項 `-` 演算子では、オペランドが型 `T`に変換されます。ここで、`T` は、オペランドのすべての可能な値を完全に表すことができる `int` および `long` の最初のものです。 この操作は `T`型の有効桁数を使用して実行され、結果の型は `T`になります。 単項 `-` 演算子を `ulong`型のオペランドに適用することはできません。
*  バイナリ `+`、`-`、`*`、`/`、`%`、`&`、`^`、`|`、`==`、`!=`、`>`、`<`の各演算子では、オペランドは `T`型に変換されます。ここで、`T` は、両方のオペランドのすべての可能な値を完全に表すことができる `int`、`uint`、`long`、および `ulong` の最初のものです。 この操作は `T`型の有効桁数を使用して実行され、結果の型は `T` になります (または、関係演算子の `bool` ます)。 1つのオペランドを `long` 型にし、もう一方のオペランドを二項演算子で `ulong` 型にすることは許可されていません。
*  二項 `<<` および `>>` 演算子の場合、左オペランドは `T`型に変換されます。ここで `T` は、オペランドのすべての可能な値を完全に表すことができる `int`、`uint`、`long`、および `ulong` の最初のものです。 この操作は `T`型の有効桁数を使用して実行され、結果の型は `T`になります。

`char` 型は整数型として分類されますが、他の整数型とは次の2つの点で異なります。

*  他の型から `char` 型へと暗黙的に変換することはできません。 特に、`sbyte`、`byte`、および `ushort` 型には、`char` 型を使用して完全に表現できる値の範囲がある場合でも、`sbyte`、`byte`、または `ushort` から `char` への暗黙的な変換は存在しません。
*  `char` 型の定数は、 *character_literal*s として記述するか、 *integer_literal*を `char`型へのキャストと組み合わせて使用する必要があります。 たとえば、`(char)10` は `'\x000A'` と同じです。

`checked` および `unchecked` の演算子とステートメントを使用して、整数型の算術演算および変換 ([checked および unchecked 演算子](expressions.md#the-checked-and-unchecked-operators)) のオーバーフローチェックを制御します。 `checked` コンテキストでは、オーバーフローによってコンパイル時エラーが生成されるか、`System.OverflowException` がスローされます。 `unchecked` のコンテキストでは、オーバーフローは無視され、変換先の型に収まらない上位ビットはすべて破棄されます。

### <a name="floating-point-types"></a>浮動小数点型

C#では、`float` と `double`の2つの浮動小数点型がサポートされています。 `float` 型と `double` 型は、32ビットの単精度と64ビットの倍精度の IEEE 754 形式を使用して表されます。これにより、次の値のセットが提供されます。

*  正のゼロと負の0。 ほとんどの場合、正のゼロと負の0は単純な値ゼロと同じように動作しますが、特定の操作で2つの ([除算演算子](expressions.md#division-operator)) が区別されます。
*  正の無限大と負の無限大。 無限大は、0以外の数値を0で除算するなどの操作によって生成されます。 たとえば、`1.0 / 0.0` は正の無限大を生成し、`-1.0 / 0.0` は負の無限大を生成します。
*  非***数***の値。多くの場合、NaN が省略されています。 Nan は、0除算などの無効な浮動小数点演算によって生成されます。
*  `s` が1または-1 で、`m` および `e` が特定の浮動小数点型によって決定される、`s * m * 2^e`形式の0以外の値の有限のセット。 `float`の場合は、`0 < m < 2^24` の場合は `-149 <= e <= 104`、`double`、`0 < m < 2^53` および `-1075 <= e <= 970`。 非正規化された浮動小数点数は、0以外の有効な値と見なされます。

`float` 型は、有効桁数が7桁の、約 `1.5 * 10^-45` から `3.4 * 10^38` までの範囲の値を表すことができます。

`double` 型は、15-16 桁の有効桁数で、約 `5.0 * 10^-324` から `1.7 × 10^308` までの範囲の値を表すことができます。

二項演算子のオペランドの1つが浮動小数点型の場合、もう一方のオペランドは整数型または浮動小数点型である必要があり、演算は次のように評価されます。

*  オペランドの1つが整数型の場合、そのオペランドはもう一方のオペランドの浮動小数点型に変換されます。
*  次に、いずれかのオペランドが `double`型である場合、もう一方のオペランドが `double`に変換され、少なくとも `double` 範囲と有効桁数を使用して演算が実行され、結果の型が `double` (または関係演算子の `bool`) になります。
*  それ以外の場合は、少なくとも `float` 範囲と有効桁数を使用して演算が実行され、結果の型が `float` ます (または、関係演算子の `bool`)。

代入演算子を含む浮動小数点演算子は、例外を生成しません。 次に示すように、例外的な状況では、浮動小数点演算ではゼロ、無限大、または NaN が生成されます。

*  浮動小数点演算の結果が変換先の形式に対して小さすぎる場合、演算の結果は正の0または負の0になります。
*  浮動小数点演算の結果が変換先の形式に対して大きすぎる場合、演算の結果は正の無限大または負の無限大になります。
*  浮動小数点演算が無効な場合、演算の結果は NaN になります。
*  浮動小数点演算の一方または両方のオペランドが NaN の場合、演算の結果は NaN になります。

浮動小数点演算は、演算の結果の型よりも高い精度で実行される場合があります。 たとえば、一部のハードウェアアーキテクチャでは、`double` 型よりも範囲と有効桁数が大きい "拡張" または "long double" 浮動小数点型がサポートされており、このより高い有効桁数の型を使用してすべての浮動小数点演算が暗黙的に実行されます。 このようなハードウェアアーキテクチャは、低精度で浮動小数点演算を実行し、パフォーマンスと精度の両方をプランするための実装を必要とするのでC#はなく、高いパフォーマンスを実現することだけが可能です。すべての浮動小数点演算に使用されます。 より正確な結果を提供する以外にも、測定可能な効果はほとんどありません。 ただし、`x * y / z`の形式の式では、乗算によって `double` 範囲外の結果が生成されますが、その後の除算では `double` 範囲に一時的な結果が返されます。これは、式がで評価されるという事実です。範囲の形式が大きいと、無限大ではなく、有限の結果が生成される可能性があります。

### <a name="the-decimal-type"></a>Decimal 型

`decimal` 型は 128 ビットのデータ型で、財務や通貨の計算に適しています。 `decimal` 型は、`1.0 * 10^-28` から `7.9 * 10^28` 約28-29 の範囲の値を表すことができます。有効桁数はです。

`decimal` 型の有限の値のセットは `(-1)^s * c * 10^-e`形式です。符号 `s` は0または1であり、`c` 係数は `0 <= *c* < 2^96`によって指定され、小数点以下桁数は `e` になります。`decimal` 型は、符号付きの0、無限大、または NaN のをサポートしていません。 `decimal` は、10の累乗によってスケーリングされた96ビット整数として表されます。 `1.0m`未満の絶対値を持つ `decimal`の場合、値は28桁の小数点以下の桁数に完全になりますが、それ以上はありません。 `1.0m`以上の絶対値を持つ `decimal`s では、値は28桁または29桁になります。 データ型の `float` と `double` とは対照的に、0.1 のような10進数の小数部は、`decimal` 表現で正確に表すことができます。 `float` と `double` 表現では、多くの場合、このような数値は無限の分数になるため、これらの表現が丸められると、丸め誤差が発生しやすくなります。

二項演算子のオペランドの1つが `decimal`型である場合、もう一方のオペランドは整数型または `decimal`型である必要があります。 整数型のオペランドが存在する場合は、演算が実行される前に `decimal` に変換されます。

`decimal` 型の値に対する演算の結果は、正確な結果 (各演算子に対して定義されているように、小数点以下桁数を保持します) を計算してから、その表現に合わせて丸めた結果になります。 結果は、最も近い表現可能な値に丸められます。また、結果が2つの表現可能な値に均等に近い場合は、最下位の桁に偶数の数値が含まれる値になります (これは "銀行型丸め" と呼ばれます)。 ゼロの結果は、常に0の符号と小数点以下桁数が0になります。

10進数の算術演算で、絶対値が絶対値で `5 * 10^-29` 以下の値が生成された場合、演算の結果はゼロになります。 `decimal` 算術演算によって、`decimal` 形式に対して大きすぎる結果が生成されると、`System.OverflowException` がスローされます。

`decimal` 型は、より精度が高く、浮動小数点型よりも範囲が小さくなっています。 したがって、浮動小数点型から `decimal` への変換ではオーバーフロー例外が発生する可能性があり、`decimal` から浮動小数点型への変換によって精度が失われる可能性があります。 このような理由から、浮動小数点型と `decimal`の間に暗黙的な変換は存在せず、明示的なキャストを行わないと、浮動小数点と `decimal` のオペランドを同じ式に混在させることはできません。

### <a name="the-bool-type"></a>Bool 型

`bool` 型はブール値の論理数を表します。 `bool` 型の有効な値は `true` と `false`です。

`bool` とその他の型の間に標準変換は存在しません。 特に、`bool` 型は、整数型とは区別されていますが、整数値の代わりに `bool` 値を使用することはできません。その逆も同様です。

C とC++言語では、ゼロの整数または浮動小数点値、または null ポインターをブール値 `false`、0以外の整数または浮動小数点値、または null 以外のポインターをブール値 `true`に変換できます。 でC#は、整数または浮動小数点値を明示的に0に比較するか、オブジェクト参照を `null`に明示的に比較することで、このような変換が行われます。

### <a name="enumeration-types"></a>列挙型

列挙型は、名前付き定数を持つ別個の型です。 すべての列挙型には基になる型があり、`byte`、`sbyte`、`short`、`ushort`、`int`、`uint`、`long`、`ulong`のいずれかである必要があります。 列挙型の値のセットは、基になる型の値のセットと同じです。 列挙型の値は、名前付き定数の値に制限されません。 列挙型は列挙宣言 (列挙型[宣言](enums.md#enum-declarations)) を使用して定義されます。

### <a name="nullable-types"></a>Null 許容型

Null 許容型は、***基になる型***のすべての値と追加の null 値を表すことができます。 Null 許容型は `T?`書き込まれます。 `T` は基になる型です。 この構文は `System.Nullable<T>`の短縮形であり、2つの形式を区別して使用できます。

逆に、 ***null 非許容の値型***は、`System.Nullable<T>` 以外の任意の値型と、その短縮形 `T?` (任意の `T`) と、null 非許容の値型 (つまり、`struct` を持つ任意の型パラメーター) に制限されている任意の型パラメーターです。制約)。 `System.Nullable<T>` 型は、`T` ([型パラメーター制約](classes.md#type-parameter-constraints)) の値型の制約を指定します。これは、null 許容型の基になる型が null 非許容の値型であることを意味します。 Null 許容型の基になる型を null 許容型または参照型にすることはできません。 たとえば、`int??` と `string?` は無効な型です。

Null 許容型 `T?` のインスタンスには、次の2つのパブリック読み取り専用プロパティがあります。

*  型の `HasValue` プロパティ `bool`
*  型の `Value` プロパティ `T`

`HasValue` が true であるインスタンスは、null 以外であると言います。 Null 以外のインスタンスには既知の値が含まれており、`Value` その値を返します。

`HasValue` が false であるインスタンスは、null と呼ばれます。 Null インスタンスには未定義の値が含まれています。 Null インスタンスの `Value` を読み取ろうとすると、`System.InvalidOperationException` がスローされます。 Null 許容インスタンスの `Value` プロパティにアクセスするプロセスを、***ラップ***解除と呼びます。

既定のコンストラクターに加えて、すべての null 許容型 `T?` には、`T`型の単一の引数を受け取るパブリックコンストラクターがあります。 `T`型の値 `x` を指定した場合、フォームのコンストラクターが呼び出されます。

```csharp
new T?(x)
```
`Value` プロパティが `x`される `T?` の null 以外のインスタンスを作成します。 指定された値の null 許容型の null 以外のインスタンスを作成するプロセスを、***ラップ***と呼びます。

暗黙の型変換は、`null` リテラルから、`T?` ([Null リテラル変換](conversions.md#null-literal-conversions)) と `T` から `T?` ([暗黙の null 許容型変換](conversions.md#implicit-nullable-conversions)) から使用できます。

## <a name="reference-types"></a>参照型

参照型は、クラス型、インターフェイス型、配列型、またはデリゲート型です。

```antlr
reference_type
    : class_type
    | interface_type
    | array_type
    | delegate_type
    ;

class_type
    : type_name
    | 'object'
    | 'dynamic'
    | 'string'
    ;

interface_type
    : type_name
    ;

array_type
    : non_array_type rank_specifier+
    ;

non_array_type
    : type
    ;

rank_specifier
    : '[' dim_separator* ']'
    ;

dim_separator
    : ','
    ;

delegate_type
    : type_name
    ;
```

参照型の値は、型の***インスタンス***への参照 (後者は***オブジェクト***と呼ばれます) です。 `null` 特別な値は、すべての参照型と互換性があり、インスタンスが存在しないことを示します。

### <a name="class-types"></a>クラス型

クラス型は、データメンバー (定数とフィールド)、関数メンバー (メソッド、プロパティ、イベント、インデクサー、演算子、インスタンスコンストラクター、デストラクターおよび静的コンストラクター)、および入れ子にされた型を含むデータ構造を定義します。 クラス型は、派生クラスが基本クラスを拡張および特殊化できる機構である継承をサポートしています。 クラス型のインスタンスは、 *object_creation_expression*s ([オブジェクト作成式](expressions.md#object-creation-expressions)) を使用して作成されます。

クラス型については、「[クラス](classes.md)」を参照してください。

次の表で説明するように、 C#定義済みの特定のクラス型は言語で特別な意味を持ちます。


| __クラスの型__     | __説明__                                         |
|--------------------|---------------------------------------------------------|
| `System.Object`    | 他のすべての型の最終的な基底クラス。 [オブジェクトの種類を](types.md#the-object-type)参照してください。 | 
| `System.String`    | C#言語の文字列型。 [文字列型を](types.md#the-string-type)参照してください。         |
| `System.ValueType` | すべての値型の基本クラス。 [ValueType 型を](types.md#the-systemvaluetype-type)参照してください。          |
| `System.Enum`      | すべての列挙型の基本クラス。 「[列挙](enums.md)型」を参照してください。              |
| `System.Array`     | すべての配列型の基本クラス。 「[配列](arrays.md)」を参照してください。             |
| `System.Delegate`  | すべてのデリゲート型の基本クラス。 「[デリゲート](delegates.md)」を参照してください。          |
| `System.Exception` | すべての例外の種類の基本クラス。 「[例外](exceptions.md)」を参照してください。         |

### <a name="the-object-type"></a>オブジェクト型

`object` クラス型は、他のすべての型の最終的な基本クラスです。 内のすべてC#の型は、`object` クラス型から直接または間接的に派生します。

キーワード `object` は、定義済みのクラス `System.Object`のエイリアスにすぎません。

### <a name="the-dynamic-type"></a>dynamic 型

`dynamic` 型 (`object`など) は任意のオブジェクトを参照できます。 `dynamic`型の式に演算子を適用すると、その解決はプログラムが実行されるまで延期されます。 したがって、演算子を参照先のオブジェクトに合法的に適用できない場合、コンパイル中にエラーは発生しません。 代わりに、実行時に演算子の解決が失敗すると、例外がスローされます。

その目的は動的バインドを許可することです。これについては、「[動的バインド](expressions.md#dynamic-binding)」で詳しく説明します。

`dynamic` は、次の点を除けば `object` と同一であると見なされます。

*  `dynamic` 型の式に対する演算は動的にバインドできます ([動的バインド](expressions.md#dynamic-binding))。
*  型の推定 ([型の推論](expressions.md#type-inference)) では、両方が候補である場合、`object` よりも `dynamic` 優先されます。

この等価性により、次のものが保持されます。

*  `object` と `dynamic`間の暗黙的な id 変換と、`dynamic` をに置き換えるときに同じである構築された型の間では、`object`
*  `object` との間の暗黙の型変換と明示的な変換は、`dynamic`との間でも適用されます。
*  `dynamic` を `object` に置き換える場合と同じメソッドシグネチャは、同じシグネチャと見なされます。
*  `dynamic` 型は、実行時に `object` と区別できません。
*  `dynamic` 型の式は、***動的な式***と呼ばれます。

### <a name="the-string-type"></a>文字列型

`string` 型は、`object`から直接継承するシールクラス型です。 `string` クラスのインスタンスは、Unicode 文字列を表します。

`string` 型の値は、文字列リテラル ([文字列リテラル](lexical-structure.md#string-literals)) として書き込むことができます。

キーワード `string` は、定義済みのクラス `System.String`のエイリアスにすぎません。

### <a name="interface-types"></a>インターフェイス型

インターフェイスはコントラクトを定義します。 インターフェイスを実装するクラスまたは構造体は、コントラクトに従う必要があります。 インターフェイスは複数の基本インターフェイスから継承でき、クラスまたは構造体は複数のインターフェイスを実装できます。

インターフェイス型については、「[インターフェイス](interfaces.md)」を参照してください。

### <a name="array-types"></a>配列型

配列は、計算されたインデックスを通じてアクセスされる0個以上の変数を含むデータ構造です。 配列に含まれる変数は、配列の要素とも呼ばれ、すべて同じ型であり、この型は配列の要素型と呼ばれます。

配列型については、「[配列](arrays.md)」を参照してください。

### <a name="delegate-types"></a>デリゲート型

デリゲートは、1つ以上のメソッドを参照するデータ構造体です。 インスタンスメソッドの場合は、対応するオブジェクトインスタンスも参照します。

C またはC++のデリゲートに最も近いものは関数ポインターですが、関数ポインターで参照できるのは静的関数だけですが、デリゲートは静的メソッドとインスタンスメソッドの両方を参照できます。 後者の場合、デリゲートは、メソッドのエントリポイントへの参照だけでなく、メソッドを呼び出すオブジェクトインスタンスへの参照も格納します。

デリゲート型については、「[デリゲート](delegates.md)」を参照してください。

## <a name="boxing-and-unboxing"></a>ボックス化とボックス化解除

ボックス化とボックス化解除の概念はC#、型システムの中心となるものです。 *Value_type*s と*reference_type*s の間のブリッジを提供します。これにより、 *value_type*の任意の値を型 `object`との間で変換することが許可されます。 ボックス化とボックス化解除を使用すると、型システムの統一されたビューを使用して、任意の型の値を最終的にオブジェクトとして扱うことができます。

### <a name="boxing-conversions"></a>ボックス化変換

ボックス化変換は、 *value_type*を暗黙的に*reference_type*に変換することを許可します。 次のボックス化変換が存在します。

*  任意の*value_type*から型 `object`にします。
*  任意の*value_type*から型 `System.ValueType`にします。
*  任意の*non_nullable_value_type*から、 *value_type*によって実装されている任意の*interface_type*に。
*  任意の*nullable_type*から、基になる*nullable_type*の型によって実装されている任意の*interface_type*にします。
*  任意の*enum_type*から型 `System.Enum`にします。
*  基になる*enum_type*を持つ任意の*nullable_type*から `System.Enum`型にします。
*  実行時に、型パラメーターからの暗黙的な変換が、値型から参照型 ([型パラメーター](conversions.md#implicit-conversions-involving-type-parameters)を使用する暗黙的な変換) に変換される場合は、ボックス化変換として実行されることに注意してください。

*Non_nullable_value_type*の値をボックス化するには、オブジェクトインスタンスを割り当て、そのインスタンスに*non_nullable_value_type*値をコピーします。

*Nullable_type*の値をボックス化すると、`null` 値 (`HasValue` が `false`) の場合は null 参照が生成され、それ以外の場合は、基になる値のラップ解除とボックス化の結果になります。

*Non_nullable_value_type*の値をボックス化する実際のプロセスは、次のように宣言されているかのように動作するジェネリック***ボックス化クラス***の存在を練りすることによって説明します。

```csharp
sealed class Box<T>: System.ValueType
{
    T value;

    public Box(T t) {
        value = t;
    }
}
```

`T` 型の値 `v` のボックス化は、式 `new Box<T>(v)`を実行し、結果のインスタンスを `object`型の値として返すようになりました。 したがって、ステートメント
```csharp
int i = 123;
object box = i;
```
概念的に対応
```csharp
int i = 123;
object box = new Box<int>(i);
```

上記の `Box<T>` のようなボックス化クラスは実際には存在せず、ボックス化された値の動的な型は実際にはクラス型ではありません。 代わりに、型 `T` のボックス化された値には動的な型 `T`があり、`is` 演算子を使用した動的な型チェックでは、単純に型 `T`を参照できます。 たとえば、オブジェクトに適用された
```csharp
int i = 123;
object box = i;
if (box is int) {
    Console.Write("Box contains an int");
}
```
は、文字列 "`Box contains an int`" をコンソールに出力します。

ボックス化変換は、ボックス化された値のコピーを作成することを意味します。 これは、 *reference_type*から `object`型への変換とは異なります。この場合、値は引き続き同じインスタンスを参照し、`object`より弱い派生型と見なされます。 たとえば、次のように宣言したとします。
```csharp
struct Point
{
    public int x, y;

    public Point(int x, int y) {
        this.x = x;
        this.y = y;
    }
}
```
次のステートメント
```csharp
Point p = new Point(10, 10);
object box = p;
p.x = 20;
Console.Write(((Point)box).x);
```
は、値10をコンソールに出力します。これは、`p` を `box` に割り当てたときに暗黙的なボックス化操作によって `p` の値がコピーされるためです。 `p` と `box` が同じインスタンスを参照するため、代わりに `Point` `class` として宣言されています。

### <a name="unboxing-conversions"></a>ボックス化解除

アンボックス変換は、 *reference_type*を明示的に*value_type*に変換することを許可します。 次のボックス化解除変換が存在します。

*  型から任意の*value_type*に `object` ます。
*  型から任意の*value_type*に `System.ValueType` ます。
*  任意の*interface_type*から、 *interface_type*を実装する任意の*non_nullable_value_type*に。
*  任意の*interface_type*から、基になる型が*interface_type*を実装している任意の*nullable_type* 。
*  型から任意の*enum_type*に `System.Enum` ます。
*  型から、基になる*enum_type*を持つ任意の*nullable_type*に `System.Enum` ます。
*  実行時に参照型から値型に変換すると ([明示的な動的変換](conversions.md#explicit-dynamic-conversions))、型パラメーターへの明示的な変換は、アンボックス変換として実行されることに注意してください。

*Non_nullable_value_type*へのボックス化解除操作では、最初に、オブジェクトインスタンスが指定された*non_nullable_value_type*のボックス化された値であることを確認し、次にインスタンスから値をコピーします。

*Nullable_type*にボックス化を解除すると、ソースオペランドが `null`場合は*nullable_type*の null 値が生成されます。それ以外の場合は、オブジェクトインスタンスを*nullable_type*の基になる型にボックス化解除した結果が返されます。

前のセクションで説明した架空のボックス化クラスを参照し、オブジェクト `box` から*value_type* `T` へのアンボックス変換は、`((Box<T>)box).value`式を実行することで構成されます。 したがって、ステートメント
```csharp
object box = 123;
int i = (int)box;
```
概念的に対応
```csharp
object box = new Box<int>(123);
int i = ((Box<int>)box).value;
```

指定された*non_nullable_value_type*へのアンボックス変換が実行時に成功するようにするには、ソースオペランドの値が、その*non_nullable_value_type*のボックス化された値への参照である必要があります。 ソースオペランドが `null`場合、`System.NullReferenceException` がスローされます。 ソースオペランドが互換性のないオブジェクトへの参照である場合は、`System.InvalidCastException` がスローされます。

指定された*nullable_type*へのアンボックス変換が実行時に成功するようにするには、source オペランドの値が `null` か、または*nullable_type*の基になる*non_nullable_value_type*のボックス化された値への参照である必要があります。 ソースオペランドが互換性のないオブジェクトへの参照である場合は、`System.InvalidCastException` がスローされます。

## <a name="constructed-types"></a>構築された型

ジェネリック型の宣言自体は、***型引数***を適用することによって、さまざまな型を形成するための "ブループリント" として使用される、バインドされていない***ジェネリック型***を表します。 型引数は、ジェネリック型の名前の直後に山かっこ (`<` と `>`) で記述されます。 少なくとも1つの型引数を含む型は、構築された***型***と呼ばれます。 構築された型は、型名を表示できる言語のほとんどの場所で使用できます。 バインドされていないジェネリック型は、 *typeof_expression* ([typeof 演算子](expressions.md#the-typeof-operator)) 内でのみ使用できます。

構築された型は、単純な名前 ([簡易名](expressions.md#simple-names)) として式で使用することも、メンバー ([メンバーアクセス](expressions.md#member-access)) にアクセスするときに使用することもできます。

*Namespace_or_type_name*が評価されると、正しい数の型パラメーターを持つジェネリック型だけが考慮されます。 したがって、型の型パラメーターの数が異なる限り、同じ識別子を使用して異なる型を識別することができます。 これは、ジェネリッククラスと非ジェネリッククラスを同じプログラムに混在させる場合に便利です。

```csharp
namespace Widgets
{
    class Queue {...}
    class Queue<TElement> {...}
}

namespace MyApplication
{
    using Widgets;

    class X
    {
        Queue q1;            // Non-generic Widgets.Queue
        Queue<int> q2;       // Generic Widgets.Queue
    }
}
```

型パラメーターが直接指定されていない場合でも、 *type_name*は構築された型を識別することがあります。 これは、ジェネリッククラス宣言内で型が入れ子になっている場合に発生する可能性があり、包含する宣言のインスタンス型は、名前参照 ([ジェネリッククラスの入れ子](classes.md#nested-types-in-generic-classes)にされた型) に暗黙的に使用されます。

```csharp
class Outer<T>
{
    public class Inner {...}

    public Inner i;                // Type of i is Outer<T>.Inner
}
```

アンセーフコードでは、構築された型を*unmanaged_type* ([ポインター型](unsafe-code.md#pointer-types)) として使用することはできません。

### <a name="type-arguments"></a>型引数

型引数リストの各引数は単なる*型*です。

```antlr
type_argument_list
    : '<' type_arguments '>'
    ;

type_arguments
    : type_argument (',' type_argument)*
    ;

type_argument
    : type
    ;
```

アンセーフコード ([unsafe コード](unsafe-code.md)) では、 *type_argument*をポインター型にすることはできません。 それぞれの型引数は、対応する型パラメーター ([型パラメーターの制約](classes.md#type-parameter-constraints)) に対する制約を満たす必要があります。

### <a name="open-and-closed-types"></a>Open 型と closed 型

すべての型は、***オープン型***または***閉じら***れた型として分類できます。 オープン型は、型パラメーターを含む型です。 具体的には次のようになります。

*  型パラメーターは、オープン型を定義します。
*  配列型は、要素型がオープン型である場合にのみ、オープン型になります。
*  構築された型は、型引数の1つ以上がオープン型である場合にのみ、オープン型になります。 構築された入れ子になった型は、その型引数の1つ以上がオープン型である場合にのみ、オープン型になります。

閉じられた型は、オープン型ではない型です。

実行時には、ジェネリック型宣言内のすべてのコードが、ジェネリック宣言に型引数を適用することによって作成されたクローズ構築型のコンテキストで実行されます。 ジェネリック型内の各型パラメーターは、特定の実行時の型にバインドされます。 すべてのステートメントおよび式の実行時処理は常に閉じられた型で発生し、オープン型はコンパイル時の処理中にのみ発生します。

閉じられた構築型にはそれぞれ、静的な変数のセットがあります。これは、その他の閉じた構築型とは共有されません。 オープン型は実行時に存在しないため、オープン型に関連付けられた静的変数はありません。 2つの閉じられた構築型は、同じ非バインドジェネリック型から構築され、それらに対応する型引数が同じ型である場合、同じ型になります。

### <a name="bound-and-unbound-types"></a>バインドおよびバインド解除された型

バインドされていない***型***とは、非ジェネリック型またはバインドされていないジェネリック型を指します。 "バインドされた***型***" とは、非ジェネリック型または構築された型を指します。

バインドされていない型は、型宣言によって宣言されたエンティティを参照します。 バインドされていないジェネリック型はそれ自体が型ではなく、変数、引数、または戻り値の型として、または基本型として使用することはできません。 バインドされていないジェネリック型を参照できる唯一のコンストラクトは、`typeof` 式 ([typeof 演算子](expressions.md#the-typeof-operator)) です。

### <a name="satisfying-constraints"></a>制約を満たす

構築された型またはジェネリックメソッドが参照されるたびに、指定された型引数は、ジェネリック型またはジェネリックメソッド ([型パラメーターの制約](classes.md#type-parameter-constraints)) で宣言された型パラメーターの制約に照らしてチェックされます。 `where` 句ごとに、名前付きの型パラメーターに対応する型引数 `A` が、次のように各制約に対してチェックされます。

*  制約がクラス型、インターフェイス型、または型パラメーターである場合、`C` は、制約に含まれる型パラメーターの代わりに指定された型引数を持つ制約を表すことができます。 制約を満たすには、型 `A` が、次のいずれかによって `C` 型に変換可能である必要があります。
    * Id 変換 ([id 変換](conversions.md#identity-conversion))
    * 暗黙の参照変換 ([暗黙的な参照](conversions.md#implicit-reference-conversions)変換)
    * 型 A が null 非許容の値型である場合、ボックス化変換 ([ボックス](conversions.md#boxing-conversions)化変換)。
    * 型パラメーター `A` から `C`への暗黙的な参照、ボックス化、または型パラメーターの変換。
*  制約が参照型制約 (`class`) の場合、型 `A` は次のいずれかを満たしている必要があります。
    * `A` は、インターフェイス型、クラス型、デリゲート型、または配列型です。 `System.ValueType` と `System.Enum` は、この制約を満たす参照型であることに注意してください。
    * `A` は、参照型 ([型パラメーターの制約](classes.md#type-parameter-constraints)) であることがわかっている型パラメーターです。
*  制約が値型制約 (`struct`) の場合、型 `A` は次のいずれかを満たしている必要があります。
    * `A` は構造体型または列挙型ですが、null 許容型ではありません。 `System.ValueType` と `System.Enum` は、この制約を満たしていない参照型であることに注意してください。
    * `A` は、値型の制約 ([型パラメーターの制約](classes.md#type-parameter-constraints)) を持つ型パラメーターです。
*  制約がコンストラクターの制約 `new()`の場合は、型 `A` を `abstract` せずに、パブリックなパラメーターなしのコンストラクターを持つ必要があります。 これは、次のいずれかに該当する場合に満たされます。
    * すべての値型にはパブリックな既定のコンストラクター ([既定のコンストラクター](types.md#default-constructors)) があるため、`A` は値型です。
    * `A` は、コンストラクターの制約 ([型パラメーターの制約](classes.md#type-parameter-constraints)) を持つ型パラメーターです。
    * `A` は、値型の制約 ([型パラメーターの制約](classes.md#type-parameter-constraints)) を持つ型パラメーターです。
    * `A` は `abstract` ないクラスであり、パラメーターを持たない明示的に宣言された `public` コンストラクターを含んでいます。
    * `A` が `abstract` ではなく、既定のコンストラクター ([既定のコンストラクター](classes.md#default-constructors)) を持っています。

指定された型引数によって1つ以上の型パラメーターの制約が満たされない場合、コンパイル時エラーが発生します。

型パラメーターは継承されないため、制約は継承されません。 次の例では、`T` が基本クラス `B<T>`によって課される制約を満たすように、型パラメーター `T` に対して制約を指定する必要があり `D`。 一方、`List<T>` は `T`に `IEnumerable` を実装しているため、クラス `E` では制約を指定する必要はありません。

```csharp
class B<T> where T: IEnumerable {...}

class D<T>: B<T> where T: IEnumerable {...}

class E<T>: B<List<T>> {...}
```

## <a name="type-parameters"></a>型パラメーター

型パラメーターは、実行時にパラメーターがバインドされる値型または参照型を指定する識別子です。

```antlr
type_parameter
    : identifier
    ;
```

型パラメーターは、さまざまな異なる実際の型引数を使用してインスタンス化できるため、型パラメーターには、他の型とは少し異なる操作と制限があります。 次の設定があります。

*  型パラメーターを直接使用して基底クラス ([基底クラス](classes.md#base-class)) またはインターフェイス ([バリアント型パラメーターリスト](interfaces.md#variant-type-parameter-lists)) を宣言することはできません。
*  型パラメーターに対するメンバー参照の規則は、型パラメーターに適用される制約によって異なります。 これらの詳細については、「[メンバー検索](expressions.md#member-lookup)」を参照してください。
*  型パラメーターに使用できる変換は、型パラメーターに適用される制約によって異なります。 これらの詳細については、型パラメーターと[明示的な動的変換](conversions.md#explicit-dynamic-conversions)を[含む暗黙の型変換](conversions.md#implicit-conversions-involving-type-parameters)について説明します。
*  型パラメーターが参照型であることがわかっている場合を除き、リテラル `null` を型パラメーターによって指定された型に変換することはできません ([型パラメーター](conversions.md#implicit-conversions-involving-type-parameters)を使用する暗黙的な変換)。 ただし、代わりに `default` 式 ([既定値の式](expressions.md#default-value-expressions)) を使用できます。 さらに、型パラメーターによって指定された型の値は、型パラメーターに値型の制約がない限り、`==` と `!=` ([参照型の等値演算子](expressions.md#reference-type-equality-operators)) を使用して、`null` と比較できます。
*  `new` 式 ([オブジェクト作成式](expressions.md#object-creation-expressions)) は、型パラメーターが*constructor_constraint*または値型の制約 ([型パラメーターの制約](classes.md#type-parameter-constraints)) によって制約されている場合にのみ、型パラメーターと共に使用できます。
*  型パラメーターは、属性内の任意の場所で使用することはできません。
*  静的メンバーまたは入れ子にされた型を識別するために、型パラメーターをメンバーアクセス ([メンバーアクセス](expressions.md#member-access)) または型名 ([名前空間と型名](basic-concepts.md#namespace-and-type-names)) で使用することはできません。
*  アンセーフコードでは、型パラメーターを*unmanaged_type* ([ポインター型](unsafe-code.md#pointer-types)) として使用することはできません。

型として、型パラメーターは純粋にコンパイル時の構成要素です。 実行時に、各型パラメーターは、ジェネリック型宣言に型引数を指定して指定されたランタイム型にバインドされます。 したがって、型パラメーターを使用して宣言された変数の型は、実行時にクローズ構築型 ([オープン型およびクローズ型](types.md#open-and-closed-types)) になります。 型パラメーターを含むすべてのステートメントおよび式の実行時の実行では、そのパラメーターの型引数として指定された実際の型を使用します。

## <a name="expression-tree-types"></a>式ツリー型

***式ツリー***では、ラムダ式を実行可能コードではなくデータ構造として表すことができます。 式ツリーは、`System.Linq.Expressions.Expression<D>`形式の***式ツリー型***の値です。 `D` は任意のデリゲート型です。 この仕様の残りの部分では、短縮形 `Expression<D>`を使用してこれらの型を参照します。

ラムダ式から `D`デリゲート型への変換が存在する場合、式ツリー型 `Expression<D>`にも変換されます。 ラムダ式からデリゲート型への変換では、ラムダ式の実行可能コードを参照するデリゲートが生成されますが、式ツリー型への変換では、ラムダ式の式ツリー表現が作成されます。

式ツリーは、ラムダ式の効率的なインメモリデータ表現であり、ラムダ式の構造を透過的かつ明示的にします。

デリゲート型 `D`と同様に、`Expression<D>` は `D`のパラメーターと戻り値の型と同じように扱われます。

次の例は、ラムダ式を実行可能コードおよび式ツリーとして表しています。 `Func<int,int>`への変換が存在するため、`Expression<Func<int,int>>`にも変換が存在します。

```csharp
Func<int,int> del = x => x + 1;                    // Code

Expression<Func<int,int>> exp = x => x + 1;        // Data
```

これらの代入の後、デリゲート `del` は `x + 1`を返すメソッドを参照し、式ツリー `exp` は式 `x => x + 1`を記述するデータ構造を参照します。

ジェネリック型 `Expression<D>` の正確な定義と、ラムダ式が式ツリー型に変換されるときに式ツリーを構築するための正確な規則は、両方ともこの仕様の範囲外です。

明示するには、次の2つのことが重要です。

*  すべてのラムダ式を式ツリーに変換することはできません。 たとえば、ステートメント本体を含むラムダ式や、代入式を含むラムダ式を表すことはできません。 このような場合は、変換はまだ存在しますが、コンパイル時に失敗します。 これらの例外の詳細については、「[匿名関数変換](conversions.md#anonymous-function-conversions)」を参考にしてください。
*   `Expression<D>` には、`D`型のデリゲートを生成するインスタンスメソッド `Compile` が用意されています。

    ```csharp
    Func<int,int> del2 = exp.Compile();
    ```

    このデリゲートを呼び出すと、式ツリーによって表されるコードが実行されます。 したがって、上記の定義を指定した場合、del と del2 は同等であり、次の2つのステートメントは同じ効果を持ちます。

    ```csharp
    int i1 = del(1);
    
    int i2 = del2(1);
    ```

    このコードを実行すると、`i1` と `i2` の両方に `2`値が設定されます。

