---
ms.openlocfilehash: f61039abd6bd557ac0ea625e6aac1c8bafa57b02
ms.sourcegitcommit: e134bb7058e9848120b93b345f96d6ac0cb8c815
ms.translationtype: MT
ms.contentlocale: ja-JP
ms.lasthandoff: 01/17/2020
ms.locfileid: "71704087"
---
# <a name="expressions"></a>式

式は一連の演算子とオペランドで構成されます。 この章では、構文、オペランドと演算子の評価順序、および式の意味を定義します。

## <a name="expression-classifications"></a>式の分類

式は、次のいずれかに分類されます。

*  値です。 すべての値には、型が関連付けられています。
*  変数。 すべての変数には、関連付けられた型、つまり変数の宣言型があります。
*  名前空間。 この分類の式は、 *member_access* ([メンバーアクセス](expressions.md#member-access)) の左側としてのみ使用できます。 その他のコンテキストでは、名前空間として分類された式によってコンパイル時エラーが発生します。
*  型。 この分類の式は、 *member_access* ([メンバーアクセス](expressions.md#member-access)) の左側として、または `as` 演算子 ([as 演算子](expressions.md#the-as-operator))、`is` 演算子 ([is 演算子](expressions.md#the-is-operator))、または `typeof` 演算子 ([typeof 演算子](expressions.md#the-typeof-operator)) のオペランドとしてのみ使用できます。 その他のコンテキストでは、型として分類された式によってコンパイル時エラーが発生します。
*  メソッドグループ。メンバー参照 ([メンバー参照](expressions.md#member-lookup)) の結果として得られる一連のオーバーロードされたメソッドです。 メソッドグループには、関連付けられたインスタンス式と、関連する型引数リストを含めることができます。 インスタンスメソッドが呼び出されると、インスタンス式を評価した結果が `this` ([このアクセス](expressions.md#this-access)) によって表されるインスタンスになります。 メソッドグループは、 *invocation_expression* ([呼び出し式](expressions.md#invocation-expressions))、 *delegate_creation_expression* ([デリゲート作成式](expressions.md#delegate-creation-expressions))、および is 演算子の左辺として許可され、互換性のあるデリゲート型 ([メソッドグループ変換](conversions.md#method-group-conversions)) に暗黙的に変換できます。 その他のコンテキストでは、メソッドグループとして分類された式によってコンパイル時エラーが発生します。
*  Null リテラル。 この分類を持つ式は、参照型または null 許容型に暗黙的に変換できます。
*  匿名関数。 この分類の式は、互換性のあるデリゲート型または式ツリー型に暗黙的に変換できます。
*  プロパティアクセス。 すべてのプロパティアクセスには、関連付けられた型、つまりプロパティの型があります。 さらに、プロパティアクセスには、関連付けられたインスタンス式が含まれる場合があります。 インスタンスプロパティアクセスのアクセサー (`get` または `set` ブロック) が呼び出されると、インスタンス式を評価した結果が、`this` ([このアクセス](expressions.md#this-access)) によって表されるインスタンスになります。
*  イベントアクセス。 すべてのイベントアクセスには、関連付けられた型、つまりイベントの種類があります。 さらに、イベントアクセスには、インスタンス式が関連付けられている場合もあります。 イベントアクセスは、`+=` 演算子と `-=` 演算子 ([イベント割り当て](expressions.md#event-assignment)) の左側のオペランドとして表示される場合があります。 その他のコンテキストでは、イベントアクセスとして分類された式によってコンパイル時エラーが発生します。
*  インデクサーアクセス。 すべてのインデクサーアクセスには、関連付けられた型、つまりインデクサーの要素型があります。 さらに、インデクサーアクセスには、インスタンス式と関連付けられた引数リストが関連付けられています。 インデクサーアクセスのアクセサー (`get` または `set` ブロック) が呼び出されると、インスタンス式を評価した結果が `this` ([このアクセス](expressions.md#this-access)) によって表されるインスタンスになり、引数リストを評価した結果が呼び出しのパラメーターリストになります。
*  Nothing。 このエラーは、式が `void`の戻り値の型を持つメソッドの呼び出しである場合に発生します。 Nothing として分類された式は、 *statement_expression* ([式ステートメント](statements.md#expression-statements)) のコンテキストでのみ有効です。

式の最終的な結果は、名前空間、型、メソッドグループ、またはイベントアクセスにはなりません。 前述のように、これらの式のカテゴリは、特定のコンテキストでのみ許可される中間構造です。

プロパティアクセスまたはインデクサーアクセスは、 *get アクセサー*または*set アクセサー*の呼び出しを実行することによって、常に値として再分類されます。 特定のアクセサーは、プロパティまたはインデクサーアクセスのコンテキストによって決定されます。アクセスが割り当てのターゲットである場合は、 *set アクセサー*が呼び出され、新しい値 ([単純な割り当て](expressions.md#simple-assignment)) が割り当てられます。 それ以外の場合は、 *get アクセサー*を呼び出して、現在の値 ([式の値](expressions.md#values-of-expressions)) を取得します。

### <a name="values-of-expressions"></a>式の値

式を含むほとんどのコンストラクトでは、最終的に***値***を示す式が必要になります。 このような場合、実際の式が名前空間、型、メソッドグループ、または nothing を表していると、コンパイル時エラーが発生します。 ただし、式がプロパティアクセス、インデクサーアクセス、または変数を表している場合、プロパティ、インデクサー、または変数の値は暗黙的に置き換えられます。

*  変数の値は、変数によって識別されるストレージの場所に現在格納されている値にすぎません。 変数は、値を取得する前に確実に代入 ([明確な代入](variables.md#definite-assignment)) される必要があります。そうしないと、コンパイル時エラーが発生します。
*  プロパティアクセス式の値は、プロパティの*get アクセサー*を呼び出すことによって取得されます。 プロパティに*get アクセサー*がない場合、コンパイル時エラーが発生します。 それ以外の場合は、関数メンバーの呼び出し ([動的なオーバーロードの解決のコンパイル時チェック](expressions.md#compile-time-checking-of-dynamic-overload-resolution)) が実行され、呼び出しの結果がプロパティアクセス式の値になります。
*  インデクサーアクセス式の値は、インデクサーの*get アクセサー*を呼び出すことによって取得されます。 インデクサーに*get アクセサー*がない場合、コンパイル時エラーが発生します。 それ以外の場合、関数メンバー呼び出し ([動的なオーバーロード解決のコンパイル時チェック](expressions.md#compile-time-checking-of-dynamic-overload-resolution)) は、インデクサーアクセス式に関連付けられている引数リストを使用して実行され、呼び出しの結果がインデクサーアクセス式の値になります。

## <a name="static-and-dynamic-binding"></a>静的バインドと動的バインド

構成式 (引数、オペランド、レシーバー) の型または値に基づいて操作の意味を判断するプロセスは、多くの場合、***バインド***と呼ばれます。 たとえば、メソッド呼び出しの意味は、受信側と引数の型に基づいて決定されます。 演算子の意味は、そのオペランドの型に基づいて決定されます。

でC#は、通常、操作の意味はコンパイル時に決定され、その構成式のコンパイル時の型に基づいて決定されます。 同様に、式にエラーが含まれている場合は、コンパイラによってエラーが検出され、報告されます。 この方法は、***静的バインド***と呼ばれます。

ただし、式が動的な式 (つまり、型が `dynamic`) の場合、その式が参加しているすべてのバインディングは、コンパイル時に含まれる型ではなく、その実行時の型 (つまり、実行時に示されるオブジェクトの実際の型) に基づいている必要があることを示します。 そのため、このような操作のバインドは、プログラムの実行中に操作が実行される時間まで延期されます。 これを***動的バインド***と呼びます。

操作が動的にバインドされる場合、コンパイラによるチェックはほとんどまたはまったく実行されません。 代わりに、実行時のバインドが失敗した場合、実行時にエラーが例外として報告されます。

のC#次の操作は、バインドの対象となります。

*  メンバーアクセス: `e.M`
*  メソッドの呼び出し: `e.M(e1, ..., eN)`
*  デリゲート呼び出し:`e(e1, ..., eN)`
*  要素アクセス: `e[e1, ..., eN]`
*  オブジェクトの作成: `new C(e1, ..., eN)`
*  オーバーロードされた単項演算子: `+`、`-`、`!`、`~`、`++`、`--`、`true`、`false`
*  オーバーロードされた二項演算子: `+`、`-`、`*`、`/`、`%`、`&`、`&&`、`|`、`||`、`??`、`^`、`<<`、`>>`、`==`、`!=`
*  代入演算子: `=`、`+=`、`-=`、`*=`、`/=`、`%=`、`&=`、`|=`、`^=`、`<<=`、`>>=`
*  暗黙的な変換と明示的な変換

動的な式が関係しないC#場合、既定では静的バインディングが使用されます。これは、構成式のコンパイル時の型が選択プロセスで使用されることを意味します。 ただし、上記の操作のいずれかの構成式が動的な式である場合、その操作は動的にバインドされます。

### <a name="binding-time"></a>バインド-時間

静的バインドはコンパイル時に行われますが、動的バインドは実行時に行われます。 次のセクションでは、バインド***時間***とは、バインディングがいつ行われるかに応じて、コンパイル時または実行時を指します。

次の例は、静的バインディングと動的バインドの概念とバインド時の概念を示しています。
```csharp
object  o = 5;
dynamic d = 5;

Console.WriteLine(5);  // static  binding to Console.WriteLine(int)
Console.WriteLine(o);  // static  binding to Console.WriteLine(object)
Console.WriteLine(d);  // dynamic binding to Console.WriteLine(int)
```

最初の2つの呼び出しは静的にバインドされます。 `Console.WriteLine` のオーバーロードは、引数のコンパイル時の型に基づいて選択されます。 したがって、バインディング時間はコンパイル時です。

3番目の呼び出しは動的にバインドされます。 `Console.WriteLine` のオーバーロードは、引数の実行時の型に基づいて選択されます。 これは、引数が動的な式である (コンパイル時の型が `dynamic`) ために発生します。 そのため、3番目の呼び出しのバインディング時間は実行時です。

### <a name="dynamic-binding"></a>動的バインディング

動的バインディングの目的は、プログラムがC# ***動的オブジェクト***(つまり、 C#型システムの通常の規則に従っていないオブジェクト) と対話できるようにすることです。 動的オブジェクトは、異なる型システムを使用する他のプログラミング言語のオブジェクトである場合もあれば、異なる操作のために独自のバインディングセマンティクスを実装するようにプログラムで設定されるオブジェクトの場合もあります。

動的オブジェクトが独自のセマンティクスを実装する機構は、実装が定義されていることです。 指定されたインターフェイス--再実装が定義されている場合は、特殊C#なセマンティクスがあることをランタイムに通知するために、動的オブジェクトによって実装されます。 したがって、動的なオブジェクトに対する操作が動的にバインドされる場合、このドキュメントで指定C#されているものではなく、独自のバインディングセマンティクスが引き継がれます。

動的バインドの目的は動的オブジェクトとの相互運用を可能にC#することであるのに対し、は動的なバインドであるかどうかにかかわらず、すべてのオブジェクトで動的バインドを許可します。 これにより、動的オブジェクトに対する操作の結果が動的なオブジェクトになるとは限りませんが、コンパイル時にはプログラマにとって未知の型になります。 また、動的バインドを使用すると、オブジェクトが動的オブジェクトに関連しない場合でも、エラーが発生しやすいリフレクションベースのコードを排除できます。

次のセクションでは、動的バインドが適用されたときの言語の各構成要素、コンパイル時のチェック (適用されている場合)、およびコンパイル時の結果と式の分類について説明します。

### <a name="types-of-constituent-expressions"></a>構成式の型

操作が静的にバインドされている場合、構成式の型 (たとえば、レシーバー、引数、インデックス、またはオペランド) は、常にその式のコンパイル時の型と見なされます。

操作が動的にバインドされる場合、構成式の型は、構成式のコンパイル時の型に応じて、さまざまな方法で決定されます。

*  コンパイル時の型 `dynamic` の構成式は、実行時に式が評価する実際の値の型を持つと見なされます。
*  コンパイル時の型が型パラメーターである構成式は、実行時に型パラメーターがバインドされる型を持つと見なされます。
*  それ以外の場合、構成式はコンパイル時の型を持つと見なされます。

## <a name="operators"></a>演算子

式は、***オペランド***と***演算子***から構築されます。 式の演算子は、オペランドに適用する演算を表します。 演算子の例として、`+`、`-`、`*`、`/`、および `new` などがあります。 オペランドの例としては、リテラル、フィールド、ローカル変数、式などがあります。

演算子には、次の3種類があります。

*  単項演算子。 単項演算子は1つのオペランドを受け取り、プレフィックス表記 (`--x`など) または後置表記 (`x++`など) のいずれかを使用します。
*  二項演算子。 二項演算子は2つのオペランドを受け取り、すべて挿入辞表記 (`x + y`など) を使用します。
*  三項演算子。 三項演算子 `?:`は1つだけ存在します。3つのオペランドを受け取り、挿入辞表記 (`c ? x : y`) を使用します。

式における演算子の評価の順序は、演算子の***優先順位***と***結合規則***(演算子の[優先順位と結合規則](expressions.md#operator-precedence-and-associativity)) によって決まります。

式のオペランドは左から右に評価されます。 たとえば、`F(i) + G(i++) * H(i)`では、メソッド `F` は `i`の古い値を使用して呼び出され、メソッド `G` は `i`の古い値を使用して呼び出され、最後にメソッド `H` が `i`の新しい値で呼び出されます。 これは、演算子の優先順位とは別のものです。

特定の演算子は***オーバーロード***できます。 演算子のオーバーロードでは、一方または両方のオペランドがユーザー定義のクラスまたは構造体の型 ([演算子のオーバーロード](expressions.md#operator-overloading)) である操作に対して、ユーザー定義の演算子の実装を指定できます。

### <a name="operator-precedence-and-associativity"></a>演算子の優先順位と結合規則

複数の演算子を含む式の場合、演算子の***優先順位***によって各々の演算子が評価される順序が決定されます。 たとえば、式 `x + y * z` は `x + (y * z)` として評価されます。これは、`*` 演算子の優先順位がバイナリ `+` 演算子よりも高いためです。 演算子の優先順位は、関連付けられている文法の定義によって決定されます。 たとえば、 *additive_expression*は `+` または `-` の演算子で区切られた一連の*multiplicative_expression*で構成されます。したがって、`+` 演算子と `-` 演算子の優先順位は、`*`、`/`、および `%` になります。

次の表は、すべての演算子を優先順位の高い順に示しています。

| __Section__                                                                                   | __カテゴリ__                | __演算子__ | 
|-----------------------------------------------------------------------------------------------|-----------------------------|---------------|
| [一次式](expressions.md#primary-expressions)                                     | Primary                     | `x.y`  `f(x)`  `a[x]`  `x++`  `x--`  `new`  `typeof`  `default`  `checked`  `unchecked`  `delegate` | 
| [単項演算子](expressions.md#unary-operators)                                             | 単項                       | `+`  `-`  `!`  `~`  `++x`  `--x`  `(T)x` | 
| [算術演算子](expressions.md#arithmetic-operators)                                   | 乗法              | `*`  `/`  `%` | 
| [算術演算子](expressions.md#arithmetic-operators)                                   | 加法                    | `+`  `-`      | 
| [シフト演算子](expressions.md#shift-operators)                                             | シフト                       | `<<`  `>>`    | 
| [関係演算子と型検査演算子](expressions.md#relational-and-type-testing-operators) | 関係式と型検査 | `<`  `>`  `<=`  `>=`  `is`  `as` | 
| [関係演算子と型検査演算子](expressions.md#relational-and-type-testing-operators) | 等価比較                    | `==`  `!=`    | 
| [論理演算子](expressions.md#logical-operators)                                         | 論理 AND                 | `&`           | 
| [論理演算子](expressions.md#logical-operators)                                         | 論理 XOR                 | `^`           | 
| [論理演算子](expressions.md#logical-operators)                                         | 論理 OR                  | <code>&#124;</code>           |
| [条件論理演算子](expressions.md#conditional-logical-operators)                 | 条件 AND             | `&&`          | 
| [条件論理演算子](expressions.md#conditional-logical-operators)                 | 条件 OR              | <code>&#124;&#124;</code>          | 
| [null 合体演算子](expressions.md#the-null-coalescing-operator)                   | Null 合体演算子             | `??`          | 
| [条件演算子](expressions.md#conditional-operator)                                   | 条件                 | `?:`          | 
| [代入演算子](expressions.md#assignment-operators)、[匿名関数式](expressions.md#anonymous-function-expressions)  | 代入式とラムダ式 | `=`  `*=`  `/=`  `%=`  `+=`  `-=`  `<<=`  `>>=`  `&=`  `^=`  <code>&#124;=</code>  `=>` | 

同じ優先順位を持つ2つの演算子の間にオペランドがある場合、演算子の結合規則によって、操作の実行順序が制御されます。

*  代入演算子および null 合体演算子を除き、すべての二項演算子は左から右へと***結合***されます。つまり、操作は左から右に実行されます。 たとえば、`x + y + z` は `(x + y) + z` と評価されます。
*  代入演算子、null 合体演算子、および条件演算子 (`?:`***) は、右から***左に操作が実行されることを意味します。 たとえば、`x = y = z` は `x = (y = z)` と評価されます。

優先順位と結合性は、かっこを使用して制御することができます。 たとえば、`x + y * z` は最初に `y` と `z` を掛け、そして結果を `x` に足しますが、`(x + y) * z` では最初に `x` と `y` を足してから `z` を掛けます。

### <a name="operator-overloading"></a>演算子のオーバーロード

すべての単項演算子と二項演算子には、任意の式で自動的に使用できる定義済みの実装があります。 定義済みの実装に加えて、クラスと構造体 ([演算子](classes.md#operators)) に `operator` 宣言を含めることによって、ユーザー定義の実装を導入することができます。 ユーザー定義の演算子の実装は、常に定義済みの演算子の実装よりも優先されます。ユーザー定義の演算子の実装が存在しない場合のみ、[単項演算子のオーバーロードの解決](expressions.md#unary-operator-overload-resolution)と[二項演算子のオーバーロードの解決](expressions.md#binary-operator-overload-resolution)に関するページで説明されているように、定義済みの演算子の実装が考慮されます。

オーバーロード可能な***単項演算子***は次のとおりです。
```csharp
+   -   !   ~   ++   --   true   false
```

`true` と `false` は式では明示的に使用されません (したがって、演算子の[優先順位と結合規則](expressions.md#operator-precedence-and-associativity)の優先順位テーブルには含まれません) が、演算子と見なされます。これは、ブール式 ([ブール式](expressions.md#boolean-expressions)) と条件付き演算子 (条件付き[演算子](expressions.md#conditional-operator)) を含む式 (条件付き[論理演算子](expressions.md#conditional-logical-operators)) で呼び出されるためです。

オーバーロードされた***二項演算子***は次のとおりです。
```csharp
+   -   *   /   %   &   |   ^   <<   >>   ==   !=   >   <   >=   <=
```

上に示した演算子のみをオーバーロードできます。 特に、メンバーアクセス、メソッド呼び出し、`=`、`&&`、`||`、`??`、`?:`、`=>`、`checked`、`unchecked`、`new`、`typeof`、`default`、`as`、`is` の各演算子をオーバーロードすることはできません。

二項演算子をオーバーロードすると、対応する代入演算子がある場合、これも暗黙的にオーバーロードされます。 たとえば、operator `*` のオーバーロードは、operator `*=`のオーバーロードでもあります。 詳細については、「[複合代入](expressions.md#compound-assignment)」を参照してください。 代入演算子自体 (`=`) はオーバーロードできないことに注意してください。 代入は常に、値の単純なビット単位のコピーを変数に対して実行します。

`(T)x`などのキャスト操作は、ユーザー定義の変換 ([ユーザー定義の変換](conversions.md#user-defined-conversions)) を提供することによってオーバーロードされます。

`a[x]`などの要素アクセスは、オーバーロード可能な演算子とは見なされません。 代わりに、インデクサー ([インデクサー](classes.md#indexers)) を使用してユーザー定義のインデックス作成がサポートされます。

式では、演算子は演算子表記を使用して参照され、宣言では、演算子は関数表記を使用して参照されます。 次の表は、単項演算子と二項演算子の演算子と関数表記の関係を示しています。 最初のエントリで、 *op*はオーバーロードされた単項前置演算子を表します。 2番目のエントリでは、 *op*は単項後置 `++` と `--` 演算子を表します。 3番目のエントリでは、 *op*はオーバーロード可能な任意の二項演算子を表します。


| __演算子の表記__ | __関数型表記__ |
|-----------------------|-------------------------|
| `op x`                | `operator op(x)`        | 
| `x op`                | `operator op(x)`        | 
| `x op y`              | `operator op(x,y)`      | 

ユーザー定義の演算子宣言には、常に、演算子宣言を含むクラスまたは構造体型のパラメーターが少なくとも1つ必要です。 したがって、ユーザー定義の演算子は、定義済みの演算子と同じシグネチャを持つことはできません。

ユーザー定義の演算子宣言では、演算子の構文、優先順位、または結合規則を変更できません。 たとえば、`/` 演算子は常に二項演算子であり、[演算子の優先順位と結合規則](expressions.md#operator-precedence-and-associativity)で指定された優先順位レベルを常に持ち、常に左から結合されます。

ユーザー定義の演算子は、pleases の計算を実行することができますが、直感的に想定されているもの以外の結果を生成する実装は避けることを強くお勧めします。 たとえば、`operator ==` の実装では、2つのオペランドが等しいかどうかを比較し、適切な `bool` 結果を返す必要があります。

[条件付き論理演算子](expressions.md#conditional-logical-operators)を使用した[主な式](expressions.md#primary-expressions)の各演算子の説明では、演算子の定義済みの実装と、各演算子に適用される追加の規則を指定します。 この説明では、***単項演算子のオーバーロードの解決***、***二項演算子のオーバーロードの解決***、および数値の***上位変換***という用語を使用します。これらの定義については、次のセクションで説明します。

### <a name="unary-operator-overload-resolution"></a>単項演算子のオーバーロードの解決

`op x` または `x op`の形式の演算。ここで `op` は、オーバーロード可能な単項演算子で、`x` は `X`型の式で、次のように処理されます。

*  操作 `operator op(x)` に対して `X` によって提供される一連のユーザー定義演算子は、[ユーザー定義の候補演算子](expressions.md#candidate-user-defined-operators)の規則を使用して決定されます。
*  一連のユーザー定義演算子が空でない場合は、これが操作の候補演算子のセットになります。 それ以外の場合、定義済みの単項 `operator op` 実装 (リフトされた形式を含む) は、操作の候補演算子のセットになります。 特定の演算子の定義済みの実装は、演算子の説明 (主な[式](expressions.md#primary-expressions)および[単項演算子](expressions.md#unary-operators)) で指定されます。
*  [オーバーロード解決](expressions.md#overload-resolution)のオーバーロード解決規則は候補演算子のセットに適用され、`(x)`引数リストに対して最適な演算子を選択します。この演算子は、オーバーロードの解決プロセスの結果になります。 オーバーロードの解決で1つの最適な演算子を選択できなかった場合、バインド時エラーが発生します。

### <a name="binary-operator-overload-resolution"></a>二項演算子のオーバーロードの解決

`x op y`形式の演算。ここで `op` は、オーバーロード可能な二項演算子で、`x` は型 `X`の式で、`y` は型 `Y`の式で、次のように処理されます。

*  操作 `operator op(x,y)` に対して `X` および `Y` によって提供される一連の候補ユーザー定義演算子が決定されます。 このセットは、`X` によって提供される候補演算子と `Y`によって提供される候補演算子の和集合で構成されます。各演算子は、[ユーザー定義演算子の候補](expressions.md#candidate-user-defined-operators)の規則を使用して決定されます。 `X` と `Y` が同じ型である場合、または `X` と `Y` が共通の基本型から派生している場合、共有候補の演算子は、結合されたセット内で1回だけ発生します。
*  一連のユーザー定義演算子が空でない場合は、これが操作の候補演算子のセットになります。 それ以外の場合、定義済みのバイナリ `operator op` 実装 (リフトされた形式を含む) が操作の候補演算子のセットになります。 特定の演算子の定義済みの実装は、演算子の説明で指定されます ([条件付き論理演算子](expressions.md#conditional-logical-operators)を使用した[算術演算子](expressions.md#arithmetic-operators))。 定義済みの列挙型およびデリゲート演算子の場合、考慮される演算子は、列挙型またはデリゲート型によって定義されている演算子のうち、いずれかのオペランドのバインド時の型であるものだけです。
*  [オーバーロード解決](expressions.md#overload-resolution)のオーバーロード解決規則は候補演算子のセットに適用され、`(x,y)`引数リストに対して最適な演算子を選択します。この演算子は、オーバーロードの解決プロセスの結果になります。 オーバーロードの解決で1つの最適な演算子を選択できなかった場合、バインド時エラーが発生します。

### <a name="candidate-user-defined-operators"></a>ユーザー定義演算子の候補

型 `T` と操作 `operator op(A)`が指定されている場合、`op` はオーバーロード可能な演算子であり、`A` は引数リストであるため、`T` の `operator op(A)` によって提供される候補ユーザー定義演算子のセットは、次のように決定されます。

*  `T0`型を決定します。 `T` が null 許容型である場合、`T0` はその基になる型であり、それ以外の場合は `T0` が `T`になります。
*  `T0` 内のすべての `operator op` 宣言、およびそのような演算子のすべてのリフトされた形式では、`A`の引数リストに対して少なくとも1つの演算子 ([適用可能な関数メンバー](expressions.md#applicable-function-member)) が適用される場合、候補演算子のセットは `T0`内の該当するすべての演算子で構成されます。
*  それ以外の場合、`T0` が `object`場合、候補演算子のセットは空になります。
*  それ以外の場合、`T0` によって提供される候補演算子のセットは、`T0`の直接基底クラスによって提供される候補演算子のセット、または `T0` が型パラメーターである場合は `T0` の有効な基本クラスです。

### <a name="numeric-promotions"></a>数値の上位変換

数値の上位変換は、定義済みの単項演算子と二項数値演算子のオペランドの特定の暗黙的な変換を自動的に実行することで構成されます。 数値の上位変換は個別のメカニズムではなく、定義済みの演算子にオーバーロードの解決を適用した場合の効果です。 数値の上位変換は、特にユーザー定義の演算子の評価には影響しませんが、同様の効果をもたらすためにユーザー定義の演算子を実装することはできます。

数値の上位変換の例として、バイナリ `*` 演算子の定義済みの実装について考えてみましょう。

```csharp
int operator *(int x, int y);
uint operator *(uint x, uint y);
long operator *(long x, long y);
ulong operator *(ulong x, ulong y);
float operator *(float x, float y);
double operator *(double x, double y);
decimal operator *(decimal x, decimal y);
```

オーバーロードの解決規則 ([オーバーロードの解決](expressions.md#overload-resolution)) がこの一連の演算子に適用される場合、結果として、オペランドの型から暗黙的な変換が存在する最初の演算子が選択されます。 たとえば、操作 `b * s`の場合、`b` は `byte`、`s` は `short`であるため、オーバーロードの解決では最適な演算子として `operator *(int,int)` が選択されます。 したがって、`b` と `s` は `int`に変換され、結果の型は `int`になります。 同様に、操作 `i * d`では、`i` は `int`、`d` は `double`であるため、オーバーロードの解決では、最適な演算子として `operator *(double,double)` が選択されます。

#### <a name="unary-numeric-promotions"></a>単項数値の上位変換

単項数値の上位変換は、定義済みの `+`、`-`、および `~` 単項演算子のオペランドに対して行われます。 単項数値の上位変換は、型 `sbyte`、`byte`、`short`、`ushort`、または `char` のオペランドを型 `int`に変換するだけで構成されます。 さらに、単項 `-` 演算子では、単項数値の上位変換では `uint` 型のオペランドが `long`型に変換されます。

#### <a name="binary-numeric-promotions"></a>バイナリ数値の上位変換

バイナリ数値の上位変換は、定義済みの `+`、`-`、`*`、`/`、`%`、`&`、`|`、`^`、`==`、`!=`、`>`、`<`、`>=`、および `<=` 二項演算子のオペランドに対して行われます。 バイナリ数値の昇格では、両方のオペランドが共通の型に暗黙的に変換されます。これは、非関係演算子の場合、演算の結果の型にもなります。 バイナリ数値の上位変換では、次のルールがここに表示される順序で適用されます。

*  いずれかのオペランドが `decimal`型である場合、もう一方のオペランドが `decimal`型に変換されるか、または他のオペランドが `float` または `double`型である場合は、バインディング時エラーが発生します。
*  それ以外の場合、いずれかのオペランドが `double`型である場合、もう一方のオペランドは `double`型に変換されます。
*  それ以外の場合、いずれかのオペランドが `float`型である場合、もう一方のオペランドは `float`型に変換されます。
*  それ以外の場合、いずれかのオペランドが `ulong`型である場合は、もう一方のオペランドが `ulong`型に変換されるか、または他のオペランドが `sbyte`、`short`、`int`、または `long`型の場合、バインド時エラーが発生します。
*  それ以外の場合、いずれかのオペランドが `long`型である場合、もう一方のオペランドは `long`型に変換されます。
*  それ以外の場合、いずれかのオペランドが `uint` 型で、もう一方のオペランドが `sbyte`、`short`、または `int`型である場合、両方のオペランドが型 `long`に変換されます。
*  それ以外の場合、いずれかのオペランドが `uint`型である場合、もう一方のオペランドは `uint`型に変換されます。
*  それ以外の場合、両方のオペランドが `int`型に変換されます。

最初のルールでは、`decimal` の種類と `double` と `float` の種類を混在させる操作は許可されていないことに注意してください。 このルールは、`decimal` 型と `double` と `float` の型の間に暗黙的な変換がないという事実から、次のようになります。

もう一方のオペランドが符号付き整数型の場合、オペランドを `ulong` 型にすることはできないことにも注意してください。 これは、`ulong` の完全な範囲と符号付き整数型を表すことができる整数型が存在しないためです。

どちらの場合も、キャスト式を使用して、あるオペランドを他のオペランドと互換性のある型に明示的に変換できます。

この例では、
```csharp
decimal AddPercent(decimal x, double percent) {
    return x * (1.0 + percent / 100.0);
}
```
`decimal` に `double`で乗算できないため、バインド時エラーが発生します。 このエラーは、次のように、2番目のオペランドを `decimal`に明示的に変換することによって解決されます。

```csharp
decimal AddPercent(decimal x, double percent) {
    return x * (decimal)(1.0 + percent / 100.0);
}
```

### <a name="lifted-operators"></a>リフト演算子

***リフト***された演算子を使用すると、null 非許容の値型を操作する定義済みの演算子とユーザー定義の演算子を、これらの型の null 許容形式でも使用できます。 リフトされた演算子は、以下で説明するように、特定の要件を満たす定義済み演算子およびユーザー定義演算子から構築されます。

*   単項演算子の場合

    ```csharp
    +  ++  -  --  !  ~
    ```

    オペランドと結果の型が両方とも null 非許容の値型である場合、演算子のリフトされた形式が存在します。 リフトされた形式を作成するには、オペランドと結果の型に1つの `?` 修飾子を追加します。 オペランドが null の場合、リフトされた演算子は null 値を生成します。 それ以外の場合、リフトされた演算子はオペランドのラップを解除し、基になる演算子を適用して、結果をラップします。

*   二項演算子の場合

    ```csharp
    +  -  *  /  %  &  |  ^  <<  >>
    ```

    オペランドと結果の型がすべて null 非許容の値型である場合、演算子のリフトされた形式が存在します。 リフトされた形式を作成するには、各オペランドと結果の型に1つの `?` 修飾子を追加します。 リフトされた演算子は、一方または両方のオペランドが null の場合、null 値を生成します (ブール型の[論理演算子](expressions.md#boolean-logical-operators)に関するページで説明されているように、`bool?` 型の `&` 演算子と `|` 演算子である例外)。 それ以外の場合、リフトされた演算子はオペランドのラップを解除し、基になる演算子を適用して、結果をラップします。

*   等値演算子の場合

    ```csharp
    ==  !=
    ```

    オペランドの型が null 非許容の値型であり、結果の型が `bool`場合、演算子のリフトされた形式が存在します。 リフトされた形式を作成するには、各オペランド型に1つの `?` 修飾子を追加します。 リフトされた演算子は、2つの null 値が等しいと見なされ、null 値は null 以外の値と等しくなりません。 両方のオペランドが null 以外の場合、リフトされた演算子はオペランドのラップを解除し、基になる演算子を適用して `bool` の結果を生成します。

*   関係演算子

    ```csharp
    <  >  <=  >=
    ```

    オペランドの型が null 非許容の値型であり、結果の型が `bool`場合、演算子のリフトされた形式が存在します。 リフトされた形式を作成するには、各オペランド型に1つの `?` 修飾子を追加します。 リフトされた演算子は、一方または両方のオペランドが null の場合に `false` 値を生成します。 それ以外の場合、リフトされた演算子はオペランドのラップを解除し、基になる演算子を適用して `bool` の結果を生成します。

## <a name="member-lookup"></a>メンバーの参照

メンバー参照とは、型のコンテキストにおける名前の意味が決定されるプロセスです。 メンバー参照は、式での*simple_name* ([簡易名](expressions.md#simple-names)) または*member_access* ([メンバーアクセス](expressions.md#member-access)) の評価の一部として発生することがあります。 *Simple_name*または*member_access*が*invocation_expression* ([メソッド呼び出し](expressions.md#method-invocations)) の*primary_expression*として発生した場合、メンバーは呼び出されていると言います。

メンバーがメソッドまたはイベントの場合、またはデリゲート型 ([デリゲート](delegates.md)) または型 `dynamic` ([動的型](types.md#the-dynamic-type)) の定数、フィールド、またはプロパティである場合、メンバーは*invocable*と呼ばれます。

メンバーの検索では、メンバーの名前だけでなく、メンバーに含まれる型パラメーターの数と、メンバーにアクセスできるかどうかも考慮されます。 メンバー参照のために、ジェネリックメソッドと入れ子になったジェネリック型にはそれぞれの宣言で指定された型パラメーターの数があり、他のすべてのメンバーにはゼロ型パラメーターがあります。

型 `T` の  型パラメーターを `K` `N` 名前のメンバー参照は、次のように処理されます。

*  まず、 `N` という名前のアクセス可能なメンバーのセットが決定されます。
    * `T` が型パラメーターの場合、 `T`のプライマリ制約またはセカンダリ制約 ([型パラメーター制約](classes.md#type-parameter-constraints)) として指定された各型の `N` という名前のアクセス可能なメンバーのセットは、`object`内の `N` という名前のアクセス可能なメンバーのセットと共に結合されます。
    * それ以外の場合、このセットは、 `T`内の `N` という名前のすべてのアクセス可能な ([メンバーアクセス](basic-concepts.md#member-access)) メンバーで構成されます。これには、継承されたメンバーや、`object`内の `N` という名前のアクセス可能 `T` が構築された型である場合は、「構築された[型のメンバー](classes.md#members-of-constructed-types)」で説明されているように、型引数を置き換えることによってメンバーのセットを取得します。 `override` 修飾子を含むメンバーは、セットから除外されます。
*  次に、`K` がゼロの場合、宣言に型パラメーターを含む入れ子になったすべての型が削除されます。 `K` がゼロでない場合は、型パラメーターの数が異なるメンバーがすべて削除されます。 `K` がゼロの場合、型パラメーターを持つメソッドは削除されません。これは、型の推論プロセス ([型の推定](expressions.md#type-inference)) が型引数を推論できる可能性があるためです。
*  次に、メンバーが*呼び出さ*れると、*invocable*以外のすべてのメンバーがセットから削除されます。
*  次に、他のメンバーによって非表示になっているメンバーがセットから削除されます。 Set 内のすべてのメンバー `S.M` について、`S` はメンバー `M` が宣言されている型であるため、次の規則が適用されます。
    * `M` が定数、フィールド、プロパティ、イベント、または列挙型のメンバーである場合は、`S` の基本型で宣言されたすべてのメンバーがセットから削除されます。
    * `M` が型宣言の場合、`S` の基本型で宣言されているすべての非型は、セットから削除され、`S` の基本型で宣言された `M` と同じ数の型パラメーターを持つすべての型宣言は、セットから削除されます。
    * `M` がメソッドの場合、`S` の基本型で宣言されているすべての非メソッドメンバーがセットから削除されます。
*  次に、クラスメンバーによって隠ぺいされたインターフェイスメンバーがセットから削除されます。 このステップは、`T` が型パラメーターであり、`object` 以外の有効な基本クラスと、空でない有効なインターフェイスセット ([型パラメーター制約](classes.md#type-parameter-constraints)) の両方が `T` 場合にのみ効果があります。 Set 内のすべてのメンバー `S.M` について、`S` はメンバー `M` が宣言されている型であるため、`S` が `object`以外のクラス宣言の場合、次の規則が適用されます。
    * `M` が定数、フィールド、プロパティ、イベント、列挙型のメンバー、または型の宣言である場合、インターフェイス宣言で宣言されているすべてのメンバーがセットから削除されます。
    * `M` がメソッドの場合は、インターフェイス宣言で宣言されているすべての非メソッドメンバーがセットから削除され、インターフェイス宣言で宣言された `M` と同じシグネチャを持つすべてのメソッドがセットから削除されます。
*  最後に、非表示のメンバーを削除すると、参照の結果が決定されます。
    * セットが、メソッドではない1つのメンバーで構成されている場合、このメンバーは参照の結果になります。
    * それ以外の場合、セットにメソッドが含まれている場合、このメソッドのグループは参照の結果になります。
    * それ以外の場合、参照はあいまいであり、バインド時エラーが発生します。

型パラメーターとインターフェイス以外の型のメンバー参照、および厳密に単一継承であるインターフェイス内のメンバー参照 (継承チェーンの各インターフェイスには、完全に0または1つの直接基底インターフェイスがある) の場合、検索規則の効果は派生メンバーが同じ名前またはシグネチャを持つ基本メンバーを非表示にするだけです。 このような単一継承の参照があいまいになることはありません。 複数継承インターフェイスのメンバー参照で生じる可能性があるあいまいさについては、「[インターフェイスメンバーアクセス](interfaces.md#interface-member-access)」を参照してください。

### <a name="base-types"></a>基本型

メンバー検索の目的では、型 `T` は次の基本型を持つと見なされます。

*  `T` が `object`場合、`T` には基本型がありません。
*  `T` が*enum_type*の場合、`T` の基本型は `System.Enum`、`System.ValueType`、および `object`のクラス型です。
*  `T` が*struct_type*の場合、`T` の基本型は `System.ValueType` および `object`のクラス型です。
*  `T` が*class_type*の場合、`T` の基本型は、クラス型 `object`を含む `T`の基本クラスです。
*  `T` が*interface_type*の場合、`T` の基本型は `T` の基本インターフェイスであり、クラス型 `object`です。
*  `T` が*array_type*の場合、`T` の基本型は `System.Array` および `object`のクラス型です。
*  `T` が*delegate_type*の場合、`T` の基本型は `System.Delegate` および `object`のクラス型です。

## <a name="function-members"></a>関数のメンバー

関数メンバーは、実行可能なステートメントを含むメンバーです。 関数メンバーは常に型のメンバーであり、名前空間のメンバーになることはできません。 C#では、次のカテゴリの関数メンバーが定義されています。

*  メソッド
*  [プロパティ]
*  Events
*  インデクサー
*  ユーザー定義の演算子
*  インスタンスコンストラクター
*  静的コンストラクター
*  デストラクター

デストラクターと静的コンストラクター (明示的に呼び出すことはできません) を除き、関数メンバーに含まれるステートメントは、関数メンバー呼び出しを通じて実行されます。 関数メンバー呼び出しを記述する実際の構文は、特定の関数メンバーカテゴリによって異なります。

関数メンバー呼び出しの引数リスト ([引数](expressions.md#argument-lists)リスト) は、関数メンバーのパラメーターに対する実際の値または変数参照を提供します。

ジェネリックメソッドの呼び出しでは、型の推定を使用して、メソッドに渡す型引数のセットを決定できます。 このプロセスについては、 [「型の推定](expressions.md#type-inference)」を参照してください。

メソッド、インデクサー、演算子、およびインスタンスコンストラクターの呼び出しは、オーバーロードの解決を使用して、呼び出し元の候補となる関数メンバーのセットを決定します。 このプロセスの詳細については、「[オーバーロードの解決](expressions.md#overload-resolution)」を参照してください。

バインディング時に特定の関数メンバーが特定された後、場合によってはオーバーロードの解決によって、関数メンバーを呼び出す実際の実行時プロセスについては、「[動的なオーバーロードの解決のコンパイル時のチェック](expressions.md#compile-time-checking-of-dynamic-overload-resolution)」で説明されています。

次の表は、明示的に呼び出すことができる関数メンバーの6つのカテゴリを含む構造体で行われる処理をまとめたものです。 テーブルでは、`e`、`x`、`y`、および `value` は、変数または値として分類された式を示します。 `T` は、型として分類される式、`F` はメソッドの簡易名、`P` はプロパティの簡易名です。


| __構築__     | __例__    | __説明__ |
|-------------------|----------------|-----------------|
| メソッドの呼び出し | `F(x,y)`       | オーバーロードの解決は、含んでいるクラスまたは構造体で `F` 最適なメソッドを選択するために適用されます。 `(x,y)`引数リストを使用してメソッドが呼び出されます。 メソッドが `static`ない場合、インスタンス式は `this`ます。 | 
|                   | `T.F(x,y)`     | オーバーロードの解決は、クラスまたは構造体 `T`で `F` 最適なメソッドを選択するために適用されます。 メソッドが `static`ない場合、バインド時エラーが発生します。 `(x,y)`引数リストを使用してメソッドが呼び出されます。 | 
|                   | `e.F(x,y)`     | オーバーロードの解決は、`e`の型によって指定されたクラス、構造体、またはインターフェイスで最適なメソッド F を選択するために適用されます。 メソッドが `static`場合、バインド時エラーが発生します。 インスタンス式 `e` と引数リスト `(x,y)`を使用してメソッドが呼び出されます。 | 
| 「プロパティ アクセス」   | `P`            | 含んでいるクラスまたは構造体のプロパティ `P` の `get` アクセサーが呼び出されます。 `P` が書き込み専用の場合は、コンパイル時にエラーが発生します。 `P` が `static`されていない場合、インスタンス式は `this`ます。 | 
|                   | `P = value`    | 含んでいるクラスまたは構造体のプロパティ `P` の `set` アクセサーは `(value)`引数リストを使用して呼び出されます。 `P` が読み取り専用の場合、コンパイル時エラーが発生します。 `P` が `static`されていない場合、インスタンス式は `this`ます。 | 
|                   | `T.P`          | クラスまたは構造体 `T` で `P` プロパティの `get` アクセサーが呼び出されます。 `P` が `static` されていない場合、または `P` が書き込み専用の場合、コンパイル時エラーが発生します。 | 
|                   | `T.P = value`  | クラスまたは構造体 `T` 内のプロパティ `P` の `set` アクセサーが、`(value)`の引数リストを使用して呼び出されます。 `P` が `static` されていない場合、または `P` が読み取り専用の場合、コンパイル時エラーが発生します。 | 
|                   | `e.P`          | `e` の型によって指定されたクラス、構造体、またはインターフェイス内のプロパティ `P` の `get` アクセサーは、インスタンス式 `e`を使用して呼び出されます。 `P` が `static` 場合、または `P` が書き込み専用の場合、バインド時エラーが発生します。 | 
|                   | `e.P = value`  | `e` の型によって指定されたクラス、構造体、またはインターフェイス内のプロパティ `P` の `set` アクセサーは、インスタンス式 `e` および引数リスト `(value)`を使用して呼び出されます。 `P` が `static` 場合、または `P` が読み取り専用の場合、バインド時エラーが発生します。 | 
| イベントアクセス      | `E += value`   | 含んでいるクラスまたは構造体のイベント `E` の `add` アクセサーが呼び出されます。 `E` が静的でない場合は、インスタンス式が `this`ます。 | 
|                   | `E -= value`   | 含んでいるクラスまたは構造体のイベント `E` の `remove` アクセサーが呼び出されます。 `E` が静的でない場合は、インスタンス式が `this`ます。 | 
|                   | `T.E += value` | クラスまたは構造体 `T` のイベント `E` の `add` アクセサーが呼び出されます。 `E` が静的でない場合は、バインド時エラーが発生します。 | 
|                   | `T.E -= value` | クラスまたは構造体 `T` のイベント `E` の `remove` アクセサーが呼び出されます。 `E` が静的でない場合は、バインド時エラーが発生します。 | 
|                   | `e.E += value` | `e` の型によって指定されたクラス、構造体、またはインターフェイス内のイベント `E` の `add` アクセサーは、インスタンス式 `e`を使用して呼び出されます。 `E` が静的である場合、バインド時エラーが発生します。 | 
|                   | `e.E -= value` | `e` の型によって指定されたクラス、構造体、またはインターフェイス内のイベント `E` の `remove` アクセサーは、インスタンス式 `e`を使用して呼び出されます。 `E` が静的である場合、バインド時エラーが発生します。 | 
| インデクサーへのアクセス    | `e[x,y]`       | オーバーロードの解決は、e の型によって指定されたクラス、構造体、またはインターフェイスで最適なインデクサーを選択するために適用されます。 インデクサーの `get` アクセサーは、インスタンス式 `e` と `(x,y)`引数リストを使用して呼び出されます。 インデクサーが書き込み専用の場合、バインド時エラーが発生します。 | 
|                   | `e[x,y] = value` | オーバーロードの解決は、`e`の型によって指定されたクラス、構造体、またはインターフェイスで最適なインデクサーを選択するために適用されます。 インデクサーの `set` アクセサーは、インスタンス式 `e` と `(x,y,value)`引数リストを使用して呼び出されます。 インデクサーが読み取り専用の場合、バインド時エラーが発生します。 | 
| 演算子の呼び出し | `-x`         | オーバーロードの解決は、`x`の型によって指定されたクラスまたは構造体の中で最適な単項演算子を選択するために適用されます。 選択した演算子が引数リスト `(x)`で呼び出されます。 | 
|                     | `x + y`      | オーバーロードの解決は、`x` と `y`の型によって指定されたクラスまたは構造体の中で最適な二項演算子を選択するために適用されます。 選択した演算子が引数リスト `(x,y)`で呼び出されます。 | 
| インスタンスコンストラクターの呼び出し | `new T(x,y)` | オーバーロードの解決は、クラスまたは構造体 `T`で最適なインスタンスコンストラクターを選択するために適用されます。 `(x,y)`引数リストを使用してインスタンスコンストラクターが呼び出されます。 | 

### <a name="argument-lists"></a>引数リスト

すべての関数メンバーとデリゲートの呼び出しには、関数メンバーのパラメーターの実際の値または変数参照を提供する引数リストが含まれています。 関数メンバー呼び出しの引数リストを指定する構文は、関数メンバーカテゴリによって異なります。

*  インスタンスコンストラクター、メソッド、インデクサー、およびデリゲートでは、次に示すように、引数が*argument_list*として指定されます。 インデクサーの場合、`set` アクセサーを呼び出すときに、引数リストに代入演算子の右オペランドとして指定された式が追加されます。
*  プロパティの場合、引数リストは `get` アクセサーを呼び出すときに空になり、`set` アクセサーを呼び出すときに代入演算子の右オペランドとして指定された式で構成されます。
*  イベントの場合、引数リストは、`+=` または `-=` 演算子の右オペランドとして指定された式で構成されます。
*  ユーザー定義演算子の場合、引数リストは単項演算子の1つのオペランド、または二項演算子の2つのオペランドで構成されます。

プロパティ ([プロパティ](classes.md#properties))、イベント ([イベント](classes.md#events))、およびユーザー定義演算子 ([演算子](classes.md#operators)) の引数は、常に値パラメーター ([値パラメーター](classes.md#value-parameters)) として渡されます。 インデクサー ([インデクサー](classes.md#indexers)) の引数は、常に値パラメーター ([値パラメーター](classes.md#value-parameters)) またはパラメーター配列 ([パラメーター配列](classes.md#parameter-arrays)) として渡されます。 参照パラメーターと出力パラメーターは、これらのカテゴリの関数メンバーではサポートされていません。

インスタンスコンストラクター、メソッド、インデクサー、またはデリゲートの呼び出しの引数は、 *argument_list*として指定されます。

```antlr
argument_list
    : argument (',' argument)*
    ;

argument
    : argument_name? argument_value
    ;

argument_name
    : identifier ':'
    ;

argument_value
    : expression
    | 'ref' variable_reference
    | 'out' variable_reference
    ;
```

*Argument_list*は、コンマで区切られた1つ以上の*引数*で構成されます。 各引数は、省略可能な*argument_name*とそれに続く*argument_value*で構成されます。 *Argument_name*を持つ*引数*は***名前付き引数***と呼ばれますが、 *argument_name*を持たない*引数*は***位置引数***です。 *Argument_list*内の名前付き引数の後に位置引数を指定すると、エラーになります。

*Argument_value*は、次のいずれかの形式を取ることができます。

*  値パラメーター ([値パラメーター](classes.md#value-parameters)) として引数が渡されることを示す*式*。
*  キーワード `ref` 後に*variable_reference* ([変数参照](variables.md#variable-references)) が続き、引数が参照パラメーター ([参照パラメーター](classes.md#reference-parameters)) として渡されることを示します。 参照パラメーターとして渡すには、変数を確実に代入 ([明確な代入](variables.md#definite-assignment)) する必要があります。 キーワード `out` 後に*variable_reference* ([変数参照](variables.md#variable-references)) が続き、引数が出力パラメーター ([出力パラメーター](classes.md#output-parameters)) として渡されることを示します。 変数は、出力パラメーターとして渡される関数メンバー呼び出しの後に、確実に代入 ([明確な代入](variables.md#definite-assignment)) と見なされます。

#### <a name="corresponding-parameters"></a>対応するパラメーター

引数リストの引数ごとに、呼び出される関数メンバーまたはデリゲートに対応するパラメーターが必要です。

次のように使用されるパラメーターリストは、次のように決定されます。

*  クラスで定義された仮想メソッドとインデクサーの場合、パラメーターリストは、受信側の静的な型から開始し、その基本クラスを検索することで、関数メンバーの最も限定的な宣言またはオーバーライドから選択されます。
*  インターフェイスメソッドとインデクサーの場合、パラメーターリストは、インターフェイス型から開始し、基本インターフェイスを検索する、メンバーの最も具体的な定義を選択します。 一意のパラメーターリストが見つからない場合、呼び出しで名前付きパラメーターを使用したり、省略可能な引数を省略したりできないように、アクセスできない名前のパラメーターリストと、省略可能なパラメーターは構築されません。
*  部分メソッドの場合は、部分メソッド宣言を定義するパラメーターリストが使用されます。
*  他のすべての関数メンバーとデリゲートでは、1つのパラメーターリストのみが使用されます。

引数またはパラメーターの位置は、引数リストまたはパラメーターリストの前にある引数またはパラメーターの数として定義されます。

関数メンバー引数の対応するパラメーターは、次のように設定されます。

*  インスタンスコンストラクター、メソッド、インデクサー、およびデリゲートの*argument_list*内の引数:
    * 固定パラメーターがパラメーターリスト内の同じ位置に出現する位置引数は、そのパラメーターに対応します。
    * 通常の形式で呼び出されたパラメーター配列を持つ関数メンバーの位置指定引数は、パラメーターリスト内の同じ位置に出現する必要があるパラメーター配列に対応します。
    * 拡張された形式で呼び出されたパラメーター配列を持つ関数メンバーの位置引数。パラメーターリスト内の同じ位置に固定パラメーターが存在しない場合は、パラメーター配列内の要素に対応します。
    * 名前付き引数は、パラメーターリスト内の同じ名前のパラメーターに対応します。
    * インデクサーの場合、`set` アクセサーを呼び出すときに、代入演算子の右オペランドとして指定された式が、`set` アクセサー宣言の暗黙的な `value` パラメーターに対応します。
*  プロパティの場合、`get` アクセサーを呼び出すときに引数はありません。 `set` アクセサーを呼び出すと、代入演算子の右オペランドとして指定された式が、`set` アクセサー宣言の暗黙的な `value` パラメーターに対応します。
*  ユーザー定義の単項演算子 (変換を含む) の場合、1つのオペランドは演算子宣言の1つのパラメーターに対応します。
*  ユーザー定義の二項演算子の場合、左側のオペランドは最初のパラメーターに対応し、右のオペランドは演算子宣言の2番目のパラメーターに対応します。

#### <a name="run-time-evaluation-of-argument-lists"></a>引数リストの実行時評価

関数メンバー呼び出しの実行時の処理中 ([動的なオーバーロード解決のコンパイル時のチェック](expressions.md#compile-time-checking-of-dynamic-overload-resolution)) では、引数リストの式または変数の参照は、左から右の順に、次のように評価されます。

*  値パラメーターの場合、引数式が評価され、対応するパラメーター型への暗黙的な変換 ([暗黙](conversions.md#implicit-conversions)の変換) が実行されます。 結果の値は、関数メンバー呼び出しの値パラメーターの初期値になります。
*  参照または出力パラメーターの場合、変数参照が評価され、結果として得られるストレージの場所が、関数メンバー呼び出しのパラメーターで表されるストレージの場所になります。 参照または出力パラメーターとして指定された変数参照が*reference_type*の配列要素である場合は、配列の要素の型がパラメーターの型と同じであることを確認するために、ランタイムチェックが実行されます。 このチェックが失敗すると、`System.ArrayTypeMismatchException` がスローされます。

メソッド、インデクサー、およびインスタンスコンストラクターは、右端のパラメーターをパラメーター配列 ([パラメーター](classes.md#parameter-arrays)配列) として宣言できます。 このような関数メンバーは、適用可能な ([適用可能な関数メンバー](expressions.md#applicable-function-member)) に応じて、通常の形式または拡張された形式で呼び出されます。

*  パラメーター配列を持つ関数メンバーが通常の形式で呼び出される場合、パラメーター配列に指定された引数は、暗黙的に変換可能な ([暗黙の変換](conversions.md#implicit-conversions)) 1 つの式である必要があります。 この場合、パラメーター配列は、値パラメーターとまったく同様に動作します。
*  パラメーター配列を持つ関数メンバーが拡張された形式で呼び出される場合、呼び出しではパラメーター配列に0個以上の位置引数を指定する必要があります。各引数は、暗黙的に変換できる式 ([暗黙的な変換](conversions.md#implicit-conversions)) です。) をパラメーター配列の要素型にします。 この場合、呼び出しは、引数の数に対応する長さを持つパラメーター配列型のインスタンスを作成し、指定された引数値を使用して配列インスタンスの要素を初期化し、新しく作成された配列インスタンスを実際のとして使用します。引数.

引数リストの式は、常に記述された順序で評価されます。 この例では、
```csharp
class Test
{
    static void F(int x, int y = -1, int z = -2) {
        System.Console.WriteLine("x = {0}, y = {1}, z = {2}", x, y, z);
    }

    static void Main() {
        int i = 0;
        F(i++, i++, i++);
        F(z: i++, x: i++);
    }
}
```
この例では、次のように出力されます。
```console
x = 0, y = 1, z = 2
x = 4, y = -1, z = 3
```

配列のクロス分散規則 ([配列の共変性](arrays.md#array-covariance)) では、配列型の値を `A[]` 配列型のインスタンスへの参照にすることが許可されています。これは、`B` から `A`への暗黙的な参照変換が存在する場合に `B[]`です。 これらの規則により、 *reference_type*の配列要素が参照パラメーターまたは出力パラメーターとして渡されるときに、配列の実際の要素型がパラメーターの要素の型と同じであることを確認するために、ランタイムチェックが必要になります。 この例では、
```csharp
class Test
{
    static void F(ref object x) {...}

    static void Main() {
        object[] a = new object[10];
        object[] b = new string[10];
        F(ref a[0]);        // Ok
        F(ref b[1]);        // ArrayTypeMismatchException
    }
}
```
`F` の2回目の呼び出しでは、`b` の実際の要素の型が `string` で `object`ではないため、`System.ArrayTypeMismatchException` がスローされます。

パラメーター配列を持つ関数メンバーが拡張された形式で呼び出されると、配列初期化子 (配列[作成式](expressions.md#array-creation-expressions)) を含む配列作成式が展開されたパラメーターの周囲に挿入された場合とまったく同じように、呼び出しが処理されます。 たとえば、次のように宣言したとします。
```csharp
void F(int x, int y, params object[] args);
```
メソッドの拡張形式の次の呼び出し
```csharp
F(10, 20);
F(10, 20, 30, 40);
F(10, 20, 1, "hello", 3.0);
```
はに正確に対応します。
```csharp
F(10, 20, new object[] {});
F(10, 20, new object[] {30, 40});
F(10, 20, new object[] {1, "hello", 3.0});
```

特に、パラメーター配列に引数が指定されていない場合は、空の配列が作成されることに注意してください。

対応する省略可能なパラメーターを使用して関数メンバーから引数を省略すると、関数メンバー宣言の既定の引数が暗黙的に渡されます。 これらは常に定数であるため、他の引数の評価順序には影響しません。

### <a name="type-inference"></a>型の推論

型引数を指定せずにジェネリックメソッドを呼び出すと、***型推論***プロセスは、その呼び出しの型引数を推論しようとします。 型の推定が存在することにより、ジェネリックメソッドを呼び出すためにより便利な構文を使用できるようになり、冗長な型情報の指定を避けることができます。 たとえば、次のようなメソッド宣言があるとします。
```csharp
class Chooser
{
    static Random rand = new Random();

    public static T Choose<T>(T first, T second) {
        return (rand.Next(2) == 0)? first: second;
    }
}
```
型引数を明示的に指定しなくても、`Choose` メソッドを呼び出すことができます。
```csharp
int i = Chooser.Choose(5, 213);                 // Calls Choose<int>

string s = Chooser.Choose("foo", "bar");        // Calls Choose<string>
```

型の推定により、型引数 `int` と `string` は、メソッドの引数から決定されます。

型の推定は、メソッド呼び出し ([メソッド呼び出し](expressions.md#method-invocations)) のバインド時の処理の一部として発生し、呼び出しのオーバーロードの解決手順の前に実行されます。 メソッドの呼び出しで特定のメソッドグループが指定され、メソッドの呼び出しの一部として型引数が指定されていない場合、メソッドグループの各ジェネリックメソッドに型の推定が適用されます。 型の推定が成功した場合は、推論される型引数を使用して、後続のオーバーロードの解決のための引数の型を決定します。 オーバーロードの解決によって、呼び出し元としてジェネリックメソッドが選択された場合、推定される型引数が呼び出しの実際の型引数として使用されます。 特定のメソッドの型の推定が失敗した場合、そのメソッドはオーバーロードの解決に関与しません。 型の推定の失敗は、それ自体のおよびでは、バインディング時エラーは発生しません。 ただし、オーバーロードの解決によって適用可能なメソッドが見つからない場合は、多くの場合、バインド時のエラーが発生します。

指定された引数の数が、メソッドのパラメーターの数と異なる場合、推論はすぐに失敗します。 それ以外の場合は、ジェネリックメソッドに次のシグネチャがあると仮定します。
```csharp
Tr M<X1,...,Xn>(T1 x1, ..., Tm xm)
```

フォームのメソッド呼び出しを使用して `M(E1...Em)` 型の推論のタスクでは、呼び出し `M<S1...Sn>(E1...Em)` が有効になるように、型パラメーター `X1...Xn` ごとに一意の型引数 `S1...Sn` を検索します。

各型パラメーターの推定処理中に、`Xi` は特定の `Si` 型に固定さ*れるか、または*関連付けられた一連の*境界*で*固定*されていません。 各境界は `T`型です。 初期状態では `Xi` それぞれの型変数は、空の境界セットでは修正されません。

型の推定はフェーズで行われます。 各フェーズでは、前のフェーズの結果に基づいて、より多くの型変数の型引数を推論しようとします。 最初のフェーズでは、境界の初期推論を行います。2番目のフェーズでは、型の変数を特定の型に修正し、さらに境界を推測します。 2番目のフェーズは、繰り返しが必要になる場合があります。

*注:* 型の推定は、ジェネリックメソッドが呼び出された場合にのみ行われます。 メソッドグループの変換に対する型の推論については、「[メソッドグループの変換の型の推定](expressions.md#type-inference-for-conversion-of-method-groups)」で説明されています。また、式のセットの最適な共通型の検索については、「[式セットの最適な共通型の検索](expressions.md#finding-the-best-common-type-of-a-set-of-expressions)」で説明されています。

#### <a name="the-first-phase"></a>最初のフェーズ

`Ei`のメソッド引数ごとに、次の手順を実行します。

*   `Ei` が匿名関数の場合は、*明示的なパラメーター型の推論*([明示的なパラメーター型](expressions.md#explicit-parameter-type-inferences)の推論) が `Ei` からに作成され `Ti`
*   それ以外の場合、`Ei` に `U` 型があり、`xi` が値パラメーターである場合は、`U`*から*`Ti`*に* *下限の推論*が行われます。
*   それ以外の場合、`Ei` に `U` 型があり、`xi` が `ref` または `out` のパラメーターである場合、`U`*から*`Ti`*に* *正確な推論*が行われます。
*   それ以外の場合、この引数に対して推論は行われません。


#### <a name="the-second-phase"></a>2番目のフェーズ

2番目のフェーズは、次のように進行します。

*   すべての未修正*の型の*変数は、([依存](expressions.md#dependence)関係)*に依存*しないすべての `Xj` を修正 ([修正](expressions.md#fixing)) `Xi` ます。
*   このような型の変数が存在しない場合は、`Xi` すべての未*修正*の型変数が固定され、次*のすべての*要素が保持されます。
    *   に依存する型変数 `Xj` が少なくとも1つあり `Xi`
    *   `Xi` に空でない境界セットがあります
*   このような型の変数が存在*せず、まだ修正*されていない型の変数がある場合、型の推定は失敗します。
*   それ以外の場合は、それ以上の非修正型変数が存在しない場合 *、型の*推定は成功します。
*   それ以外の場合、*出力の種類*([出力](expressions.md#output-types)型) には固定されていない型の変数*が含まれ*ていますが、*入力*の型 ([入力型](expressions.md#input-types)) には `Xj` の出力*型の推論*([出力](expressions.md#output-type-inferences)型の推論) が `Ei`*から*`Ti`*に*対して行われるので、すべての引数に対応するパラメーターの型 `Ti` `Ei` ます。 次に、2番目のフェーズが繰り返されます。

#### <a name="input-types"></a>入力の種類

`E` がメソッドグループまたは暗黙的に型指定された匿名関数で、`T` がデリゲート型または式ツリー型である場合、`T` のすべてのパラメーターの型は `T`*型*の `E` の*入力型*になります。

####  <a name="output-types"></a>出力型

`E` がメソッドグループまたは匿名関数で、`T` がデリゲート型または式ツリー型である場合、`T` の戻り値の型は `T`*型*の `E`*の出力型*になります。

#### <a name="dependence"></a>依存

固定されていない型変数 `Xi` は、固定されてい*ない型変数* *に直接依存*しています。 `Xj` 型の引数 `Tk` `Ek` では、型 `Xj` の `Ek` の*入力型*`Tk` に発生し、`Xi` 型の `Ek` の*出力型*で発生する場合があります。

`Xj` が `Xi`*に直接依存*している場合、または `Xi` が `Xk`*に直接*依存しており、`Xk` が `Xj`*に*依存している場合、`Xj` は `Xi`*に依存*します。 したがって、"依存関係" は推移的ですが、"直接に依存している" の再帰クロージャではありません。

#### <a name="output-type-inferences"></a>出力の型の推論

*出力型の推論*は、次のように `T` 型*に*`E` 式*から*実行されます。

*  `E` が、推論された戻り値の型 `U` ([推定戻り値の型](expressions.md#inferred-return-type)) の匿名関数で、`T` が戻り値の型が `Tb`であるデリゲート型または式ツリー型である場合は、*下限の推論*([下限](expressions.md#lower-bound-inferences)の推論) が `U`*から*`Tb`*に*作成されます。
*  それ以外の場合、`E` がメソッドグループで、`T` がパラメーター型 `T1...Tk` および戻り値の型 `Tb`を持つデリゲート型または式ツリー型であり、型 `E` のオーバーロード解決では、戻り値の型が *`T1...Tk` の 1*つのメソッドが生成 *され*ます。
*  それ以外の場合、`E` が `U`型の式である場合、`U`*から*`T`*に* *下限の推論*が行われます。
*  それ以外の場合、推論は行われません。

#### <a name="explicit-parameter-type-inferences"></a>明示的なパラメーター型の推論

*明示的なパラメーター型の推論*は、次のように `T` 型*に*`E` 式*から*作成されます。

*  `E` がパラメーターの `U1...Uk` 型を持つ明示的に型指定された匿名関数であり、`T` が `V1...Vk` パラメーターの型を持つデリゲート型または式ツリー型である場合、各 `Ui` に対して*正確な推論*([正確](expressions.md#exact-inferences)な推論) が `Ui`*から*対応する `Vi`*に*行われます。

#### <a name="exact-inferences"></a>正確な推論

`U` 型*から*`V` 型への*厳密な推論*は、次のよう*に*行われます。

*  `V` が固定*されていない `Xi` の*1 つである場合、`U` は `Xi`の完全な境界のセットに追加されます。

*  それ以外の場合は、次のいずれかのケースに該当するかどうかを確認することによって、`V1...Vk` を設定し `U1...Uk` を決定します。

   *  `V` は配列型で `V1[...]` `U` は同じランクの配列型 `U1[...]` です。
   *  `V` は `V1?` 型で、`U` は型です `U1?`
   *  `V` は構築された型 `C<V1...Vk>`で、`U` は構築された型です `C<U1...Uk>`

   これらのいずれかのケースに該当する場合は、各 `Ui`*から*対応する `Vi`*に* *正確な推論*が行われます。

*  それ以外の場合、推論は行われません。

#### <a name="lower-bound-inferences"></a>下限の推論

型 `U` から型 `V` へ*の* *下限の推論*は、次のよう*に*行われます。

*  `V` が未修正の `Xi` の1つである*場合、`U`* は `Xi`の下限のセットに追加されます。
*  それ以外の場合、`V` が `V1?`型で、`U` が `U1?` 型である場合は、`U1` から `V1`に下限の推論が行われます。
*  それ以外の場合は、次のいずれかのケースに該当するかどうかを確認することによって、`U1...Uk` を設定し `V1...Vk` を決定します。
   *  `V` は配列型で `V1[...]` `U` は配列型 `U1[...]` (または、有効な基本型が `U1[...]`である型パラメーター) です。
   *  `V` が `IEnumerable<V1>`、`ICollection<V1>` または `IList<V1>` のいずれかで、`U` が1次元配列型 `U1[]`(または、有効な基本型が `U1[]`である型パラメーター) です。
   *  `V` は、構築され `U` たクラス、構造体、インターフェイス、またはデリゲート型 `C<V1...Vk>` で `C<U1...Uk>` あり、`U` が型パラメーターの場合、その有効な基本クラスまたはその有効なインターフェイスセットのメンバーが (直接または間接的に) (直接または間接的に) (直接または間接的に) `C<U1...Uk>`を実装 (直接または間接的に) する

      ("一意性" の制限とは、`C<T> {} class U: C<X>, C<Y> {}`ケースインターフェイスでは、`U1` を `X` または `Y`することができるため、`U` から `C<T>` に推論するときに推論が行われないことを意味します)。

   これらのいずれかのケースに該当する場合は、次のように各 `Ui`*から*対応する `Vi`*に*推論が行われます。

   *  `Ui` が参照型でないことがわかっている場合は、*正確な推論*が行われます。
   *  それ以外の場合、`U` が配列型である場合は、*下限の推論*が行われます。
   *  それ以外の場合、`V` が `C<V1...Vk>` 場合、推論は `C`の i 番目の型パラメーターに依存します。
      *  共変の場合は、*下限の推論*が行われます。
      *  反変の場合は、*上限の推論*が行われます。
      *  不変である場合は、*正確な推定*が行われます。
*  それ以外の場合、推論は行われません。

#### <a name="upper-bound-inferences"></a>上限の推論

型 `U` から型 `V` へ*の* *上限の推論*は、次のよう*に*行われます。

*  `V` が固定*されていない `Xi` の*1 つである場合、`U` が `Xi`の上限のセットに追加されます。
*  それ以外の場合は、次のいずれかのケースに該当するかどうかを確認することによって、`V1...Vk` を設定し `U1...Uk` を決定します。
   *  `U` は配列型で `U1[...]` `V` は同じランクの配列型 `V1[...]` です。
   *  `U` は `IEnumerable<Ue>`、`ICollection<Ue>` または `IList<Ue>` のいずれかで、`V` は1次元配列型です `Ve[]`
   *  `U` は `U1?` 型で、`V` は型です `V1?`
   *  `U` は、構築されたクラス、構造体、インターフェイス、またはデリゲート型 `C<U1...Uk>` であり、`V` はクラス、構造体、インターフェイス、またはデリゲート型です。これは、(直接または間接的に) を継承するか、または一意の型を (直接または間接的に) 実装します `C<V1...Vk>`

      ("一意性" の制限は、`interface C<T>{} class V<Z>: C<X<Z>>, C<Y<Z>>{}`がある場合に `C<U1>` から `V<Q>`に推論するときに推論が行われないことを意味します。 `U1` から `X<Q>` または `Y<Q>`に推論は行われません)。

   これらのいずれかのケースに該当する場合は、次のように各 `Ui`*から*対応する `Vi`*に*推論が行われます。
   *  `Ui` が参照型でないことがわかっている場合は、*正確な推論*が行われます。
   *  それ以外の場合、`V` が配列型であれば、*上限の推論*が行われます。
   *  それ以外の場合、`U` が `C<U1...Uk>` 場合、推論は `C`の i 番目の型パラメーターに依存します。
      *  共変の場合は、*上限の推論*が行われます。
      *  反変の場合は、*下限の推論*が行われます。
      *  不変である場合は、*正確な推定*が行われます。
*  それ以外の場合、推論は行われません。   

#### <a name="fixing"></a>写真の

一連の境界を持つ固定されてい*ない型変数*`Xi` は、次のように*固定*されています。

*  *候補の種類*のセット `Uj`、`Xi`の一連の境界内のすべての型のセットとして開始されます。
*  次に、それぞれのバインドされている `Xi` を確認します。 `Xi` の完全バインド `U` については、`U` と同じではないすべての型 `Uj` を候補セットから削除します。 `Xi` の下限 `U` ごとに、`U` からの暗黙の変換が*行われていない*すべての型 `Uj` 候補セットから削除されます。 `U` への暗黙的な変換が*行われていない*すべての型 `Uj` `Xi` の上限 `U` は、候補セットから削除されます。
*  他の候補の型の中に、他のすべての候補の型への暗黙の型変換が存在する `Uj` 一意の型 `V` がある場合、`Xi` は `V`に固定されます。
*  それ以外の場合、型の推定は失敗します。

#### <a name="inferred-return-type"></a>推定される戻り値の型

匿名関数 `F` の推定戻り値の型は、型の推定およびオーバーロードの解決の際に使用されます。 推論された戻り値の型は、すべてのパラメーター型が明示的に指定されているか、匿名関数の変換によって指定されるか、または外側のジェネリックの型の推論中に推論されるため、すべてのパラメーター型がわかっている場合にのみ特定できます。メソッドの呼び出し。

推論される***結果の型***は、次のように決定されます。

*  `F` の本体が型を持つ*式*である場合、`F` の推定結果型はその式の型になります。
*  `F` の本体が*ブロック*で、ブロックの `return` ステートメント内の式のセットが最適な共通型 `T` ([一連の式の中で最適な共通型を見つける](expressions.md#finding-the-best-common-type-of-a-set-of-expressions)) の場合、`F` の推定結果型は `T`になります。
*  それ以外の場合、`F`に対して結果の型を推論することはできません。

推論される***戻り値の型***は、次のように決定されます。

*  `F` が async で、`F` の本体が nothing ([式の分類](expressions.md#expression-classifications)) として分類された式、または return ステートメントに式が含まれていないステートメントブロックのいずれかである場合、推論される戻り値の型は `System.Threading.Tasks.Task`
*  `F` が async で、推論された結果型が `T`の場合、推論される戻り値の型は `System.Threading.Tasks.Task<T>`です。
*  `F` が非同期ではなく、推論された結果型 `T`の場合、推論される戻り値の型は `T`です。
*  それ以外の場合、`F`の戻り値の型を推論することはできません。

匿名関数を含む型推論の例として、`System.Linq.Enumerable` クラスで宣言された `Select` 拡張メソッドを考えてみます。
```csharp
namespace System.Linq
{
    public static class Enumerable
    {
        public static IEnumerable<TResult> Select<TSource,TResult>(
            this IEnumerable<TSource> source,
            Func<TSource,TResult> selector)
        {
            foreach (TSource element in source) yield return selector(element);
        }
    }
}
```

`System.Linq` 名前空間が `using` 句を使用してインポートされ、`string`型の `Name` プロパティを持つクラス `Customer` された場合、`Select` メソッドを使用して顧客の一覧の名前を選択できます。
```csharp
List<Customer> customers = GetCustomerList();
IEnumerable<string> names = customers.Select(c => c.Name);
```

`Select` の拡張メソッドの呼び出し ([拡張メソッド](expressions.md#extension-method-invocations)の呼び出し) は、静的メソッドの呼び出しへの呼び出しを書き換えて処理されます。
```csharp
IEnumerable<string> names = Enumerable.Select(customers, c => c.Name);
```

型引数が明示的に指定されていないため、型引数を推論するために型の推定が使用されます。 まず、`customers` 引数は、`Customer`する `T` を推論する `source` パラメーターに関連付けられています。 次に、上記で説明した匿名関数型推論プロセスを使用して、`c` に型 `Customer`を指定し、式 `c.Name` を `selector` パラメーターの戻り値の型に関連付けて、`S` する `string`を推論します。 したがって、呼び出しはと同じです。
```csharp
Sequence.Select<Customer,string>(customers, (Customer c) => c.Name)
```
結果は `IEnumerable<string>`型になります。

次の例では、匿名関数型推論によって、ジェネリックメソッド呼び出しの引数間で型情報を "flow" できるようにする方法を示します。 次のメソッドを指定します。
```csharp
static Z F<X,Y,Z>(X value, Func<X,Y> f1, Func<Y,Z> f2) {
    return f2(f1(value));
}
```

呼び出しの型の推定:
```csharp
double seconds = F("1:15:30", s => TimeSpan.Parse(s), t => t.TotalSeconds);
```
次のように処理を進めます。最初に、引数 `"1:15:30"` が `value` パラメーターに関連付けられ、`string`する `X` を推論します。 次に、最初の匿名関数 `s`のパラメーターに推論される型 `string`を指定します。また、式 `TimeSpan.Parse(s)` は `f1`の戻り値の型に関連付けられ、`Y` する `System.TimeSpan`を推論します。 最後に、2番目の匿名関数 `t`のパラメーターには、推論される型 `System.TimeSpan`が与えられ、式 `t.TotalSeconds` は `f2`の戻り値の型に関連付けられ、`Z` する `double`が推論されます。 したがって、呼び出しの結果は `double`型になります。

#### <a name="type-inference-for-conversion-of-method-groups"></a>メソッドグループの変換の型推論

ジェネリックメソッドの呼び出しと同様に、ジェネリックメソッドを含むメソッドグループ `M` が特定のデリゲート `D` 型に変換される場合 ([メソッドグループ変換](conversions.md#method-group-conversions)) にも、型推論を適用する必要があります。 指定されたメソッド
```csharp
Tr M<X1...Xn>(T1 x1 ... Tm xm)
```
また、メソッドグループ `M` デリゲート型に割り当てられ `D` 型引数を検索して式を `S1...Sn` します。
```csharp
M<S1...Sn>
```
は、`D`と互換性のある ([デリゲート宣言](delegates.md#delegate-declarations)) になります。

Unlike the type inference algorithm for generic method calls, in this case there are only argument *types*, no argument *expressions*. In particular, there are no anonymous functions and hence no need for multiple phases of inference.

Instead, all `Xi` are considered *unfixed*, and a *lower-bound inference* is made *from* each argument type `Uj` of `D` *to* the corresponding parameter type `Tj` of `M`. If for any of the `Xi` no bounds were found, type inference fails. Otherwise, all `Xi` are *fixed* to corresponding `Si`, which are the result of type inference.

#### <a name="finding-the-best-common-type-of-a-set-of-expressions"></a>Finding the best common type of a set of expressions

In some cases, a common type needs to be inferred for a set of expressions. In particular, the element types of implicitly typed arrays and the return types of anonymous functions with *block* bodies are found in this way.

Intuitively, given a set of expressions `E1...Em` this inference should be equivalent to calling a method
```csharp
Tr M<X>(X x1 ... X xm)
```
with the `Ei` as arguments.

More precisely, the inference starts out with an *unfixed* type variable `X`. *Output type inferences* are then made *from* each `Ei` *to* `X`. Finally, `X` is *fixed* and, if successful, the resulting type `S` is the resulting best common type for the expressions. If no such `S` exists, the expressions have no best common type.

### <a name="overload-resolution"></a>オーバーロードの解決

Overload resolution is a binding-time mechanism for selecting the best function member to invoke given an argument list and a set of candidate function members. Overload resolution selects the function member to invoke in the following distinct contexts within C#:

*  Invocation of a method named in an *invocation_expression* ([Method invocations](expressions.md#method-invocations)).
*  Invocation of an instance constructor named in an *object_creation_expression* ([Object creation expressions](expressions.md#object-creation-expressions)).
*  Invocation of an indexer accessor through an *element_access* ([Element access](expressions.md#element-access)).
*  Invocation of a predefined or user-defined operator referenced in an expression ([Unary operator overload resolution](expressions.md#unary-operator-overload-resolution) and [Binary operator overload resolution](expressions.md#binary-operator-overload-resolution)).

Each of these contexts defines the set of candidate function members and the list of arguments in its own unique way, as described in detail in the sections listed above. For example, the set of candidates for a method invocation does not include methods marked `override` ([Member lookup](expressions.md#member-lookup)), and methods in a base class are not candidates if any method in a derived class is applicable ([Method invocations](expressions.md#method-invocations)).

Once the candidate function members and the argument list have been identified, the selection of the best function member is the same in all cases:

*  Given the set of applicable candidate function members, the best function member in that set is located. If the set contains only one function member, then that function member is the best function member. Otherwise, the best function member is the one function member that is better than all other function members with respect to the given argument list, provided that each function member is compared to all other function members using the rules in [Better function member](expressions.md#better-function-member). If there is not exactly one function member that is better than all other function members, then the function member invocation is ambiguous and a binding-time error occurs.

The following sections define the exact meanings of the terms ***applicable function member*** and ***better function member***.

#### <a name="applicable-function-member"></a>Applicable function member

A function member is said to be an ***applicable function member*** with respect to an argument list `A` when all of the following are true:

*  `A` の各引数は、[対応するパラメーター](expressions.md#corresponding-parameters)で説明されているように、関数メンバー宣言内のパラメーターに対応します。引数が対応していないパラメーターは、省略可能なパラメーターです。
*  `A`の引数ごとに、引数のパラメーター渡しモード (つまり、value、`ref`、または `out`) は、対応するパラメーターのパラメーター渡しモードと同じになります。
   *  値パラメーターまたはパラメーター配列の場合、引数から対応するパラメーターの型への暗黙的な変換 ([暗黙](conversions.md#implicit-conversions)の変換) が存在します。
   *  `ref` または `out` パラメーターの場合、引数の型は、対応するパラメーターの型と同じになります。 結局のところ、`ref` または `out` パラメーターは渡された引数のエイリアスです。

パラメーター配列を含む関数メンバーでは、関数メンバーが上記の規則によって適用される場合、その関数メンバーは通常の***形式***で適用されると言われます。 パラメーター配列を含む関数メンバーを通常の形式で適用できない場合は、その関数メンバーが拡張された***形式***で適用される可能性があります。

*  拡張されたフォームを作成するには、関数メンバー宣言内のパラメーター配列をパラメーター配列の要素型の0個以上の値パラメーターに置き換えます。これにより、引数リスト内の引数の数がパラメーターの合計数と一致 `A` ます。 `A` の引数が関数メンバー宣言の固定パラメーター数よりも小さい場合、関数メンバーの拡張形式は構築できないため、適用できません。
*  それ以外の場合、拡張されたフォームは、引数のパラメーター渡しモードが対応するパラメーターのパラメーター渡しモードと同じ `A` の各引数に対して適用できます。
   *  拡張によって作成された固定値パラメーターまたは値パラメーターの場合、引数の型から対応するパラメーターの型への暗黙の変換 ([暗黙](conversions.md#implicit-conversions)の変換) が存在します。
   *  `ref` または `out` パラメーターの場合、引数の型は、対応するパラメーターの型と同じになります。

#### <a name="better-function-member"></a>より優れた関数メンバー

より優れた関数メンバーを決定するために、削除された引数リストは、元の引数リストに出現する順序で引数式だけを含むように構築されます。

各候補関数メンバーのパラメーターリストは、次のように構築されます。

*  拡張されたフォームは、関数メンバーが展開されたフォームでのみ適用された場合に使用されます。
*  対応する引数のない省略可能なパラメーターは、パラメーターリストから削除されます。
*  パラメーターは、引数リスト内の対応する引数と同じ位置に出現するように順序が変わります。

引数のリストに `A` 引数の式 `{E1, E2, ..., En}` と、適用可能な2つの関数メンバー `Mp` `Mq` およびパラメーターの型 `{P1, P2, ..., Pn}` と `{Q1, Q2, ..., Qn}`に対して指定されている場合、`Mp` は `Mq` よりも***適切な関数メンバー***として定義されています。

*  引数ごとに、`Ex` から `Qx` への暗黙的な変換は `Ex` から `Px`への暗黙的な変換よりも適切ではありません。
*  少なくとも1つの引数については、`Ex` から `Px` への変換は `Ex` から `Qx`への変換よりも優れています。

この評価を実行する場合、展開された形式で `Mp` または `Mq` を適用できる場合、`Px` または `Qx` は、拡張された形式のパラメーターリストのパラメーターを参照します。

パラメーターの型のシーケンス `{P1, P2, ..., Pn}` および `{Q1, Q2, ..., Qn}` が等しい場合 (つまり、各 `Pi` に対応する `Qi`への id 変換がある場合)、より適切な関数メンバーを決定するために、次のような相互に関連する規則が順番に適用されます。

*  `Mp` が非ジェネリックメソッドで `Mq` がジェネリックメソッドである場合、`Mp` は `Mq`よりも優れています。
*  それ以外の場合、`Mp` が通常の形式で適用可能で `Mq` `params` 配列を持ち、その拡張フォームにのみ適用できる場合、`Mp` は `Mq`よりも優れています。
*  それ以外の場合、`Mp` が `Mq`よりも宣言されたパラメーターを持つ場合、`Mp` は `Mq`よりも優れています。 これは、両方のメソッドが `params` 配列を持ち、拡張されたフォームにのみ適用できる場合に発生する可能性があります。
*  それ以外の場合、`Mp` のすべてのパラメーターに対応する引数があるのに対し、既定の引数は `Mq` で少なくとも1つの省略可能なパラメーターの代わりに使用する必要があり、`Mp` は `Mq`よりも優れています。
*  それ以外の場合、`Mp` のパラメーターの型が `Mq`よりも多い場合、`Mp` は `Mq`よりも優れています。 `{R1, R2, ..., Rn}` と `{S1, S2, ..., Sn}` は、`Mp` と `Mq`のインスタンスおよび展開されていないパラメーターの種類を表します。 `Mp`のパラメーターの型は、各パラメーターについては `Mq`よりも具体的で、`Rx` が `Sx`よりも限定的ではなく、少なくとも1つのパラメーターについては `Rx` よりも `Sx`よりも具体的です。
   *  型パラメーターが非型パラメーターよりも限定的ではありません。
   *  1つ以上の型引数がより限定的で、型引数がもう一方の型引数よりも限定的でない場合、構築された型は再帰的に (型引数の数が同じである) 別の構築型よりも固有になります。
   *  配列型は、1つ目の要素の型が2番目の要素の型よりも固有である場合、(次元数が同じ) 別の配列型よりも具体的です。
*  それ以外の場合、一方のメンバーがリフトされていない演算子で、もう一方がリフトされた演算子の場合、リフトされていない1つの方が適しています。
*  それ以外の場合は、どちらの関数メンバーも適していません。

#### <a name="better-conversion-from-expression"></a>式からの変換の向上

式の `E` から型 `T1`に変換する暗黙的な `C1` 変換と、式の `E` を型 `T2`に変換する暗黙的な変換 `C2` を指定した場合、`C1` が `C2` と完全に一致せず、次の少なくとも1つのが保持されていると、`E` よりも***変換が適切***になります。

* `E` `T1` (正確に[一致する式](expressions.md#exactly-matching-expression)) と完全に一致します。
* `T1` は `T2` よりも適切な変換ターゲットです ([変換ターゲットの方が適し](expressions.md#better-conversion-target)ています)。

#### <a name="exactly-matching-expression"></a>正確に一致する式

式 `E` と型 `T`が指定されている場合、次のいずれかの条件を満たしている場合は `T` に正確に一致 `E` ます。

*  `E` には `S`型があり、`S` からに id 変換が存在し `T`
*  `E` は匿名関数 `T` であり、デリゲート型 `D` または式ツリー型 `Expression<D>` で、次のいずれかが保持されます。
   *  `D` ([推定戻り値の型](expressions.md#inferred-return-type)) のパラメーターリストのコンテキストで `E` に対して推論された戻り値の型 `X` 存在します。また、`X` からの戻り値の型への id 変換が存在し `D`
   *  `E` が非同期ではなく、`D` の戻り値の型が `Y` または `E` が async で、`D` の戻り値の型が `Task<Y>`である場合、次のいずれかが保持されます。
      * `E` の本体は、正確に一致する式です `Y`
      * `E` の本体は、すべての return ステートメントが正確に一致する式を返すステートメントブロックです `Y`

#### <a name="better-conversion-target"></a>変換ターゲットの向上

`T1` と `T2`の2つの異なる型を指定した場合、`T2` から `T1` への暗黙的な変換が存在せず、少なくとも次のいずれかが保持されている場合、`T1` は `T2` よりも変換ターゲットとして適しています。

*  `T1` から `T2` への暗黙的な変換
*  `T1` はデリゲート型 `D1` または式ツリー型 `Expression<D1>`のいずれかで、`T2` はデリゲート型 `D2` または式ツリー型 `Expression<D2>`、`D1` には戻り値の型 `S1`、次のいずれかが含まれます。
   * `D2` は void を返します。
   * `D2` に `S2`戻り値の型があり、`S1` がより適切な変換ターゲットです `S2`
*  `T1` は `Task<S1>`、`T2` は `Task<S2>`、`S1` はより優れた変換ターゲットです `S2`
*  `T1` は、`S1` が符号付き整数型であり、`T2` が符号なし整数型である `S2` または `S2?` である場合に `S1` または `S1?` ます。 具体的には、次のように使用します。
   * `S1` は `sbyte` で、`S2` は `byte`、`ushort`、`uint`、または `ulong`
   * `S1` は `short` で、`S2` は `ushort`、`uint`、または `ulong`
   * `S1` は `int` で `S2` は `uint`、または `ulong`
   * `S1` は `long` で `S2` は `ulong`

#### <a name="overloading-in-generic-classes"></a>オーバーロード (ジェネリッククラスでの)

宣言されたシグネチャは一意である必要がありますが、型引数の代入によって同じシグネチャが生成される可能性があります。 このような場合、上記のオーバーロードの解決規則によって、最も限定的なメンバーが選択されます。

次の例は、この規則に従って有効で無効なオーバーロードを示しています。

```csharp
interface I1<T> {...}

interface I2<T> {...}

class G1<U>
{
    int F1(U u);                  // Overload resolution for G<int>.F1
    int F1(int i);                // will pick non-generic

    void F2(I1<U> a);             // Valid overload
    void F2(I2<U> a);
}

class G2<U,V>
{
    void F3(U u, V v);            // Valid, but overload resolution for
    void F3(V v, U u);            // G2<int,int>.F3 will fail

    void F4(U u, I1<V> v);        // Valid, but overload resolution for    
    void F4(I1<V> v, U u);        // G2<I1<int>,int>.F4 will fail

    void F5(U u1, I1<V> v2);      // Valid overload
    void F5(V v1, U u2);

    void F6(ref U u);             // valid overload
    void F6(out V v);
}
```

### <a name="compile-time-checking-of-dynamic-overload-resolution"></a>動的なオーバーロードの解決のコンパイル時チェック

動的にバインドされたほとんどの操作では、コンパイル時に解決できる候補のセットは不明です。 ただし、場合によっては、候補セットはコンパイル時に認識されます。

*  動的引数を使用した静的メソッド呼び出し
*  受信側が動的な式でないインスタンスメソッド呼び出し
*  受信側が動的な式ではないインデクサー呼び出し
*  動的引数を使用したコンストラクター呼び出し

このような場合、実行時に適用される可能性があるかどうかを確認するために、各候補に対して限定的なコンパイル時チェックが実行されます。この確認は、次の手順で構成されています。

*  部分型推論: `dynamic` 型の引数に直接または間接的に依存していない型引数は、[型推論](expressions.md#type-inference)の規則を使用して推論されます。 その他の型引数は不明です。
*  部分適用性の確認: 適用性は、[適用可能な関数メンバー](expressions.md#applicable-function-member)に従ってチェックされますが、型が不明のパラメーターは無視されます。
*  このテストに合格しなかった場合は、コンパイル時エラーが発生します。

### <a name="function-member-invocation"></a>関数メンバーの呼び出し

ここでは、特定の関数メンバーを呼び出すために実行時に実行されるプロセスについて説明します。 バインド時のプロセスでは、呼び出される特定のメンバーが既に決定されていることを前提としています。これは、候補となる関数メンバーのセットにオーバーロードの解決を適用することによって行われる可能性があります。

呼び出しプロセスを記述する目的で、関数メンバーは次の2つのカテゴリに分類されます。

*  静的関数のメンバー。 これらは、インスタンスコンストラクター、静的メソッド、静的プロパティアクセサー、およびユーザー定義の演算子です。 静的関数メンバーは常に非仮想です。
*  インスタンス関数のメンバー。 これらは、インスタンスメソッド、インスタンスプロパティアクセサー、およびインデクサーアクセサーです。 インスタンス関数メンバーは、仮想でも仮想でもなく、常に特定のインスタンスで呼び出されます。 インスタンスはインスタンス式によって計算され、`this` ([このアクセス](expressions.md#this-access)) として関数メンバー内でアクセスできるようになります。

関数メンバー呼び出しの実行時の処理は、次の手順で構成されます。ここで `M` は関数メンバーで、`M` がインスタンスメンバーである場合は `E` インスタンス式です。

*  `M` が静的関数メンバーである場合は、次のようになります。
   * 引数リストは、「[引数リスト](expressions.md#argument-lists)」で説明されているように評価されます。
   * `M` が呼び出されます。

*  `M` が*value_type*で宣言されたインスタンス関数メンバーの場合は、次のようになります。
   * `E` が評価されます。 この評価によって例外が発生した場合、それ以上の手順は実行されません。
   * `E` が変数として分類されていない場合は、`E`の型の一時的なローカル変数が作成され、`E` の値がその変数に代入されます。 その後、`E` は、その一時的なローカル変数への参照として再分類されます。 一時変数は、`M`内の `this` としてアクセスできますが、他の方法ではアクセスできません。 したがって、`E` が真の変数である場合にのみ、呼び出し元は `this`する `M` の変更を観察できます。
   * 引数リストは、「[引数リスト](expressions.md#argument-lists)」で説明されているように評価されます。
   * `M` が呼び出されます。 `E` によって参照される変数は、`this`によって参照される変数になります。

*  `M` が*reference_type*で宣言されたインスタンス関数メンバーの場合は、次のようになります。
   * `E` が評価されます。 この評価によって例外が発生した場合、それ以上の手順は実行されません。
   * 引数リストは、「[引数リスト](expressions.md#argument-lists)」で説明されているように評価されます。
   * `E` の型が*value_type*である場合、`E` を型 `object`に変換するためのボックス変換 ([ボックス](types.md#boxing-conversions)化変換) が実行され、`E` は次の手順では `object` 型と見なされます。 この場合、`M` は `System.Object`のメンバーである必要があります。
   * `E` の値が有効であるかどうかがチェックされます。 `E` の値が `null`場合は `System.NullReferenceException` がスローされ、それ以上の手順は実行されません。
   * 呼び出す関数メンバーの実装は、次のように決定されます。
     * `E` のバインド時の型がインターフェイスの場合、呼び出す関数メンバーは `E`によって参照されるインスタンスの実行時の型によって提供される `M` の実装です。 この関数メンバーは、`E`によって参照されるインスタンスのランタイム型によって提供される `M` の実装を決定するために、インターフェイスマッピング規則 ([インターフェイスマッピング](interfaces.md#interface-mapping)) を適用することによって決定されます。
     * それ以外の場合、`M` が仮想関数メンバーである場合、呼び出す関数メンバーは `E`によって参照されるインスタンスの実行時の型によって提供される `M` の実装です。 この関数メンバーは、`E`によって参照されるインスタンスの実行時の型に対して、`M` の最も派生する実装 ([仮想メソッド](classes.md#virtual-methods)) を決定するための規則を適用することによって決定されます。
     * それ以外の場合、`M` は非仮想関数メンバーであり、呼び出す関数メンバーは `M` ます。
   * 上記の手順で決定した関数メンバーの実装が呼び出されます。 `E` によって参照されるオブジェクトは、`this`によって参照されるオブジェクトになります。

#### <a name="invocations-on-boxed-instances"></a>ボックス化されたインスタンスでの呼び出し

*Value_type*に実装されている関数メンバーは、次のような場合に*value_type*のボックス化されたインスタンスを使用して呼び出すことができます。

*  関数メンバーが `object` 型から継承されたメソッドの `override` であり、`object`型のインスタンス式を通じて呼び出される場合。
*  関数メンバーがインターフェイス関数メンバーの実装であり、 *interface_type*のインスタンス式を通じて呼び出される場合。
*  デリゲートを通じて関数メンバーが呼び出されたとき。

このような場合、ボックス化されたインスタンスには*value_type*の変数が含まれていると見なされ、この変数は関数メンバー呼び出し内で `this` によって参照される変数になります。 これは特に、ボックス化されたインスタンスで関数メンバーが呼び出されたときに、関数メンバーがボックス化されたインスタンスに含まれる値を変更できることを意味します。

## <a name="primary-expressions"></a>一次式

主な式には、最も単純な形式の式が含まれます。

```antlr
primary_expression
    : primary_no_array_creation_expression
    | array_creation_expression
    ;

primary_no_array_creation_expression
    : literal
    | interpolated_string_expression
    | simple_name
    | parenthesized_expression
    | member_access
    | invocation_expression
    | element_access
    | this_access
    | base_access
    | post_increment_expression
    | post_decrement_expression
    | object_creation_expression
    | delegate_creation_expression
    | anonymous_object_creation_expression
    | typeof_expression
    | checked_expression
    | unchecked_expression
    | default_value_expression
    | nameof_expression
    | anonymous_method_expression
    | primary_no_array_creation_expression_unsafe
    ;
```

プライマリ式は*array_creation_expression*s と*primary_no_array_creation_expression*の間で分けられます。 この方法で配列作成式を扱うことは、他の単純な式フォームと共にリストするのではなく、文法によって、次のような混乱の可能性のあるコードを許可しないようにします。
```csharp
object o = new int[3][1];
```
これは、
```csharp
object o = (new int[3])[1];
```

### <a name="literals"></a>リテラル

*リテラル*([リテラル](lexical-structure.md#literals)) で構成される*primary_expression*は、値として分類されます。


### <a name="interpolated-strings"></a>挿入文字列

*Interpolated_string_expression*は、`$` の符号とそれに続く通常のリテラルまたは逐語的な文字列リテラルで構成され、`{` と `}`によって区切られ、式と書式指定の仕様を囲みます。 補間文字列式は、「[補間文字列リテラル](lexical-structure.md#interpolated-string-literals)」で説明されているように、個々のトークンに分割された*interpolated_string_literal*の結果です。

```antlr
interpolated_string_expression
    : '$' interpolated_regular_string
    | '$' interpolated_verbatim_string
    ;

interpolated_regular_string
    : interpolated_regular_string_whole
    | interpolated_regular_string_start interpolated_regular_string_body interpolated_regular_string_end
    ;

interpolated_regular_string_body
    : interpolation (interpolated_regular_string_mid interpolation)*
    ;

interpolation
    : expression
    | expression ',' constant_expression
    ;

interpolated_verbatim_string
    : interpolated_verbatim_string_whole
    | interpolated_verbatim_string_start interpolated_verbatim_string_body interpolated_verbatim_string_end
    ;

interpolated_verbatim_string_body
    : interpolation (interpolated_verbatim_string_mid interpolation)+
    ;
```

補間内の*constant_expression*には、`int`への暗黙的な変換が必要です。

*Interpolated_string_expression*は値として分類されます。 `System.IFormattable` に直ちに変換される場合、または暗黙的な挿入文字列変換 (暗黙的な補[間](conversions.md#implicit-interpolated-string-conversions)文字列変換) を使用して `System.FormattableString` 場合、挿入文字列式の型はです。 それ以外の場合は `string`型になります。

挿入文字列の型が `System.IFormattable` または `System.FormattableString`の場合、意味は `System.Runtime.CompilerServices.FormattableStringFactory.Create`を呼び出すことになります。 型が `string`の場合、式の意味は `string.Format`の呼び出しになります。 どちらの場合も、呼び出しの引数リストは、各補間のプレースホルダーを含む書式指定文字列リテラルと、プレースホルダーに対応する各式の引数で構成されます。

書式指定文字列リテラルは次のように構成されます。ここで `N` は*interpolated_string_expression*内の補間の数です。

*  *Interpolated_regular_string_whole*または*interpolated_verbatim_string_whole*が `$` 記号の後に続く場合、書式文字列リテラルはそのトークンです。
*  それ以外の場合、書式指定文字列リテラルは次の要素で構成されます。 
   *  最初の*interpolated_regular_string_start*または*interpolated_verbatim_string_start*
   *  次に、`0` から `N-1`に `I` 数値ごとに、次のように入力します。 
      * `I` の10進数表現
      * 次に、対応する*補間*に*constant_expression*がある場合、`,` (コンマ) の後に*constant_expression*の値の10進数表現が続きます。
      * 次に、対応する補間の直後に*interpolated_regular_string_mid*、 *interpolated_regular_string_end*、 *interpolated_verbatim_string_mid* 、または*interpolated_verbatim_string_end*ます。

後続の引数は、単に*補間*(存在する場合) からの*式*です。

TODO: 例。


### <a name="simple-names"></a>簡易名

*Simple_name*は識別子で構成され、その後に型引数リストが続きます。

```antlr
simple_name
    : identifier type_argument_list?
    ;
```

*Simple_name*は、フォーム `I` またはフォーム `I<A1,...,Ak>`のいずれかです。ここで `I` は単一の識別子で、`<A1,...,Ak>` は省略可能な*type_argument_list*です。 *Type_argument_list*が指定されていない場合は、`K` を0にすることを検討してください。 *Simple_name*が評価され、次のように分類されます。

*  `K` がゼロで*simple_name*が*ブロック*内に存在し、*ブロック*の (またはそれを囲む*ブロック*の) ローカル変数宣言領域 ([宣言](basic-concepts.md#declarations)) に、 `I`という名前のローカル変数、パラメーター、または定数が含まれている場合、 *simple_name*はそのローカル変数、パラメーター、または定数を参照し、変数または値として分類されます。
*  `K` がゼロで、 *simple_name*がジェネリックメソッド宣言の本体内に存在し、その宣言に `I`という名前の型パラメーターが含まれている場合、 *simple_name*はその型パラメーターを参照します。
*  それ以外の場合は、インスタンス型 `T` ([インスタンス型](classes.md#the-instance-type)) に対して、すぐ外側の型宣言のインスタンス型から開始し、外側の各クラスまたは構造体宣言のインスタンス型 (存在する場合) を続行します。
   *  `K` がゼロで、`T` の宣言に `I`という名前の型パラメーターが含まれている場合、 *simple_name*はその型パラメーターを参照します。
   *  それ以外の場合、`K` 型引数を使用して `T` 内の `I` のメンバー参照 ([メンバー参照](expressions.md#member-lookup)) が一致すると、次のようになります。
      * `T` がすぐ外側のクラスまたは構造体型のインスタンス型であり、参照が1つ以上のメソッドを識別する場合、結果は `this`のインスタンス式が関連付けられたメソッドグループになります。 型引数リストが指定されている場合は、ジェネリックメソッド ([メソッド呼び出し](expressions.md#method-invocations)) の呼び出しで使用されます。
      * それ以外の場合、`T` が、すぐに外側のクラスまたは構造体型のインスタンス型である場合、参照がインスタンスメンバーを識別し、インスタンスコンストラクター、インスタンスメソッド、またはインスタンスアクセサーの本体内で参照が発生した場合、結果は `this.I`フォームのメンバーアクセス ([メンバー](expressions.md#member-access)アクセス) と同じになります。 これは、`K` が0の場合にのみ発生します。
      * それ以外の場合、結果は `T.I` または `T.I<A1,...,Ak>`フォームのメンバーアクセス ([メンバーアクセス](expressions.md#member-access)) と同じになります。 この場合、 *simple_name*がインスタンスメンバーを参照するためのバインド時エラーです。

*  それ以外の場合は、名前空間 `N`ごとに、 *simple_name*が発生する名前空間から開始し、外側の各名前空間 (存在する場合) を続行し、グローバル名前空間で終わると、エンティティが見つかるまで次の手順が評価されます。
   *  `K` がゼロで、`I` が `N`内の名前空間の名前である場合は、次のようになります。
      * *Simple_name*が発生した場所が `N` の名前空間宣言によって囲まれていて、名前空間に名前空間または型が関連付けられている*extern_alias_directive*または*using_alias_directive*が名前空間宣言に含まれている場合、 * `I`* はあいまいで、コンパイル時エラーが発生します。
      * それ以外の場合、 *simple_name*は `N`内の `I` という名前空間を参照します。
   *  それ以外の場合、`N` に名前 `I` と `K` 型パラメーターを持つアクセス可能な型が含まれている場合は、次のようになります。
      * `K` がゼロで、 *simple_name*が発生した場所が `N` の名前空間宣言によって囲まれており、名前空間を名前空間または型に関連付ける*extern_alias_directive*または*using_alias_directive*が名前空間宣言に含まれている場合、 * `I`* はあいまいで、コンパイル時エラーが発生します。
      * それ以外の場合、 *namespace_or_type_name*は、指定された型引数を使用して構築された型を参照します。
   *  それ以外の場合、 *simple_name*が発生した場所が `N`の名前空間宣言によって囲まれている場合は、次のようになります。
      * `K` がゼロで、名前空間の宣言に、名前 `I` をインポートした名前空間または型に関連付ける*extern_alias_directive*または*using_alias_directive*が含まれている場合、 *simple_name*はその名前空間または型を参照します。
      * それ以外の場合、 *using_namespace_directive*s および名前空間宣言の*using_static_directive*によってインポートされた名前空間と型の宣言に、アクセス可能な型または非拡張静的メンバーが1つだけ含まれており、その名前が `I` で、型 * * パラメーターが `K`場合は、指定された型引数を使用して構築されたその型またはメンバーを
      * それ以外の場合、名前空間宣言の*using_namespace_directive*s によってインポートされた名前空間と型に複数のアクセス可能な型または非拡張メソッドの静的メンバーが含まれていて、名前が `I` で、型パラメーターが  `K`場合、 *simple_name*はあいまいで、エラーが発生します。

   この手順全体は、 *namespace_or_type_name* ([名前空間と型名](basic-concepts.md#namespace-and-type-names)) を処理するための対応する手順と完全に並列であることに注意してください。

*  それ以外の場合、 *simple_name*は定義されていないため、コンパイル時エラーが発生します。


### <a name="parenthesized-expressions"></a>かっこで囲まれる式

*Parenthesized_expression*は、かっこで囲まれた*式*で構成されます。

```antlr
parenthesized_expression
    : '(' expression ')'
    ;
```

*Parenthesized_expression*は、かっこ内の*式*を評価することによって評価されます。 かっこ内の*式*が名前空間または型を表している場合は、コンパイル時エラーが発生します。 それ以外の場合、 *parenthesized_expression*の結果は、含まれている*式*を評価した結果になります。

### <a name="member-access"></a>メンバー アクセス。

*Member_access*は、 *primary_expression*、 *predefined_type*、または*qualified_alias_member*で構成され、その後に "`.`" トークン、*識別子*、および必要に応じて、後に*type_argument_list*が続きます。

```antlr
member_access
    : primary_expression '.' identifier type_argument_list?
    | predefined_type '.' identifier type_argument_list?
    | qualified_alias_member '.' identifier
    ;

predefined_type
    : 'bool'   | 'byte'  | 'char'  | 'decimal' | 'double' | 'float' | 'int' | 'long'
    | 'object' | 'sbyte' | 'short' | 'string'  | 'uint'   | 'ulong' | 'ushort'
    ;
```

*Qualified_alias_member*運用環境は、[名前空間エイリアス修飾子](namespaces.md#namespace-alias-qualifiers)で定義されています。

*Member_access*は、フォーム `E.I` またはフォーム `E.I<A1, ..., Ak>`のいずれかです。ここで `E` はプライマリ式であり、`I` は単一の識別子で、`<A1, ..., Ak>` は省略可能な*type_argument_list*です。 *Type_argument_list*が指定されていない場合は、`K` を0にすることを検討してください。

`dynamic` 型の*primary_expression*を持つ*member_access*が動的にバインドされます ([動的バインド](expressions.md#dynamic-binding))。 この場合、コンパイラはメンバーアクセスを `dynamic`型のプロパティアクセスとして分類します。 次の規則は、 *member_access*の意味を判断するために、 *primary_expression*のコンパイル時の型ではなく、実行時の型を使用して実行時に適用されます。 この実行時の分類によってメソッドグループが発生する場合は、メンバーアクセスが*invocation_expression*の*primary_expression*である必要があります。

*Member_access*が評価され、次のように分類されます。

*  `K` がゼロで `E` が名前空間で、`E` に名前が `I`で入れ子になった名前空間が含まれている場合、結果はその名前空間になります。
*  それ以外の場合、`E` が名前空間で、`E` に名前 `I` および  `K`型パラメーターを持つアクセス可能な型が含まれている場合、結果は指定された型引数を使用して構築された型になります。
*  `E` が型として分類された*predefined_type*または*primary_expression*の場合、`E` が型パラメーターではなく、`I` の `E` のメンバー参照 ([メンバー参照](expressions.md#member-lookup)) が `K` 型パラメーターで一致すると、`E.I` が評価され、次のように分類されます。
   *  `I` が型を識別する場合、結果は指定された型引数を使用して構築された型になります。
   *  `I` が1つ以上のメソッドを識別する場合、結果はインスタンス式が関連付けられていないメソッドグループになります。 型引数リストが指定されている場合は、ジェネリックメソッド ([メソッド呼び出し](expressions.md#method-invocations)) の呼び出しで使用されます。
   *  `I` が `static` プロパティを識別する場合、結果は、インスタンス式が関連付けられていないプロパティアクセスになります。
   *  `I` が `static` フィールドを識別する場合は、次のようになります。
      * フィールドが `readonly`、フィールドが宣言されているクラスまたは構造体の静的コンストラクターの外側で参照が発生した場合、結果は値になります。つまり、 `E`の静的フィールド `I` の値です。
      * それ以外の場合、結果は変数になります。つまり、 `E`の静的フィールド `I` です。
   *  `I` が `static` イベントを識別する場合:
      * イベントが宣言されているクラスまたは構造体内で参照が発生し、イベントが*event_accessor_declarations* ([イベント](classes.md#events)) を使用せずに宣言されている場合、`E.I` は `I` が静的フィールドであった場合とまったく同じように処理されます。
      * それ以外の場合、結果はインスタンス式が関連付けられていないイベントアクセスになります。
   *  `I` が定数を識別する場合、結果は値、つまりその定数の値になります。
    * `I` が列挙型のメンバーを識別する場合、結果はその列挙体のメンバーの値、つまり値になります。
    * それ以外の場合、`E.I` は無効なメンバー参照であり、コンパイル時エラーが発生します。
*  `E` がプロパティアクセス、インデクサーアクセス、変数、または値であり、その型が `T`である場合、および `K` 型引数を持つ `T` 内の `I` のメンバー参照 ([メンバー参照](expressions.md#member-lookup)) によって一致が生成されると、`E.I` が評価され、次のように分類されます。
   *  最初に、`E` がプロパティまたはインデクサーアクセスである場合は、プロパティまたはインデクサーアクセスの値 ([式の値](expressions.md#values-of-expressions)) を取得し、`E` を値として再分類します。
   *  `I` が1つ以上のメソッドを識別する場合、結果は `E`のインスタンス式が関連付けられたメソッドグループになります。 型引数リストが指定されている場合は、ジェネリックメソッド ([メソッド呼び出し](expressions.md#method-invocations)) の呼び出しで使用されます。
   *  `I` インスタンスのプロパティを識別する場合は、
      * `E` が `this`場合、`I` は自動的に実装されるプロパティ ([自動的に実装](classes.md#automatically-implemented-properties)されるプロパティ) を setter を指定せずに識別します。参照は、クラスまたは構造体の `T`型のインスタンスコンストラクター内で行われます。その後、結果は変数になります。つまり、`I` によって指定された `T` によって指定された自動
      * それ以外の場合、結果は、 `E`のインスタンス式が関連付けられたプロパティアクセスになります。
   *  `T` が*class_type*で、`I` *class_type*のインスタンスフィールドを識別する場合は、次のようになります。
      * `E` の値が `null`場合は、`System.NullReferenceException` がスローされます。
      * それ以外の場合、フィールドが `readonly`、参照がフィールドが宣言されているクラスのインスタンスコンストラクターの外部で発生した場合、結果は値になります。つまり、 `E`によって参照されるオブジェクト内のフィールド `I` の値です。
      * それ以外の場合、結果は変数、つまり `E`によって参照されるオブジェクト内のフィールド `I` になります。
   *  `T` が*struct_type*で、`I` *struct_type*のインスタンスフィールドを識別する場合は、次のようになります。
      * `E` が値の場合、またはフィールドが `readonly` で、そのフィールドが宣言されている構造体のインスタンスコンストラクターの外側で参照が発生した場合、結果は値になります。つまり、 `E`によって指定された構造体のインスタンスコンストラクター内のフィールド `I` の値になります。
      * それ以外の場合、結果は変数、つまり `E`によって指定された構造体インスタンス内のフィールド `I` になります。
   *  `I` がインスタンスイベントを識別する場合は、次のようになります。
      * イベントが宣言されているクラスまたは構造体内で参照が発生し、イベントが*event_accessor_declarations* ([イベント](classes.md#events)) なしで宣言されており、参照が `+=` または `-=` 演算子の左側として発生していない場合、`E.I` は `I` がインスタンスフィールドである場合とまったく同じように処理されます。
      * それ以外の場合、結果は、 `E`のインスタンス式が関連付けられたイベントアクセスになります。
*  それ以外の場合、拡張メソッドの呼び出し ([拡張メソッドの呼び出し](expressions.md#extension-method-invocations)) として `E.I` を処理しようとしました。 これが失敗した場合、`E.I` は無効なメンバー参照であり、バインド時エラーが発生します。

#### <a name="identical-simple-names-and-type-names"></a>同じ簡易名と型名

`E.I`フォームのメンバーアクセスでは、`E` が単一の識別子であり、 *simple_name* ([簡易名](expressions.md#simple-names)) としての `E` の意味が、`E` ([名前空間と型名](basic-concepts.md#namespace-and-type-names)) とし*て type_name の*意味と同じ型を持つ定数、フィールド、プロパティ、ローカル変数、またはパラメーターである場合、`E` の両方の意味を持つことができます。 `I` は常に `E` 型のメンバーである必要があるため、`E.I` の2つの意味があいまいになることはありません。 つまり、この規則は、コンパイル時エラーが発生した `E` の静的メンバーおよび入れ子にされた型へのアクセスを許可するだけです。 例:
```csharp
struct Color
{
    public static readonly Color White = new Color(...);
    public static readonly Color Black = new Color(...);

    public Color Complement() {...}
}

class A
{
    public Color Color;                // Field Color of type Color

    void F() {
        Color = Color.Black;           // References Color.Black static member
        Color = Color.Complement();    // Invokes Complement() on Color field
    }

    static void G() {
        Color c = Color.White;         // References Color.White static member
    }
}
```

#### <a name="grammar-ambiguities"></a>文法のあいまい性

*Simple_name* ([簡易名](expressions.md#simple-names)) と*member_access* ([メンバーアクセス](expressions.md#member-access)) の生産によって、式の文法があいまいになる可能性があります。 たとえば、ステートメントは次のようになります。
```csharp
F(G<A,B>(7));
```
は、`G < A` と `B > (7)`の2つの引数を持つ `F` の呼び出しとして解釈される可能性があります。 または、1つの引数を持つ `F` の呼び出しとして解釈することもできます。これは、2つの型引数と1つの標準引数を持つジェネリックメソッド `G` の呼び出しです。

トークンのシーケンスを*simple_name* ([簡易名](expressions.md#simple-names))、 *member_access* ([メンバーアクセス](expressions.md#member-access))、または*pointer_member_access* ([ポインターメンバーアクセス](unsafe-code.md#pointer-member-access)) で*type_argument_list*終わり ([型引数](types.md#type-arguments)) として解析できる場合、終了 `>` トークンの直後にあるトークンが検査されます。 のいずれかである場合
```csharp
(  )  ]  }  :  ;  ,  .  ?  ==  !=  |  ^
```
その後、 *type_argument_list*は*simple_name*、 *member_access*または*pointer_member_access*の一部として保持され、その他のトークンシーケンスの解析はすべて破棄されます。 それ以外の場合、トークンのシーケンスを解析できない場合でも、 *type_argument_list*は*simple_name*、 *member_access* 、または*pointer_member_access*の一部とは見なされません。 これらの規則は、 *namespace_or_type_name* ([名前空間と型名](basic-concepts.md#namespace-and-type-names)) の*type_argument_list*を解析するときには適用されないことに注意してください。 次のステートメント、
```csharp
F(G<A,B>(7));
```
は、この規則に従って、1つの引数を持つ `F` の呼び出しとして解釈されます。これは、2つの型引数と1つの標準引数を持つジェネリックメソッド `G` の呼び出しです。 ステートメント
```csharp
F(G < A, B > 7);
F(G < A, B >> 7);
```
は、2つの引数を持つ `F` の呼び出しとして解釈されます。 次のステートメント、
```csharp
x = F < A > +y;
```
は、 *type_argument_list*の後に二項プラス演算子が続く*simple_name*としてではなく `x = (F < A) > (+y)`に記述されているかのように、小なり演算子、大なり演算子、および単項プラス演算子として解釈されます。 ステートメント内
```csharp
x = y is C<T> + z;
```
`C<T>` トークンは、 *type_argument_list*の*namespace_or_type_name*として解釈されます。

### <a name="invocation-expressions"></a>Invocation 式

*Invocation_expression*は、メソッドを呼び出すために使用されます。

```antlr
invocation_expression
    : primary_expression '(' argument_list? ')'
    ;
```

次のいずれかに当てはまる場合、 *invocation_expression*は動的にバインドされます ([動的バインド](expressions.md#dynamic-binding))。

* *Primary_expression*には、コンパイル時の型 `dynamic`があります。
* オプションの*argument_list*の少なくとも1つの引数にコンパイル時の型 `dynamic` があり、 *primary_expression*にデリゲート型がありません。

この場合、コンパイラは*invocation_expression*を型 `dynamic`の値として分類します。 次の規則は、 *invocation_expression*の意味を判断するために、実行時に実行時に適用されます。これには、コンパイル時の型 `dynamic`を持つ*primary_expression*および引数のコンパイル時の型ではなく、実行時の型が使用されます。 *Primary_expression*にコンパイル時の型 `dynamic`がない場合、「[動的なオーバーロードの解決のコンパイル時のチェック](expressions.md#compile-time-checking-of-dynamic-overload-resolution)」で説明されているように、メソッドの呼び出しでコンパイル時間が制限されます。

*Invocation_expression*の*primary_expression*は、メソッドグループまたは*delegate_type*の値である必要があります。 *Primary_expression*がメソッドグループの場合、 *invocation_expression*はメソッド呼び出し ([メソッド](expressions.md#method-invocations)呼び出し) です。 *Primary_expression*が*delegate_type*の値の場合、 *Invocation_expression*はデリゲート呼び出し ([デリゲート](expressions.md#delegate-invocations)呼び出し) です。 *Primary_expression*がメソッドグループでも*delegate_type*の値でもない場合は、バインド時エラーが発生します。

省略可能な*argument_list* ([引数リスト](expressions.md#argument-lists)) は、メソッドのパラメーターの値または変数参照を提供します。

*Invocation_expression*を評価した結果は、次のように分類されます。

*  *Invocation_expression*が `void`を返すメソッドまたはデリゲートを呼び出すと、結果は nothing になります。 Nothing として分類される式は、 *statement_expression* ([式ステートメント](statements.md#expression-statements)) のコンテキスト、または*lambda_expression* ([匿名関数式](expressions.md#anonymous-function-expressions)) の本体としてのみ許可されます。 それ以外の場合、バインド時エラーが発生します。
*  それ以外の場合、結果は、メソッドまたはデリゲートによって返される型の値になります。

#### <a name="method-invocations"></a>メソッドの呼び出し

メソッド呼び出しの場合、 *invocation_expression*の*primary_expression*はメソッドグループである必要があります。 メソッドグループは、呼び出す1つのメソッド、または特定のメソッドを呼び出すオーバーロードされたメソッドのセットを識別します。 後者の場合、呼び出す特定のメソッドの決定は、 *argument_list*内の引数の型によって提供されるコンテキストに基づいて行われます。

`M(A)`フォームのメソッド呼び出しのバインド時の処理。 `M` は、( *type_argument_list*を含む) メソッドグループであり、`A` は省略可能な*argument_list*で、次の手順で構成されています。

*  メソッド呼び出しの候補メソッドのセットが構築されます。 メソッドグループに関連付けられている各メソッド `F` `M`を次に示します。
   *  `F` が非ジェネリックの場合、`F` は次のような場合に候補になります。
      * `M` に型引数リストがありません。
      * `F` は `A` ([適用可能な関数メンバー](expressions.md#applicable-function-member)) に対して適用できます。
   *  `F` がジェネリックで `M` に型引数リストがない場合、`F` は次のような場合に候補になります。
      * 型の推定 ([型の推定](expressions.md#type-inference)) が成功し、呼び出しの型引数のリストが推論されます。
      * 推論された型引数が対応するメソッドの型パラメーターに置き換えられると、F のパラメーターリスト内に構築されたすべての型は、制約を満たす ([制約を満たす](types.md#satisfying-constraints)) ことができます。また、`F` のパラメーターリストは、`A` ([適用可能な関数メンバー](expressions.md#applicable-function-member)) に対して適用できます。
   *  `F` がジェネリックで、`M` 型引数リストを含む場合、`F` は次のような場合に候補になります。
      * `F` には、型引数リストで指定されたものと同じ数のメソッド型パラメーターがあります。
      * 型引数を対応するメソッドの型パラメーターの代わりに使用すると、F のパラメーターリスト内の構築されたすべての型は、制約を満たす ([制約を満たす](types.md#satisfying-constraints)) と共に、`F` のパラメーターリストを `A` ([適用可能な関数メンバー](expressions.md#applicable-function-member)) に対して適用できます。
*  候補メソッドのセットは、ほとんどの派生型のメソッドのみを含むように縮小されます。 set 内のメソッド `C.F` ごとに、`C` はメソッド `F` が宣言されている型で、`C` の基本型で宣言されているすべてのメソッドがセットから削除されます。 さらに、`C` が `object`以外のクラス型である場合は、インターフェイス型で宣言されたすべてのメソッドがセットから削除されます。 (この後者の規則は、メソッドグループが、オブジェクト以外の有効な基本クラスと空でない有効なインターフェイスセットを持つ型パラメーターに対するメンバー参照の結果である場合にのみ影響を与えます)。
*  結果として得られる一連のメソッドが空の場合、次の手順に従ってさらに処理が中止され、その代わりに、拡張メソッドの呼び出し ([拡張メソッド](expressions.md#extension-method-invocations)呼び出し) として呼び出しを処理しようとしました。 これが失敗した場合、適用可能なメソッドは存在せず、バインド時エラーが発生します。
*  候補のメソッドセットの最適なメソッドは、[オーバーロード解決](expressions.md#overload-resolution)のオーバーロードの解決規則を使用して識別されます。 1つの最適なメソッドを識別できない場合、メソッドの呼び出しがあいまいになり、バインディング時エラーが発生します。 オーバーロードの解決を実行する場合、ジェネリックメソッドのパラメーターは、対応するメソッドの型パラメーターに対して型引数 (指定または推論) を代入した後に考慮されます。
*  選択した最適な方法の最終的な検証が実行されます。
   * メソッドは、メソッドグループのコンテキストで検証されます。最適なメソッドが静的メソッドの場合、メソッドグループは、型によって*simple_name*または*member_access*から生成されたものである必要があります。 最適なメソッドがインスタンスメソッドの場合、メソッドグループの結果は、 *simple_name*、変数または値を使用した*member_access* 、または*base_access*である必要があります。 これらの要件のいずれも当てはまらない場合は、バインド時エラーが発生します。
   * 最適なメソッドがジェネリックメソッドの場合は、ジェネリックメソッドで宣言されている制約 ([制約を満たす](types.md#satisfying-constraints)) に対して、型引数 (指定または推論) がチェックされます。 型引数が型パラメーターの対応する制約を満たしていない場合、バインド時エラーが発生します。

前の手順でバインド時にメソッドを選択して検証すると、実際のランタイム呼び出しは、「[動的なオーバーロードの解決のコンパイル時チェック](expressions.md#compile-time-checking-of-dynamic-overload-resolution)」で説明されている関数メンバー呼び出しの規則に従って処理されます。

上記で説明した解決規則の直感的な効果は次のとおりです。メソッド呼び出しによって呼び出された特定のメソッドを検索するには、メソッドの呼び出しによって示された型から開始し、少なくとも1つのが適用されるまで継承チェーンを進めます。アクセス可能で、オーバーライドされていないメソッド宣言が見つかりました。 次に、その型で宣言されている、アクセス可能で、オーバーライドできないメソッドのセットに対して、型の推定とオーバーロードの解決を実行し、選択したメソッドを呼び出します。 メソッドが見つからなかった場合は、代わりに拡張メソッドの呼び出しとして呼び出しを処理するようにしてください。

#### <a name="extension-method-invocations"></a>拡張メソッドの呼び出し

フォームのいずれかのメソッド呼び出し (ボックス化された[インスタンスでの呼び出し](expressions.md#invocations-on-boxed-instances))
```csharp
expr . identifier ( )

expr . identifier ( args )

expr . identifier < typeargs > ( )

expr . identifier < typeargs > ( args )
```
呼び出しの通常の処理で適用可能なメソッドが検出されなかった場合は、拡張メソッドの呼び出しとしてコンストラクトを処理しようとしました。 *Expr*またはいずれかの*引数*にコンパイル時の型 `dynamic`がある場合、拡張メソッドは適用されません。

目的は、対応する静的メソッドの呼び出しを実行できるように、最適な*type_name* `C`を見つけることです。
```csharp
C . identifier ( expr )

C . identifier ( expr , args )

C . identifier < typeargs > ( expr )

C . identifier < typeargs > ( expr , args )
```

拡張メソッド `Ci.Mj` は、次の場合に***適し***ています。

*  非ジェネリックの非入れ子クラスである `Ci`
*  `Mj` の名前は*識別子*です
*  上に示すように、引数に静的メソッドとして適用すると、`Mj` にアクセスして適用できます。
*  暗黙的な id、参照、またはボックス化変換は、 *expr*から `Mj`の最初のパラメーターの型に存在します。

`C` の検索は次のように実行されます。

*  最も近い外側の名前空間宣言から開始し、外側の名前空間宣言のそれぞれを継続し、次に、一連の拡張メソッドを検索します。
   * 指定された名前空間またはコンパイル単位に、対象となる拡張メソッド `Mj`の `Ci` 非ジェネリック型宣言が直接含まれている場合、これらの拡張メソッドのセットは候補セットになります。
   * 型 `Ci` *using_static_declarations*によってインポートされ、特定の名前空間またはコンパイル単位の*using_namespace_directive*によってインポートされた名前空間で直接宣言されている場合、適切な拡張メソッド `Mj`が直接含まれているため、これらの拡張メソッドのセットは候補セットになります。
*  外側の名前空間宣言またはコンパイル単位で候補セットが見つからない場合、コンパイル時エラーが発生します。
*  それ以外の場合は、「([オーバーロードの解決](expressions.md#overload-resolution))」の説明に従って、オーバーロードの解決が候補セットに適用されます。 1つの最適なメソッドが見つからない場合は、コンパイル時エラーが発生します。
*  `C` は、最適なメソッドが拡張メソッドとして宣言されている型です。

`C` をターゲットとして使用すると、メソッドの呼び出しは静的メソッドの呼び出しとして処理されます ([動的なオーバーロードの解決のコンパイル時のチェック](expressions.md#compile-time-checking-of-dynamic-overload-resolution))。

上記の規則は、インスタンスメソッドが拡張メソッドよりも優先されることを意味します。内部名前空間宣言で使用できる拡張メソッドは、外側の名前空間宣言で使用できる拡張メソッドよりも優先されます。名前空間で直接宣言されたメソッドは、using namespace ディレクティブを使用して同じ名前空間にインポートされた拡張メソッドよりも優先されます。 例:
```csharp
public static class E
{
    public static void F(this object obj, int i) { }

    public static void F(this object obj, string s) { }
}

class A { }

class B
{
    public void F(int i) { }
}

class C
{
    public void F(object obj) { }
}

class X
{
    static void Test(A a, B b, C c) {
        a.F(1);              // E.F(object, int)
        a.F("hello");        // E.F(object, string)

        b.F(1);              // B.F(int)
        b.F("hello");        // E.F(object, string)

        c.F(1);              // C.F(object)
        c.F("hello");        // C.F(object)
    }
}
```

この例では、`B`のメソッドは最初の拡張メソッドよりも優先され、`C`のメソッドは両方の拡張メソッドよりも優先されます。

```csharp
public static class C
{
    public static void F(this int i) { Console.WriteLine("C.F({0})", i); }
    public static void G(this int i) { Console.WriteLine("C.G({0})", i); }
    public static void H(this int i) { Console.WriteLine("C.H({0})", i); }
}

namespace N1
{
    public static class D
    {
        public static void F(this int i) { Console.WriteLine("D.F({0})", i); }
        public static void G(this int i) { Console.WriteLine("D.G({0})", i); }
    }
}

namespace N2
{
    using N1;

    public static class E
    {
        public static void F(this int i) { Console.WriteLine("E.F({0})", i); }
    }

    class Test
    {
        static void Main(string[] args)
        {
            1.F();
            2.G();
            3.H();
        }
    }
}
```

この例の出力は次のようになります。
```console
E.F(1)
D.G(2)
C.H(3)
```
`D.G` は `C.G`よりも優先され、`E.F` は `D.F` と `C.F`の両方に優先します。

#### <a name="delegate-invocations"></a>デリゲートの呼び出し

デリゲート呼び出しの場合、 *invocation_expression*の*primary_expression*は*delegate_type*の値である必要があります。 さらに、 *delegate_type*が*delegate_type*と同じパラメーターリストを持つ関数メンバーになることを考慮して、 *delegate_type*は*invocation_expression*の*argument_list*に対して適用可能 ([適用可能な関数メンバー](expressions.md#applicable-function-member)) である必要があります。

`D(A)`フォームのデリゲート呼び出しの実行時処理。 `D` は*delegate_type*の*primary_expression*であり、`A` は省略可能な*argument_list*で、次の手順で構成されています。

*  `D` が評価されます。 この評価によって例外が発生した場合、それ以上の手順は実行されません。
*  `D` の値が有効であるかどうかがチェックされます。 `D` の値が `null`場合は `System.NullReferenceException` がスローされ、それ以上の手順は実行されません。
*  それ以外の場合、`D` はデリゲートインスタンスへの参照です。 関数メンバー呼び出し ([動的なオーバーロード解決のコンパイル時チェック](expressions.md#compile-time-checking-of-dynamic-overload-resolution)) は、デリゲートの呼び出しリスト内の呼び出し可能な各エンティティに対して実行されます。 インスタンスメソッドとインスタンスメソッドで構成される呼び出し可能なエンティティの場合、呼び出しのインスタンスは、呼び出し可能なエンティティに含まれるインスタンスです。

### <a name="element-access"></a>要素アクセス

*Element_access*は、 *primary_no_array_creation_expression*で構成され、その後に "`[`" トークン、その後に続く*argument_list*、"`]`" トークンが続きます。 *Argument_list*は、コンマで区切られた1つ以上の*引数*で構成されます。

```antlr
element_access
    : primary_no_array_creation_expression '[' expression_list ']'
    ;
```

*Element_access*の*argument_list*に `ref` または `out` 引数を含めることはできません。

次のいずれかに当てはまる場合、 *element_access*は動的にバインドされます ([動的バインド](expressions.md#dynamic-binding))。

* *Primary_no_array_creation_expression*には、コンパイル時の型 `dynamic`があります。
* *Argument_list*の少なくとも1つの式のコンパイル時の型が `dynamic` で、 *primary_no_array_creation_expression*に配列型がありません。

この場合、コンパイラは*element_access*を型 `dynamic`の値として分類します。 次の規則は、 *element_access*の意味を判断するために、実行時に実行時に適用されます。これには、コンパイル時の型 `dynamic`を持つ*primary_no_array_creation_expression*および*argument_list*式のコンパイル時の型ではなく、ランタイム型が使用されます。 *Primary_no_array_creation_expression*にコンパイル時の型 `dynamic`がない場合は、「[動的なオーバーロードの解決のコンパイル時チェック](expressions.md#compile-time-checking-of-dynamic-overload-resolution)」で説明されているように、要素へのアクセスが制限付きコンパイル時間になります。

*Element_access*の*primary_no_array_creation_expression*が*array_type*の値の場合、 *element_access*は配列アクセス ([配列アクセス](expressions.md#array-access)) です。 それ以外の場合、 *primary_no_array_creation_expression*は、1つ以上のインデクサーメンバーを持つクラス、構造体、またはインターフェイス型の変数または値である必要があります。この場合、 *element_access*はインデクサーアクセス ([インデクサーアクセス](expressions.md#indexer-access)) になります。

#### <a name="array-access"></a>配列へのアクセス

配列アクセスの場合、 *element_access*の*primary_no_array_creation_expression*は*array_type*の値である必要があります。 さらに、配列アクセスの*argument_list*に名前付き引数を含めることはできません。*Argument_list*内の式の数は、 *array_type*のランクと同じである必要があります。また、各式は `int`、`uint`、`long`、`ulong`の型であるか、またはこれらの型の1つ以上に暗黙的に変換可能である必要があります。

配列アクセスを評価した結果は、配列の要素型、つまり、 *argument_list*内の式の値によって選択された配列要素の変数になります。

`P[A]`フォームへの配列アクセスの実行時処理では、`P` は*array_type*の*primary_no_array_creation_expression*であり、`A` は*argument_list*で、次の手順で構成されています。

*  `P` が評価されます。 この評価によって例外が発生した場合、それ以上の手順は実行されません。
*  *Argument_list*のインデックス式は、左から右に順番に評価されます。 各インデックス式を評価すると、次のいずれかの型への暗黙的な変換 ([暗黙](conversions.md#implicit-conversions)の変換) が実行されます: `int`、`uint`、`long`、`ulong`。 暗黙的な変換が存在する、この一覧の最初の型が選択されます。 たとえば、インデックス式が `short` 型の場合、`int` への暗黙的な変換が実行されます。これは、`short` から `int` への暗黙の変換と `short` から `long` への暗黙的な変換が可能であるためです。 インデックス式またはそれ以降の暗黙的な変換の評価によって例外が発生した場合、それ以降のインデックス式は評価されず、それ以上の手順は実行されません。
*  `P` の値が有効であるかどうかがチェックされます。 `P` の値が `null`場合は `System.NullReferenceException` がスローされ、それ以上の手順は実行されません。
*  *Argument_list*内の各式の値は、`P`によって参照される配列インスタンスの各次元の実際の境界に照らし合わせてチェックされます。 1つ以上の値が範囲外の場合は、`System.IndexOutOfRangeException` がスローされ、それ以上の手順は実行されません。
*  インデックス式によって指定された配列要素の位置が計算され、この位置が配列アクセスの結果になります。

#### <a name="indexer-access"></a>インデクサーへのアクセス

インデクサーアクセスの場合、 *element_access*の*primary_no_array_creation_expression*はクラス、構造体、またはインターフェイス型の変数または値である必要があり、この型は*element_access*の*argument_list*に対して適用できる1つ以上のインデクサーを実装する必要があります。

`P[A]`形式のインデクサーアクセスのバインド時の処理では、`P` はクラス、構造体、またはインターフェイス型 `T`の*primary_no_array_creation_expression*であり、`A` は*argument_list*で、次の手順で構成されます。

*  `T` によって提供されるインデクサーのセットが構築されます。 このセットは、`T` で宣言されたすべてのインデクサーと、`override` 宣言ではなく、現在のコンテキスト ([メンバーアクセス](basic-concepts.md#member-access)) でアクセスできる `T` の基本型で構成されます。
*  このセットは、他のインデクサーによって適用可能で非表示にされるインデクサーに限定されます。 次の規則は、セット内の各インデクサー `S.I` に適用されます。 `S` は、インデクサー `I` が宣言されている型です。
   * `I` が `A` ([該当する関数メンバー](expressions.md#applicable-function-member)) に対して適用されない場合は、`I` がセットから削除されます。
   * `I` が `A` ([適用可能な関数メンバー](expressions.md#applicable-function-member)) に対して適用できる場合、`S` の基本型で宣言されたすべてのインデクサーがセットから削除されます。
   * `I` が `A` ([適用可能な関数メンバー](expressions.md#applicable-function-member)) に対して適用可能で、`S` が `object`以外のクラス型である場合、インターフェイスで宣言されているすべてのインデクサーがセットから削除されます。
*  結果として得られる一連のインデクサーが空の場合、適用可能なインデクサーは存在せず、バインド時エラーが発生します。
*  一連の候補インデクサーの最適なインデクサーは、[オーバーロード解決](expressions.md#overload-resolution)のオーバーロードの解決規則を使用して識別されます。 1つの最適なインデクサーを識別できない場合、インデクサーアクセスはあいまいであり、バインド時エラーが発生します。
*  *Argument_list*のインデックス式は、左から右に順番に評価されます。 インデクサーアクセスの処理結果は、インデクサーアクセスとして分類される式です。 インデクサーアクセス式は、上記の手順で特定されたインデクサーを参照し、`P` のインスタンス式と、関連付けられた `A`の引数リストを持ちます。

インデクサーアクセスは、使用されるコンテキストに応じて、インデクサーの*get アクセサー*または*set アクセサー*のいずれかを呼び出します。 インデクサーアクセスが割り当てのターゲットである場合は、 *set アクセサー*が呼び出され、新しい値 ([単純な割り当て](expressions.md#simple-assignment)) が割り当てられます。 それ以外の場合は、 *get アクセサー*を呼び出して現在の値 ([式の値](expressions.md#values-of-expressions)) を取得します。

### <a name="this-access"></a>このアクセス権

*This_access*は、予約語 `this`で構成されています。

```antlr
this_access
    : 'this'
    ;
```

*This_access*は、インスタンスコンストラクター、インスタンスメソッド、またはインスタンスアクセサーの*ブロック*内でのみ許可されます。 次のいずれかの意味があります。

*  クラスのインスタンスコンストラクター内の*primary_expression*で `this` を使用すると、値として分類されます。 値の型は、使用が発生するクラスのインスタンス型 ([インスタンス型](classes.md#the-instance-type)) であり、値は構築されているオブジェクトへの参照です。
*  クラスのインスタンスメソッドまたはインスタンスアクセサー内の*primary_expression*で `this` を使用すると、値として分類されます。 値の型は、使用が発生するクラスのインスタンスの型 ([インスタンス型](classes.md#the-instance-type)) です。この値は、メソッドまたはアクセサーが呼び出されたオブジェクトへの参照です。
*  構造体のインスタンスコンストラクター内の*primary_expression*で `this` を使用すると、変数として分類されます。 変数の型は、使用が発生する構造体のインスタンス型 ([インスタンス型](classes.md#the-instance-type)) であり、変数は構築されている構造体を表します。 構造体のインスタンスコンストラクターの `this` 変数は、構造体型の `out` パラメーターとまったく同じように動作します。特に、これは、インスタンスコンストラクターのすべての実行パスで変数を確実に割り当てる必要があることを意味します。
*  構造体のインスタンスメソッドまたはインスタンスアクセサー内の*primary_expression*で `this` を使用すると、変数として分類されます。 変数の型は、使用状況が発生する構造体のインスタンスの型 ([インスタンス型](classes.md#the-instance-type)) です。
   * メソッドまたはアクセサーが反復子 ([反復子](classes.md#iterators)) でない場合、`this` 変数は、メソッドまたはアクセサーが呼び出された構造体を表し、構造体型の `ref` パラメーターとまったく同じように動作します。
   * メソッドまたはアクセサーが反復子の場合、`this` 変数は、メソッドまたはアクセサーが呼び出された構造体のコピーを表し、構造体型の値パラメーターとまったく同じように動作します。

上記以外のコンテキストで*primary_expression*内の `this` を使用すると、コンパイル時エラーが発生します。 特に、静的メソッド、静的プロパティアクセサー、またはフィールド宣言の*variable_initializer*で `this` を参照することはできません。

### <a name="base-access"></a>基本アクセス

*Base_access*は、予約語 `base` の後に "`.`" トークン、識別子、または角かっこで囲まれた*argument_list*で構成されます。

```antlr
base_access
    : 'base' '.' identifier
    | 'base' '[' expression_list ']'
    ;
```

*Base_access*は、現在のクラスまたは構造体の同じ名前のメンバーによって隠ぺいされている基底クラスのメンバーにアクセスするために使用されます。 *Base_access*は、インスタンスコンストラクター、インスタンスメソッド、またはインスタンスアクセサーの*ブロック*内でのみ許可されます。 クラスまたは構造体で `base.I` が発生した場合、`I` は、そのクラスまたは構造体の基底クラスのメンバーを示す必要があります。 同様に、クラスで `base[E]` が発生した場合は、適用可能なインデクサーが基本クラスに存在する必要があります。

バインド時には、フォーム `base.I` と `base[E]` の*base_access*式が `((B)this).I` および `((B)this)[E]`に記述されているかのように正確に評価されます。 `B` は、コンストラクトが発生するクラスまたは構造体の基本クラスです。 したがって、`base.I` と `base[E]` は `this.I` と `this[E]`に対応しますが、`this` は基本クラスのインスタンスとして表示される点が異なります。

*Base_access*が仮想関数メンバー (メソッド、プロパティ、またはインデクサー) を参照する場合、実行時に呼び出す関数メンバーの決定 ([動的なオーバーロードの解決のコンパイル時チェック](expressions.md#compile-time-checking-of-dynamic-overload-resolution)) が変更されます。 呼び出される関数メンバーを決定するには、関数メンバーの最も派生された実装 ([仮想メソッド](classes.md#virtual-methods)) を検索します。これは、`this`の実行時の型に対してではなく、`B` に対して行われます。これは、非基本アクセスの場合と同様です。 したがって、`virtual` 関数メンバーの `override` 内では、 *base_access*を使用して、関数メンバーの継承された実装を呼び出すことができます。 *Base_access*によって参照される関数メンバーが abstract の場合、バインド時エラーが発生します。

### <a name="postfix-increment-and-decrement-operators"></a>後置インクリメント演算子と後置デクリメント演算子

```antlr
post_increment_expression
    : primary_expression '++'
    ;

post_decrement_expression
    : primary_expression '--'
    ;
```

後置インクリメントまたはデクリメント演算のオペランドには、変数、プロパティアクセス、またはインデクサーアクセスとして分類される式を指定する必要があります。 演算の結果は、オペランドと同じ型の値になります。

*Primary_expression*にコンパイル時の型が `dynamic` 場合、演算子は動的バインド ([動的バインド](expressions.md#dynamic-binding))、 *post_increment_expression*または*post_decrement_expression*にはコンパイル時の型が `dynamic`、実行時には*primary_expression*のランタイム型を使用して次の規則が適用されます。

後置インクリメントまたはデクリメント演算のオペランドがプロパティまたはインデクサーアクセスの場合、プロパティまたはインデクサーには、`get` と `set` の両方のアクセサーが必要です。 そうでない場合は、バインド時エラーが発生します。

単項演算子のオーバーロードの解決 ([単項演算子のオーバーロードの解決](expressions.md#unary-operator-overload-resolution)) は、特定の演算子の実装を選択するために適用されます。 定義済みの `++` と `--` の演算子は、`sbyte`、`byte`、`short`、`ushort`、`int`、`uint`、`long`、`ulong`、`char`、`float`、`double`、`decimal`、列挙型の各型に存在します。 定義済みの `++` 演算子は、オペランドに1を加算して生成された値を返します。定義済みの `--` 演算子は、オペランドから1を減算して生成された値を返します。 `checked` コンテキストでは、この加算または減算の結果が結果型の範囲外で、結果型が整数型または列挙型の場合、`System.OverflowException` がスローされます。

`x++` または `x--` フォームの後置インクリメントまたはデクリメント操作の実行時処理は、次の手順で構成されています。

*   `x` が変数として分類される場合は、次のようになります。
    * 変数を生成するために `x` が評価されます。
    * `x` の値が保存されます。
    * 選択した演算子は、引数として `x` の保存値を使用して呼び出されます。
    * 演算子によって返される値は、`x`の評価によって指定された場所に格納されます。
    * `x` の保存された値は、操作の結果になります。
*   `x` がプロパティまたはインデクサーアクセスとして分類される場合は、次のようになります。
    * インスタンス式 (`x` が `static`でない場合) と `x` に関連付けられている引数リスト (`x` がインデクサーアクセスの場合) が評価され、その結果が後続の `get` および `set` アクセサー呼び出しで使用されます。
    * `x` の `get` アクセサーが呼び出され、戻り値が保存されます。
    * 選択した演算子は、引数として `x` の保存値を使用して呼び出されます。
    * `x` の `set` アクセサーは、`value` 引数として演算子によって返された値を使用して呼び出されます。
    * `x` の保存された値は、操作の結果になります。

`++` 演算子と `--` 演算子では、プレフィックスの[インクリメントとデクリメント演算子](expressions.md#prefix-increment-and-decrement-operators)もサポートされています。 通常、`x++` または `x--` の結果は、操作の前の `x` の値になります。一方、`++x` または `--x` の結果は、操作後の `x` の値になります。 どちらの場合も、`x` 自体の値は、操作の後で同じになります。

`operator ++` または `operator --` の実装は、後置表記またはプレフィックス表記のいずれかを使用して呼び出すことができます。 2つの表記に対して個別の演算子を実装することはできません。

### <a name="the-new-operator"></a>新しい演算子

`new` 演算子は、型の新しいインスタンスを作成するために使用されます。

`new` 式には、次の3つの形式があります。

*  オブジェクト作成式は、クラス型と値型の新しいインスタンスを作成するために使用されます。
*  配列作成式は、配列型の新しいインスタンスを作成するために使用されます。
*  デリゲート作成式は、デリゲート型の新しいインスタンスを作成するために使用されます。

`new` 演算子は、型のインスタンスの作成を意味しますが、必ずしもメモリの動的割り当てを意味するわけではありません。 特に、値型のインスタンスは、それが存在する変数以外に追加のメモリを必要としません。値型のインスタンスを作成するために `new` を使用する場合、動的な割り当ては発生しません。

#### <a name="object-creation-expressions"></a>オブジェクト作成式

*Object_creation_expression*は、 *class_type*または*value_type*の新しいインスタンスを作成するために使用されます。

```antlr
object_creation_expression
    : 'new' type '(' argument_list? ')' object_or_collection_initializer?
    | 'new' type object_or_collection_initializer
    ;

object_or_collection_initializer
    : object_initializer
    | collection_initializer
    ;
```

*Object_creation_expression*の*種類*は、 *class_type*、 *value_type* 、または*type_parameter*である必要があります。 *型*を `abstract` *class_type*にすることはできません。

省略可能な*argument_list* ([引数リスト](expressions.md#argument-lists)) は、*型*が*class_type*または*struct_type*の場合にのみ許可されます。

オブジェクトの作成式では、コンストラクターの引数リストと、オブジェクト初期化子またはコレクション初期化子が含まれている場合に囲むかっこを省略できます。 コンストラクターの引数リストと囲んでいるかっこを省略することは、空の引数リストを指定することと同じです。

オブジェクト初期化子またはコレクション初期化子を含むオブジェクト作成式の処理では、最初にインスタンスコンストラクターを処理した後、オブジェクト初期化子 ([オブジェクト初期化](expressions.md#object-initializers)子) またはコレクション初期化子 ([コレクション](expressions.md#collection-initializers)初期化子) によって指定されたメンバーまたは要素の初期化を処理します。

省略可能な*argument_list*内のいずれかの引数にコンパイル時の型が `dynamic` 場合、 *object_creation_expression*は動的にバインドされ ([動的バインディング](expressions.md#dynamic-binding))、次の規則は、コンパイル時の型 `dynamic`を持つ*argument_list*の引数の実行時の型を使用して実行時に適用されます。 ただし、オブジェクトの作成では、「[動的なオーバーロードの解決のコンパイル時チェック](expressions.md#compile-time-checking-of-dynamic-overload-resolution)」で説明されているように、コンパイル時間の制限があります。

フォーム `new T(A)`の*object_creation_expression*のバインド時の処理。 `T` は*class_type*または*value_type*で、`A` は省略可能な*argument_list*で、次の手順で構成されています。

*   `T` が*value_type*で、`A` が存在しない場合は、次のようになります。
    * *Object_creation_expression*は、既定のコンストラクターの呼び出しです。 *Object_creation_expression*の結果は `T`型の値です。つまり、[システムの ValueType 型](types.md#the-systemvaluetype-type)で定義されている `T` の既定値です。
*   それ以外の場合、`T` が*type_parameter*で `A` が存在しない場合は、次のようになります。
    * `T`に値型の制約またはコンストラクターの制約 ([型パラメーターの制約](classes.md#type-parameter-constraints)) が指定されていない場合、バインディング時エラーが発生します。
    * *Object_creation_expression*の結果は、型パラメーターのバインド先であるランタイム型の値です。つまり、その型の既定のコンストラクターを呼び出した結果です。 実行時の型は、参照型または値型にすることができます。
*   それ以外の場合、`T` が*class_type*または*struct_type*の場合は、次のようになります。
    * `T` が `abstract` *class_type*の場合、コンパイル時エラーが発生します。
    * 呼び出すインスタンスコンストラクターは、[オーバーロード解決](expressions.md#overload-resolution)のオーバーロードの解決規則を使用して決定されます。 候補インスタンスコンストラクターのセットは、`A` ([適用可能な関数メンバー](expressions.md#applicable-function-member)) に対して適用できる、`T` で宣言されたすべてのアクセス可能なインスタンスコンストラクターで構成されます。 候補インスタンスコンストラクターのセットが空である場合、または1つの最適なインスタンスコンストラクターを識別できない場合は、バインディング時エラーが発生します。
    * *Object_creation_expression*の結果は `T`型の値です。つまり、上記の手順で特定されたインスタンスコンストラクターを呼び出すことによって生成される値です。
*  それ以外の場合、 *object_creation_expression*は無効であり、バインド時エラーが発生します。

*Object_creation_expression*が動的にバインドされている場合でも、コンパイル時の型は引き続き `T`ます。

フォーム `new T(A)`の*object_creation_expression*の実行時処理。 `T` は*class_type*または*struct_type*で、`A` は省略可能な*argument_list*で、次の手順で構成されています。

*   `T` が*class_type*の場合は、次のようになります。
    * クラス `T` の新しいインスタンスが割り当てられます。 新しいインスタンスの割り当てに使用できるメモリが不足している場合は、`System.OutOfMemoryException` がスローされ、それ以上の手順は実行されません。
    * 新しいインスタンスのすべてのフィールドは、既定値 ([既定値](variables.md#default-values)) に初期化されます。
    * インスタンスコンストラクターは、関数メンバー呼び出しの規則 ([動的なオーバーロードの解決のコンパイル時チェック](expressions.md#compile-time-checking-of-dynamic-overload-resolution)) に従って呼び出されます。 新しく割り当てられたインスタンスへの参照がインスタンスコンストラクターに自動的に渡され、そのコンストラクター内から `this`としてインスタンスにアクセスできます。
*   `T` が*struct_type*の場合は、次のようになります。
    * `T` 型のインスタンスは、一時的なローカル変数を割り当てることによって作成されます。 *Struct_type*のインスタンスコンストラクターは、作成されるインスタンスの各フィールドに値を確実に割り当てる必要があるため、一時変数を初期化する必要はありません。
    * インスタンスコンストラクターは、関数メンバー呼び出しの規則 ([動的なオーバーロードの解決のコンパイル時チェック](expressions.md#compile-time-checking-of-dynamic-overload-resolution)) に従って呼び出されます。 新しく割り当てられたインスタンスへの参照がインスタンスコンストラクターに自動的に渡され、そのコンストラクター内から `this`としてインスタンスにアクセスできます。

#### <a name="object-initializers"></a>オブジェクト初期化子

オブジェクト***初期化子***は、オブジェクトの0個以上のフィールド、プロパティ、またはインデックス付き要素の値を指定します。

```antlr
object_initializer
    : '{' member_initializer_list? '}'
    | '{' member_initializer_list ',' '}'
    ;

member_initializer_list
    : member_initializer (',' member_initializer)*
    ;

member_initializer
    : initializer_target '=' initializer_value
    ;

initializer_target
    : identifier
    | '[' argument_list ']'
    ;

initializer_value
    : expression
    | object_or_collection_initializer
    ;
```

オブジェクト初期化子は、`{` および `}` トークンで囲まれ、コンマで区切られた一連のメンバー初期化子で構成されます。 各*member_initializer*は、初期化のターゲットを指定します。 *識別子*は、初期化されるオブジェクトのアクセス可能なフィールドまたはプロパティに名前を付ける必要があります。一方、角かっこで囲まれた*argument_list*は、初期化されるオブジェクトのアクセス可能なインデクサーの引数を指定する必要があります。 オブジェクト初期化子に、同じフィールドまたはプロパティに対して複数のメンバー初期化子が含まれていると、エラーになります。

各*initializer_target*には、等号と、式、オブジェクト初期化子、またはコレクション初期化子のいずれかが続きます。 オブジェクト初期化子内の式は、初期化中の新しく作成されたオブジェクトを参照することはできません。

等号の後にある式を指定するメンバー初期化子は、ターゲットへの代入 ([単純な代入](expressions.md#simple-assignment)) と同じ方法で処理されます。

等号の後にオブジェクト初期化子を指定するメンバー初期化子は、入れ子になったオブジェクト***初期化子***、つまり埋め込みオブジェクトの初期化です。 フィールドまたはプロパティに新しい値を割り当てる代わりに、入れ子になったオブジェクト初期化子の割り当ては、フィールドまたはプロパティのメンバーへの割り当てとして扱われます。 入れ子になったオブジェクト初期化子は、値型のプロパティ、または値の型を持つ読み取り専用フィールドには適用できません。

等号の後にコレクション初期化子を指定するメンバー初期化子は、埋め込みコレクションを初期化します。 ターゲットフィールド、プロパティ、またはインデクサーに新しいコレクションを割り当てる代わりに、初期化子に指定された要素が、ターゲットによって参照されるコレクションに追加されます。 ターゲットは、[コレクション初期化子](expressions.md#collection-initializers)に指定された要件を満たすコレクション型である必要があります。

インデックス初期化子への引数は、常に1回だけ評価されます。 したがって、引数が最終的に使用されない場合 (たとえば、入れ子になった空の初期化子があるため)、副作用について評価されます。

次のクラスは、2つの座標を持つ点を表します。
```csharp
public class Point
{
    int x, y;

    public int X { get { return x; } set { x = value; } }
    public int Y { get { return y; } set { y = value; } }
}
```

`Point` のインスタンスは、次のようにして作成および初期化できます。
```csharp
Point a = new Point { X = 0, Y = 1 };
```
これは、
```csharp
Point __a = new Point();
__a.X = 0;
__a.Y = 1; 
Point a = __a;
```
`__a` は、非表示であり、アクセスできない一時的な変数です。 次のクラスは、2つの点から作成された四角形を表します。
```csharp
public class Rectangle
{
    Point p1, p2;

    public Point P1 { get { return p1; } set { p1 = value; } }
    public Point P2 { get { return p2; } set { p2 = value; } }
}
```

`Rectangle` のインスタンスは、次のようにして作成および初期化できます。
```csharp
Rectangle r = new Rectangle {
    P1 = new Point { X = 0, Y = 1 },
    P2 = new Point { X = 2, Y = 3 }
};
```
これは、
```csharp
Rectangle __r = new Rectangle();
Point __p1 = new Point();
__p1.X = 0;
__p1.Y = 1;
__r.P1 = __p1;
Point __p2 = new Point();
__p2.X = 2;
__p2.Y = 3;
__r.P2 = __p2; 
Rectangle r = __r;
```
`__r`、`__p1`、および `__p2` は、非表示でアクセスできない一時的な変数です。

`Rectangle`のコンストラクターが2つの埋め込み `Point` インスタンスを割り当てる場合
```csharp
public class Rectangle
{
    Point p1 = new Point();
    Point p2 = new Point();

    public Point P1 { get { return p1; } }
    public Point P2 { get { return p2; } }
}
```
次のコンストラクトは、新しいインスタンスを割り当てる代わりに、埋め込み `Point` インスタンスを初期化するために使用できます。
```csharp
Rectangle r = new Rectangle {
    P1 = { X = 0, Y = 1 },
    P2 = { X = 2, Y = 3 }
};
```
これは、
```csharp
Rectangle __r = new Rectangle();
__r.P1.X = 0;
__r.P1.Y = 1;
__r.P2.X = 2;
__r.P2.Y = 3;
Rectangle r = __r;
```

次の例では、C の適切な定義が指定されています。
```csharp
var c = new C {
    x = true,
    y = { a = "Hello" },
    z = { 1, 2, 3 },
    ["x"] = 5,
    [0,0] = { "a", "b" },
    [1,2] = {}
};
```
は、次の一連の代入と同じです。
```csharp
C __c = new C();
__c.x = true;
__c.y.a = "Hello";
__c.z.Add(1); 
__c.z.Add(2);
__c.z.Add(3);
string __i1 = "x";
__c[__i1] = 5;
int __i2 = 0, __i3 = 0;
__c[__i2,__i3].Add("a");
__c[__i2,__i3].Add("b");
int __i4 = 1, __i5 = 2;
var c = __c;
```
`__c`などは、ソースコードからは見えず、アクセスできない生成変数です。 `[0,0]` の引数は1回だけ評価され、使用されていない場合でも `[1,2]` の引数は1回だけ評価されることに注意してください。

#### <a name="collection-initializers"></a>コレクション初期化子

コレクション初期化子は、コレクションの要素を指定します。

```antlr
collection_initializer
    : '{' element_initializer_list '}'
    | '{' element_initializer_list ',' '}'
    ;

element_initializer_list
    : element_initializer (',' element_initializer)*
    ;

element_initializer
    : non_assignment_expression
    | '{' expression_list '}'
    ;

expression_list
    : expression (',' expression)*
    ;
```

コレクション初期化子は、`{` および `}` トークンで囲まれ、コンマで区切られた要素初期化子のシーケンスで構成されます。 各要素初期化子は、初期化されるコレクションオブジェクトに追加する要素を指定します。また、`{` および `}` トークンで囲まれ、コンマで区切られた式のリストで構成されます。  単一式の要素初期化子は、かっこを使用せずに記述できますが、メンバー初期化子とのあいまいさを避けるために代入式にすることはできません。 *Non_assignment_expression*の運用環境は、[式](expressions.md#expression)で定義されます。

次に、コレクション初期化子を含むオブジェクト作成式の例を示します。
```csharp
List<int> digits = new List<int> { 0, 1, 2, 3, 4, 5, 6, 7, 8, 9 };
```

コレクション初期化子が適用されるコレクションオブジェクトは、`System.Collections.IEnumerable` を実装する型であるか、またはコンパイル時のエラーが発生します。 コレクション初期化子は、指定された要素ごとに、引数リストとして要素初期化子の式リストを使用してターゲットオブジェクトの `Add` メソッドを呼び出し、各呼び出しに対して通常のメンバー参照とオーバーロードの解決を適用します。 したがって、コレクションオブジェクトには、要素初期化子ごとに `Add` という名前の適用可能なインスタンスまたは拡張メソッドが必要です。

次のクラスは、名前と電話番号のリストを持つ連絡先を表します。
```csharp
public class Contact
{
    string name;
    List<string> phoneNumbers = new List<string>();

    public string Name { get { return name; } set { name = value; } }

    public List<string> PhoneNumbers { get { return phoneNumbers; } }
}
```

`List<Contact>` は、次のようにして作成および初期化できます。
```csharp
var contacts = new List<Contact> {
    new Contact {
        Name = "Chris Smith",
        PhoneNumbers = { "206-555-0101", "425-882-8080" }
    },
    new Contact {
        Name = "Bob Harris",
        PhoneNumbers = { "650-555-0199" }
    }
};
```
これは、
```csharp
var __clist = new List<Contact>();
Contact __c1 = new Contact();
__c1.Name = "Chris Smith";
__c1.PhoneNumbers.Add("206-555-0101");
__c1.PhoneNumbers.Add("425-882-8080");
__clist.Add(__c1);
Contact __c2 = new Contact();
__c2.Name = "Bob Harris";
__c2.PhoneNumbers.Add("650-555-0199");
__clist.Add(__c2);
var contacts = __clist;
```
`__clist`、`__c1`、および `__c2` は、非表示でアクセスできない一時的な変数です。

#### <a name="array-creation-expressions"></a>配列作成式

*Array_creation_expression*は、 *array_type*の新しいインスタンスを作成するために使用されます。

```antlr
array_creation_expression
    : 'new' non_array_type '[' expression_list ']' rank_specifier* array_initializer?
    | 'new' array_type array_initializer
    | 'new' rank_specifier array_initializer
    ;
```

最初の形式の配列作成式は、式リストから各式を削除した結果として得られる型の配列インスタンスを割り当てます。 たとえば、配列作成式 `new int[10,20]` によって `int[,]`型の配列インスタンスが生成され、配列作成式 `new int[10][,]` によって `int[][,]`型の配列が生成されます。 式リストの各式は、型 `int`、`uint`、`long`、または `ulong`であるか、またはこれらの型の1つ以上に暗黙的に変換できなければなりません。 各式の値によって、新しく割り当てられた配列インスタンス内の対応する次元の長さが決まります。 配列の次元の長さは負ではない必要があるため、式の一覧に負の値を持つ*constant_expression*を持つコンパイル時エラーが発生します。

Unsafe コンテキスト ([unsafe](unsafe-code.md#unsafe-contexts)コンテキスト) の場合を除き、配列のレイアウトは指定されません。

最初の形式の配列作成式に配列初期化子が含まれている場合、式リスト内の各式は定数である必要があり、式リストで指定されたランクと次元の長さは配列初期化子の式と一致する必要があります。

2番目または3番目の形式の配列作成式では、指定された配列型またはランク指定子のランクが配列初期化子のランクと一致している必要があります。 個々の次元の長さは、配列初期化子の対応する入れ子のレベルそれぞれに含まれる要素の数から推論されます。 したがって、式
```csharp
new int[,] {{0, 1}, {2, 3}, {4, 5}}
```
完全に対応
```csharp
new int[3, 2] {{0, 1}, {2, 3}, {4, 5}}
```

3番目の形式の配列作成式は、暗黙的に***型指定された配列作成式***と呼ばれます。 2番目の形式に似ていますが、配列の要素の型は明示的に指定されていませんが、配列初期化子内の式のセットの最適な共通型 ([式セットの最適な共通型](expressions.md#finding-the-best-common-type-of-a-set-of-expressions)) として決定される点が異なります。 多次元配列の場合、つまり、 *rank_specifier*に少なくとも1つのコンマが含まれている場合、このセットは、入れ子になった*array_initializer*s で見つかったすべての*式*で構成されます。

配列初期化子の詳細については、「[配列初期化子](arrays.md#array-initializers)」を参照してください。

配列作成式を評価した結果は、新たに割り当てられた配列インスタンスへの参照として、値として分類されます。 配列作成式の実行時の処理は、次の手順で構成されます。

*  *Expression_list*のディメンション長式は、左から右の順に評価されます。 各式を評価すると、次のいずれかの型への暗黙的な変換 ([暗黙](conversions.md#implicit-conversions)の変換) が実行されます: `int`、`uint`、`long`、`ulong`。 暗黙的な変換が存在する、この一覧の最初の型が選択されます。 式またはそれ以降の暗黙的な変換によって例外が発生した場合、それ以降の式は評価されず、それ以上の手順は実行されません。
*  ディメンションの長さの計算値は、次のように検証されます。 1つ以上の値が0未満の場合は、`System.OverflowException` がスローされ、それ以上の手順は実行されません。
*  次元の長さを指定して配列インスタンスが割り当てられています。 新しいインスタンスの割り当てに使用できるメモリが不足している場合は、`System.OutOfMemoryException` がスローされ、それ以上の手順は実行されません。
*  新しい配列インスタンスのすべての要素は、既定値 ([既定値](variables.md#default-values)) に初期化されます。
*  配列作成式に配列初期化子が含まれている場合は、配列初期化子内の各式が評価され、対応する配列要素に代入されます。 評価と割り当ては、配列初期化子で式が記述されている順序で実行されます。つまり、要素は、一番右にあるディメンションが優先され、インデックスの昇順で初期化されます。 指定された式の評価、または対応する配列要素への後続の代入によって例外が発生した場合、それ以上要素は初期化されません (残りの要素には既定値が設定されます)。

配列作成式では、配列型の要素を含む配列のインスタンス化が許可されますが、このような配列の要素は手動で初期化する必要があります。 たとえば、次のステートメントは
```csharp
int[][] a = new int[100][];
```
`int[]`型の100要素を含む1次元配列を作成します。 各要素の初期値は `null`です。 同じ配列作成式で、サブ配列とステートメントをインスタンス化することはできません。
```csharp
int[][] a = new int[100][5];        // Error
```
コンパイル時エラーが発生します。 代わりに、サブ配列のインスタンス化を手動で実行する必要があります。
```csharp
int[][] a = new int[100][];
for (int i = 0; i < 100; i++) a[i] = new int[5];
```

配列の配列に "四角形" の形状がある場合、つまり、サブ配列の長さがすべて同じである場合は、多次元配列を使用する方が効率的です。 上の例では、配列の配列のインスタンス化によって101オブジェクト (1 つの外部配列と100サブ配列) が作成されます。 それに対して
```csharp
int[,] = new int[100, 5];
```
1つのオブジェクトと2次元配列だけを作成し、1つのステートメントで割り当てを行います。

暗黙的に型指定された配列作成式の例を次に示します。
```csharp
var a = new[] { 1, 10, 100, 1000 };                       // int[]

var b = new[] { 1, 1.5, 2, 2.5 };                         // double[]

var c = new[,] { { "hello", null }, { "world", "!" } };   // string[,]

var d = new[] { 1, "one", 2, "two" };                     // Error
```

最後の式では、`int` も `string` も暗黙的に他方に変換できないため、コンパイル時エラーが発生します。したがって、最適な共通型はありません。 この場合は、`object[]`する型を指定するなど、明示的に型指定された配列作成式を使用する必要があります。 または、要素の1つを共通の基本型にキャストして、その要素の型が推論されるようにすることもできます。

暗黙的に型指定された配列作成式を匿名オブジェクト初期化子 ([匿名オブジェクト作成式](expressions.md#anonymous-object-creation-expressions)) と組み合わせて、匿名型のデータ構造を作成することができます。 例:
```csharp
var contacts = new[] {
    new {
        Name = "Chris Smith",
        PhoneNumbers = new[] { "206-555-0101", "425-882-8080" }
    },
    new {
        Name = "Bob Harris",
        PhoneNumbers = new[] { "650-555-0199" }
    }
};
```

#### <a name="delegate-creation-expressions"></a>デリゲート作成式

*Delegate_creation_expression*は、 *delegate_type*の新しいインスタンスを作成するために使用されます。

```antlr
delegate_creation_expression
    : 'new' delegate_type '(' expression ')'
    ;
```

デリゲート作成式の引数には、メソッドグループ、匿名関数、またはコンパイル時の型 `dynamic` または*delegate_type*のいずれかの値を指定する必要があります。 引数がメソッドグループの場合、メソッドと、インスタンスメソッドの場合は、デリゲートを作成する対象のオブジェクトを識別します。 引数が匿名関数の場合、デリゲートターゲットのパラメーターとメソッドの本体が直接定義されます。 引数が値の場合は、コピーを作成する対象のデリゲートインスタンスを識別します。

*式*に `dynamic`コンパイル時の型がある場合、 *delegate_creation_expression*は動的にバインドされ ([動的バインディング](expressions.md#dynamic-binding))、次の規則は実行時に*式*の実行時の型を使用して適用されます。 それ以外の場合は、コンパイル時に規則が適用されます。

フォーム `new D(E)`の*delegate_creation_expression*のバインド時の処理。 `D` は*delegate_type*で、`E` は*式*です。は、次の手順で構成されています。

*  `E` がメソッドグループの場合、デリゲート作成式は、メソッドグループの変換 ([メソッドグループ](conversions.md#method-group-conversions)の変換) と同じ方法で `E` から `D`に処理されます。
*  `E` が匿名関数の場合、デリゲート作成式は、匿名関数の変換 ([匿名関数](conversions.md#anonymous-function-conversions)の変換) と同じ方法で、`E` から `D`に処理されます。
*  `E` が値の場合、`E` は `D`と互換性がある ([デリゲート宣言](delegates.md#delegate-declarations)) 必要があります。また、結果は、`E`と同じ呼び出しリストを参照する、`D` 型の新しく作成されたデリゲートへの参照になります。 `E` が `D`と互換性がない場合は、コンパイル時にエラーが発生します。

フォーム `new D(E)`の*delegate_creation_expression*の実行時処理。 `D` は*delegate_type*で、`E` は*式*です。は、次の手順で構成されています。

*   `E` がメソッドグループの場合、デリゲート作成式は、メソッドグループの変換 ([メソッドグループ](conversions.md#method-group-conversions)の変換) として `E` から `D`に評価されます。
*   `E` が匿名関数の場合、デリゲートの作成は、`E` から `D` ([匿名関数の変換](conversions.md#anonymous-function-conversions)) への匿名関数の変換として評価されます。
*   `E` が*delegate_type*の値の場合は、次のようになります。
    * `E` が評価されます。 この評価によって例外が発生した場合、それ以上の手順は実行されません。
    * `E` の値が `null`場合は `System.NullReferenceException` がスローされ、それ以上の手順は実行されません。
    * `D` デリゲート型の新しいインスタンスが割り当てられます。 新しいインスタンスの割り当てに使用できるメモリが不足している場合は、`System.OutOfMemoryException` がスローされ、それ以上の手順は実行されません。
    * `E`によって指定されたデリゲートインスタンスと同じ呼び出しリストを使用して、新しいデリゲートインスタンスが初期化されます。

デリゲートの呼び出しリストは、デリゲートがインスタンス化されるときに決定され、その後、デリゲートの有効期間全体にわたって定数のままになります。 つまり、作成されたデリゲートのターゲット呼び出し可能エンティティを変更することはできません。 2つのデリゲートを結合する場合、または一方を別のデリゲート[宣言 (デリゲート宣言](delegates.md#delegate-declarations)) から削除する場合は、新しいデリゲートの結果はです。既存のデリゲートの内容が変更されていません。

プロパティ、インデクサー、ユーザー定義の演算子、インスタンスコンストラクター、デストラクター、または静的コンストラクターを参照するデリゲートを作成することはできません。

前述のように、メソッドグループからデリゲートを作成すると、デリゲートの仮パラメーターリストと戻り値の型によって、どのオーバーロードされたメソッドを選択するかが決まります。 この例では、
```csharp
delegate double DoubleFunc(double x);

class A
{
    DoubleFunc f = new DoubleFunc(Square);

    static float Square(float x) {
        return x * x;
    }

    static double Square(double x) {
        return x * x;
    }
}
```
`A.f` フィールドは、2番目の `Square` メソッドを参照するデリゲートで初期化されます。これは、そのメソッドが `DoubleFunc`の仮パラメーターリストおよび戻り値の型と完全に一致するためです。 2番目の `Square` メソッドが存在しない場合、コンパイル時エラーが発生しました。

#### <a name="anonymous-object-creation-expressions"></a>匿名オブジェクト作成式

*Anonymous_object_creation_expression*は、匿名型のオブジェクトを作成するために使用されます。

```antlr
anonymous_object_creation_expression
    : 'new' anonymous_object_initializer
    ;

anonymous_object_initializer
    : '{' member_declarator_list? '}'
    | '{' member_declarator_list ',' '}'
    ;

member_declarator_list
    : member_declarator (',' member_declarator)*
    ;

member_declarator
    : simple_name
    | member_access
    | base_access
    | null_conditional_member_access
    | identifier '=' expression
    ;
```

匿名オブジェクト初期化子は、匿名型を宣言し、その型のインスタンスを返します。 匿名型は、`object`から直接継承する無名のクラス型です。 匿名型のメンバーは、型のインスタンスを作成するために使用される匿名オブジェクト初期化子から推論される読み取り専用プロパティのシーケンスです。 具体的には、フォームの匿名オブジェクト初期化子
```csharp
new { p1 = e1, p2 = e2, ..., pn = en }
```
フォームの匿名型を宣言します。
```csharp
class __Anonymous1
{
    private readonly T1 f1;
    private readonly T2 f2;
    ...
    private readonly Tn fn;

    public __Anonymous1(T1 a1, T2 a2, ..., Tn an) {
        f1 = a1;
        f2 = a2;
        ...
        fn = an;
    }

    public T1 p1 { get { return f1; } }
    public T2 p2 { get { return f2; } }
    ...
    public Tn pn { get { return fn; } }

    public override bool Equals(object __o) { ... }
    public override int GetHashCode() { ... }
}
```
各 `Tx` は `ex`対応する式の型です。 *Member_declarator*で使用する式には型が必要です。 したがって、 *member_declarator*内の式が null または匿名関数である場合、コンパイル時エラーになります。 また、式に安全でない型がある場合のコンパイル時エラーでもあります。

匿名型の名前と `Equals` メソッドに対するパラメーターの名前は、コンパイラによって自動的に生成され、プログラムテキストで参照することはできません。

同じプログラム内で、同じ名前の一連のプロパティとコンパイル時の型を同じ順序で指定する2つの匿名オブジェクト初期化子は、同じ匿名型のインスタンスを生成します。

この例では、
```csharp
var p1 = new { Name = "Lawnmower", Price = 495.00 };
var p2 = new { Name = "Shovel", Price = 26.95 };
p1 = p2;
```
`p1` と `p2` が同じ匿名型であるため、最後の行の代入が許可されます。

匿名型の `Equals` および `GetHashcode` メソッドは、`object`から継承されたメソッドをオーバーライドし、プロパティの `Equals` および `GetHashcode` の観点から定義されます。これにより、同じ匿名型の2つのインスタンスが等しい場合に限り、同じ匿名型の2つのインスタンスが等しいようになります。

メンバー宣言子は、単純な名前 (型の[推定](expressions.md#type-inference))、メンバーアクセス ([動的なオーバーロードの解決のコンパイル時のチェック](expressions.md#compile-time-checking-of-dynamic-overload-resolution))、基本アクセス ([基本アクセス](expressions.md#base-access))、または null 条件付きのメンバーアクセス ([プロジェクション初期化子としての null 条件式](expressions.md#null-conditional-expressions-as-projection-initializers)) に省略できます。 これは、***射影初期化子***と呼ばれ、同じ名前を持つプロパティの宣言と代入のための短縮形です。 具体的には、フォームのメンバー宣言子
```csharp
identifier
expr.identifier
```
は、それぞれ次のものに相当します。
```csharp
identifier = identifier
identifier = expr.identifier
```

したがって、プロジェクション初期化子では、値が割り当てられる値とフィールドまたはプロパティの両方が*識別子*によって選択されます。 直感的に言えば、プロジェクション初期化子は、値だけでなく、値の名前でもあります。

### <a name="the-typeof-operator"></a>Typeof 演算子

`typeof` 演算子は、型の `System.Type` オブジェクトを取得するために使用されます。

```antlr
typeof_expression
    : 'typeof' '(' type ')'
    | 'typeof' '(' unbound_type_name ')'
    | 'typeof' '(' 'void' ')'
    ;

unbound_type_name
    : identifier generic_dimension_specifier?
    | identifier '::' identifier generic_dimension_specifier?
    | unbound_type_name '.' identifier generic_dimension_specifier?
    ;

generic_dimension_specifier
    : '<' comma* '>'
    ;

comma
    : ','
    ;
```

*Typeof_expression*の最初の形式は、`typeof` キーワードとそれに続くかっこで囲まれた*型*で構成されます。 この形式の式の結果は、指定された型の `System.Type` オブジェクトです。 指定された型には `System.Type` オブジェクトが1つだけあります。 つまり、型 `T`の場合、`typeof(T) == typeof(T)` は常に true になります。 *型*を `dynamic`にすることはできません。

2番目の形式の*typeof_expression*は、`typeof` キーワードとそれに続くかっこで囲まれた*unbound_type_name*で構成されます。 *Unbound_type_name*は*type_name* ([名前空間と型名](basic-concepts.md#namespace-and-type-names)) と非常によく似ていますが、 *type_name*に*type_argument_list*が含まれる*generic_dimension_specifier*が*unbound_type_name*に含まれている点が異なります。 *Typeof_expression*のオペランドが*unbound_type_name*と*type_name*の両方の文法を満たすトークンのシーケンスである場合、つまり、 *generic_dimension_specifier*も*type_argument_list*も含まれていない場合、トークンのシーケンスは*type_name*と見なされます。 *Unbound_type_name*の意味は、次のように決定されます。

*  各*generic_dimension_specifier*を同じ数のコンマを持つ*type_argument_list*に置き換えることにより、トークンのシーケンスを*type_name*に変換します。各*type_argument*には `object` キーワードを使用します。
*  すべての型パラメーター制約を無視して、結果の*type_name*を評価します。
*  *Unbound_type_name*は、結果の構築された型 ([バインドおよびバインド](types.md#bound-and-unbound-types)解除された型) に関連付けられたバインドされていないジェネリック型に解決されます。

*Typeof_expression*の結果は、結果としてバインドされていないジェネリック型の `System.Type` オブジェクトです。

3番目の形式の*typeof_expression*は、`typeof` キーワードの後にかっこで囲んだ `void` キーワードで構成されます。 この形式の式の結果は、型が存在しないことを表す `System.Type` オブジェクトです。 `typeof(void)` によって返される型オブジェクトは、任意の型に対して返される型オブジェクトとは異なります。 この特別な型のオブジェクトは、言語のメソッドへのリフレクションを可能にするクラスライブラリで役立ちます。これらのメソッドは、void メソッドを含むメソッドの戻り値の型を `System.Type`のインスタンスと共に表す方法を必要とします。

`typeof` 演算子は、型パラメーターで使用できます。 結果として、型パラメーターにバインドされたランタイム型の `System.Type` オブジェクトが生成されます。 `typeof` 演算子は、構築された型またはバインドされていないジェネリック型 ([バインドおよび](types.md#bound-and-unbound-types)バインド解除された型) でも使用できます。 バインドされていないジェネリック型の `System.Type` オブジェクトは、インスタンス型の `System.Type` オブジェクトと同じではありません。 インスタンス型は、実行時に常にクローズ構築型です。そのため、`System.Type` オブジェクトは使用するランタイム型引数に依存しますが、バインドされていないジェネリック型には型引数がありません。

例
```csharp
using System;

class X<T>
{
    public static void PrintTypes() {
        Type[] t = {
            typeof(int),
            typeof(System.Int32),
            typeof(string),
            typeof(double[]),
            typeof(void),
            typeof(T),
            typeof(X<T>),
            typeof(X<X<T>>),
            typeof(X<>)
        };
        for (int i = 0; i < t.Length; i++) {
            Console.WriteLine(t[i]);
        }
    }
}

class Test
{
    static void Main() {
        X<int>.PrintTypes();
    }
}
```
では、次の出力が生成されます。
```console
System.Int32
System.Int32
System.String
System.Double[]
System.Void
System.Int32
X`1[System.Int32]
X`1[X`1[System.Int32]]
X`1[T]
```

`int` と `System.Int32` は同じ型であることに注意してください。

また、`typeof(X<>)` の結果は型引数に依存しないことに注意してくださいが、`typeof(X<T>)` の結果は異なります。

### <a name="the-checked-and-unchecked-operators"></a>checked 演算子と unchecked 演算子

`checked` 演算子と `unchecked` 演算子を使用して、整数型の算術演算および変換の***オーバーフローチェックコンテキスト***を制御します。

```antlr
checked_expression
    : 'checked' '(' expression ')'
    ;

unchecked_expression
    : 'unchecked' '(' expression ')'
    ;
```

`checked` 演算子は checked コンテキストで含まれている式を評価し、`unchecked` 演算子は、チェックされていないコンテキストで含まれている式を評価します。 *Checked_expression*または*unchecked_expression*は、指定されたオーバーフローチェックコンテキストで含まれる式が評価される点を除いて、 *parenthesized_expression* ([かっこで囲ま](expressions.md#parenthesized-expressions)れた式) と正確に対応します。

オーバーフローチェックコンテキストは、`checked` および `unchecked` ステートメント ([checked ステートメントと unchecked ステートメント](statements.md#the-checked-and-unchecked-statements)) を使用して制御することもできます。

次の操作は、`checked` によって確立されたオーバーフローチェックコンテキストと `unchecked` の演算子およびステートメントによって影響を受けます。

*  オペランドが整数型の場合、定義済みの `++` と `--` の単項演算子 ([後置インクリメントおよびデクリメント演算子](expressions.md#postfix-increment-and-decrement-operators)、[前置インクリメントおよびデクリメント演算子](expressions.md#prefix-increment-and-decrement-operators))。
*  オペランドが整数型の場合、定義済みの `-` 単項演算子 ([単項マイナス演算子](expressions.md#unary-minus-operator))。
*  両方のオペランドが整数型の場合、定義済みの `+`、`-`、`*`、および `/` 二項演算子 ([算術演算子](expressions.md#arithmetic-operators))。
*  ある整数型から別の整数型へ、または `float` または `double` から整数型への明示的な数値変換 ([明示的な数値変換](conversions.md#explicit-numeric-conversions))。

上記のいずれかの操作によって、変換先の型で表現するには大きすぎる結果が生成された場合、演算が実行されるコンテキストによって結果の動作が制御されます。

*  `checked` コンテキストでは、操作が定数式 ([定数式](expressions.md#constant-expressions)) の場合、コンパイル時エラーが発生します。 それ以外の場合、実行時に操作が実行されると、`System.OverflowException` がスローされます。
*  `unchecked` のコンテキストでは、変換先の型に適合しない上位ビットを破棄することによって結果が切り捨てられます。

`checked` または `unchecked` の演算子またはステートメントでは囲まれていない非定数式 (実行時に評価される式) の場合、`checked` 評価のために外部要因 (コンパイラスイッチや実行環境の構成など) が呼び出されない限り、既定のオーバーフローチェックコンテキストは `unchecked` ます。

定数式 (コンパイル時に完全に評価できる式) の場合、既定のオーバーフローチェックコンテキストは常に `checked`ます。 定数式が `unchecked` コンテキストに明示的に配置されていない限り、式のコンパイル時の評価中にオーバーフローが発生すると、常にコンパイル時エラーが発生します。

匿名関数の本体は、匿名関数が発生する `checked` または `unchecked` のコンテキストの影響を受けません。

この例では、
```csharp
class Test
{
    static readonly int x = 1000000;
    static readonly int y = 1000000;

    static int F() {
        return checked(x * y);      // Throws OverflowException
    }

    static int G() {
        return unchecked(x * y);    // Returns -727379968
    }

    static int H() {
        return x * y;               // Depends on default
    }
}
```
コンパイル時のエラーは報告されません。コンパイル時に式を評価することはできません。 実行時には、`F` メソッドによって `System.OverflowException`がスローされ、`G` メソッドによって-727379968 (範囲外の結果の下位32ビット) が返されます。 `H` メソッドの動作は、コンパイルの既定のオーバーフローチェックコンテキストによって異なりますが、`F` または `G`と同じです。

この例では、
```csharp
class Test
{
    const int x = 1000000;
    const int y = 1000000;

    static int F() {
        return checked(x * y);      // Compile error, overflow
    }

    static int G() {
        return unchecked(x * y);    // Returns -727379968
    }

    static int H() {
        return x * y;               // Compile error, overflow
    }
}
```
`F` および `H` の定数式を評価するときにオーバーフローが発生すると、式は `checked` コンテキストで評価されるため、コンパイル時のエラーが報告されます。 `G`で定数式を評価するときにもオーバーフローが発生しますが、評価は `unchecked` のコンテキストで行われるため、オーバーフローは報告されません。

`checked` 演算子と `unchecked` 演算子は、"`(`" トークンと "`)`" トークンに含まれる操作のオーバーフローチェックコンテキストにのみ影響します。 演算子は、含まれている式を評価した結果として呼び出される関数メンバーには影響しません。 この例では、
```csharp
class Test
{
    static int Multiply(int x, int y) {
        return x * y;
    }

    static int F() {
        return checked(Multiply(1000000, 1000000));
    }
}
```
`F` での `checked` の使用は `Multiply`の `x * y` の評価には影響しないため、既定のオーバーフローチェックコンテキストで `x * y` が評価されます。

`unchecked` 演算子は、符号付き整数型の定数を16進表記で記述する場合に便利です。 例:
```csharp
class Test
{
    public const int AllBits = unchecked((int)0xFFFFFFFF);

    public const int HighBit = unchecked((int)0x80000000);
}
```

上記の16進定数はどちらも `uint`型です。 定数は `int` 範囲の外側にあり、`unchecked` 演算子を使用しないと、`int` するキャストによってコンパイル時エラーが発生します。

`checked` および `unchecked` の演算子とステートメントを使用すると、プログラマはいくつかの数値計算の特定の側面を制御できます。 ただし、一部の数値演算子の動作は、そのオペランドのデータ型によって異なります。 たとえば、2つの10進数を乗算すると、明示的な `unchecked` コンストラクト内であってもオーバーフローでは例外が発生します。 同様に、2つの浮動小数点数を乗算しても、明示的な `checked` コンストラクト内であってもオーバーフローで例外が発生することはありません。 また、他の演算子は、既定でも明示的でも、チェックモードの影響を受けません。

### <a name="default-value-expressions"></a>既定値の式

既定値の式は、型の既定値 ([既定](variables.md#default-values)値) を取得するために使用されます。 通常、型パラメーターには既定値式が使用されます。これは、型パラメーターが値型または参照型であるかどうかが不明な場合があるためです。 (型パラメーターが参照型であることがわかっている場合を除き、`null` リテラルから型パラメーターへの変換は存在しません)。

```antlr
default_value_expression
    : 'default' '(' type ')'
    ;
```

*Default_value_expression*の*型*が実行時に参照型に評価される場合、結果はその型に変換 `null` れます。 *Default_value_expression*の*型*が実行時に値型に評価される場合、結果は*Value_type*の既定値 ([既定のコンストラクター](types.md#default-constructors)) になります。

型が参照型または参照型であることがわかっている型パラメーター ([型パラメーターの制約](classes.md#type-parameter-constraints)) の場合、 *default_value_expression*は定数式 ([定数式](expressions.md#constant-expressions)) です。 また、型が `sbyte`、`byte`、`short`、`ushort`、`int`、`uint`、`long`、`ulong`、`char`、`float`、`double`、`decimal`、`bool`、または任意の列挙型のいずれかの値型の場合、 *default_value_expression*は定数式です。


### <a name="nameof-expressions"></a>すべてのの表記

*Nameof_expression*は、プログラムエンティティの名前を定数文字列として取得するために使用されます。

```antlr
nameof_expression
    : 'nameof' '(' named_entity ')'
    ;

named_entity
    : simple_name
    | named_entity_target '.' identifier type_argument_list?
    ;

named_entity_target
    : 'this'
    | 'base'
    | named_entity 
    | predefined_type 
    | qualified_alias_member
    ;
```

文法的に言えば、 *named_entity*のオペランドは常に式です。 `nameof` は予約されたキーワードではないため、名前の単純な名前 `nameof`の呼び出しによって、名前の指定式は常に構文的にあいまいになります。 互換性の理由により、名前の名前の参照 ([簡易名](expressions.md#simple-names)) が成功した場合、呼び出しが有効であるかどうかに関係なく、式は*invocation_expression*として扱われます。 `nameof`。 それ以外の場合は、 *nameof_expression*になります。

*Nameof_expression*の*named_entity*の意味は、式として意味があります。つまり、 *simple_name*、 *base_access*または*member_access*のいずれかになります。 ただし、[単純名](expressions.md#simple-names)と[メンバーアクセス](expressions.md#member-access)で説明されている参照では、インスタンスメンバーが静的コンテキストで見つかったため、エラーが発生します。 *nameof_expression*では、このようなエラーは発生しません。

メソッドグループに*type_argument_list*が指定されている*named_entity*は、コンパイル時にエラーになります。 *Named_entity_target*が型 `dynamic`を持つ場合、コンパイル時エラーになります。

*Nameof_expression*は `string`型の定数式であり、実行時には効果がありません。 具体的には、その*named_entity*は評価されず、明確な代入分析 ([単純式の一般的な規則](variables.md#general-rules-for-simple-expressions)) のために無視されます。 この値は、省略可能な最終*type_argument_list*の前の*named_entity*の最後の識別子で、次のように変換されます。

* プレフィックス "`@`" (使用されている場合) は削除されます。
* 各*unicode_escape_sequence*は、対応する unicode 文字に変換されます。
* *Formatting_characters*はすべて削除されます。

これらは、識別子が等しいかどうかをテストするときに[識別子](lexical-structure.md#identifiers)に適用される変換と同じです。

TODO: 例

### <a name="anonymous-method-expressions"></a>匿名メソッドの式

*Anonymous_method_expression*は、匿名関数を定義する2つの方法のうちの1つです。 これらの詳細については、「[匿名関数の式](expressions.md#anonymous-function-expressions)」を参照してください。

## <a name="unary-operators"></a>単項演算子

`?`、`+`、`-`、`!`、`~`、`++`、`--`、cast、および `await` の各演算子を単項演算子と呼びます。

```antlr
unary_expression
    : primary_expression
    | null_conditional_expression
    | '+' unary_expression
    | '-' unary_expression
    | '!' unary_expression
    | '~' unary_expression
    | pre_increment_expression
    | pre_decrement_expression
    | cast_expression
    | await_expression
    | unary_expression_unsafe
    ;
```

*Unary_expression*のオペランドにコンパイル時の型 `dynamic`がある場合、そのオペランドは動的にバインドされます ([動的バインド](expressions.md#dynamic-binding))。 この場合、 *unary_expression*のコンパイル時の型が `dynamic`、次に示す解決方法は、実行時にオペランドの実行時の型を使用して行われます。

### <a name="null-conditional-operator"></a>Null 条件演算子

Null 条件演算子では、オペランドが null 以外の場合にのみ、演算のリストがオペランドに適用されます。 それ以外の場合、演算子を適用した結果が `null`されます。

```antlr
null_conditional_expression
    : primary_expression null_conditional_operations
    ;

null_conditional_operations
    : null_conditional_operations? '?' '.' identifier type_argument_list?
    | null_conditional_operations? '?' '[' argument_list ']'
    | null_conditional_operations '.' identifier type_argument_list?
    | null_conditional_operations '[' argument_list ']'
    | null_conditional_operations '(' argument_list? ')'
    ;
```

操作の一覧には、メンバーアクセスと要素アクセス操作 (それ自体が null 条件の場合もあります)、および呼び出しを含めることができます。

たとえば、`a.b?[0]?.c()` 式は、 *primary_expression* `a.b` *、null_conditional_operations (* null 条件要素アクセス)、`?[0]` (null 条件メンバーアクセス)、`?.c` (呼び出し) を持つ*null_conditional_expression*です。

*Primary_expression* `P`の*null_conditional_expression* `E` については、`E0` を持つ `?` の各*null_conditional_operations*から先頭の `E` を削除することによって得られる式にすることができます。 概念的には、`E0` は、`?`によって表される null チェックに `null`が見つからない場合に評価される式です。

また、`E`内の最初の*null_conditional_operations*から先頭の `?` を削除することによって得られる式を `E1` します。 これに*より、プライマリ式*(`?`が1つだけの場合) または別の*null_conditional_expression*が発生する可能性があります。

たとえば、`E` が式 `a.b?[0]?.c()`の場合、`E0` は式 `a.b[0].c()`、`E1` は式 `a.b[0]?.c()`です。

`E0` が何も分類されていない場合、`E` は nothing として分類されます。 それ以外の場合、E は値として分類されます。

`E0` と `E1` は、`E`の意味を決定するために使用されます。

*  `E` が*statement_expression*として発生した場合、`E` の意味は、ステートメントと同じです。

   ```csharp
   if ((object)P != null) E1;
   ```

   ただし、P は1回だけ評価されます。

*  それ以外の場合、`E0` が何も分類されていないと、コンパイル時エラーが発生します。

*  それ以外の場合は `T0` `E0`の型にします。

   *  `T0` が参照型または null 非許容の値型として認識されない型パラメーターである場合、コンパイル時エラーが発生します。

   *  `T0` が null 非許容の値型である場合、`E` の種類は `T0?`、`E` の意味は次のようになります。

      ```csharp
      ((object)P == null) ? (T0?)null : E1
      ```

      ただし、`P` は1回だけ評価されます。

   *  それ以外の場合、E の型は T0 になり、E の意味はと同じになります。

      ```csharp
      ((object)P == null) ? null : E1
      ```

      ただし、`P` は1回だけ評価されます。

`E1` がそれ自体が*null_conditional_expression*である場合は、これらの規則が再度適用され、それ以上 `?`がなくなるまで `null` のテストが入れ子になり、式はすべてプライマリ式の `E0`まで縮小されます。

たとえば、次のステートメントのように、式 `a.b?[0]?.c()` がステートメント式として出現する場合です。
```csharp
a.b?[0]?.c();
```
その意味は、次の場合と同じです。
```csharp
if (a.b != null) a.b[0]?.c();
```
これは、次の場合と同じです。
```csharp
if (a.b != null) if (a.b[0] != null) a.b[0].c();
```
ただし、`a.b` と `a.b[0]` は1回だけ評価されます。

次のように、その値が使用されているコンテキストで発生する場合:
```csharp
var x = a.b?[0]?.c();
```
最後の呼び出しの型が null 非許容の値型ではないと仮定した場合、その意味は次のようになります。
```csharp
var x = (a.b == null) ? null : (a.b[0] == null) ? null : a.b[0].c();
```
ただし、`a.b` と `a.b[0]` は1回だけ評価されます。

#### <a name="null-conditional-expressions-as-projection-initializers"></a>Null 条件式 (プロジェクション初期化子としての)

Null 条件式は、(必要に応じて null 条件付き) メンバーアクセスで終了する場合にのみ、 *anonymous_object_creation_expression* ([匿名オブジェクト作成式](expressions.md#anonymous-object-creation-expressions)) の*member_declarator*としてのみ使用できます。 文法的には、この要件は次のように表現できます。

```antlr
null_conditional_member_access
    : primary_expression null_conditional_operations? '?' '.' identifier type_argument_list?
    | primary_expression null_conditional_operations '.' identifier type_argument_list?
    ;
```

これは、上記の*null_conditional_expression*の文法の特殊なケースです。 [匿名オブジェクト作成式](expressions.md#anonymous-object-creation-expressions)の*member_declarator*の実稼働には、 *null_conditional_member_access*のみが含まれます。

#### <a name="null-conditional-expressions-as-statement-expressions"></a>ステートメント式としての Null 条件式

Null 条件式は、呼び出しで終了した場合にのみ*statement_expression* ([式ステートメント](statements.md#expression-statements)) として使用できます。 文法的には、この要件は次のように表現できます。

```antlr
null_conditional_invocation_expression
    : primary_expression null_conditional_operations '(' argument_list? ')'
    ;
```

これは、上記の*null_conditional_expression*の文法の特殊なケースです。 [式ステートメント](statements.md#expression-statements)内の*statement_expression*の実稼働には、 *null_conditional_invocation_expression*のみが含まれます。


### <a name="unary-plus-operator"></a>単項プラス演算子

`+x`フォームの操作では、単項演算子のオーバーロードの解決 ([単項演算子のオーバーロードの解決](expressions.md#unary-operator-overload-resolution)) が適用され、特定の演算子の実装を選択します。 オペランドは選択された演算子のパラメーターの型に変換され、結果の型は演算子の戻り値の型になります。 定義済みの単項プラス演算子は次のとおりです。

```csharp
int operator +(int x);
uint operator +(uint x);
long operator +(long x);
ulong operator +(ulong x);
float operator +(float x);
double operator +(double x);
decimal operator +(decimal x);
```

これらの各演算子について、結果は単純にオペランドの値になります。

### <a name="unary-minus-operator"></a>単項マイナス演算子

`-x`フォームの操作では、単項演算子のオーバーロードの解決 ([単項演算子のオーバーロードの解決](expressions.md#unary-operator-overload-resolution)) が適用され、特定の演算子の実装を選択します。 オペランドは選択された演算子のパラメーターの型に変換され、結果の型は演算子の戻り値の型になります。 定義済みの否定演算子は次のとおりです。

*  整数の否定:

   ```csharp
   int operator -(int x);
   long operator -(long x);
   ```

   結果は、0から `x` を減算することによって計算されます。 `x` の値がオペランド型の最小表現可能値 (`int` の場合は-2 ^ 31、`long`の場合は-2 ^ 63) である場合、`x` の算術否定はオペランド型では表現できません。 これが `checked` コンテキスト内で発生すると、`System.OverflowException` がスローされます。`unchecked` のコンテキスト内で発生した場合、結果はオペランドの値になり、オーバーフローは報告されません。

   否定演算子のオペランドが `uint`型である場合は、型 `long`に変換され、結果の型は `long`になります。 例外として、`int` 値-2147483648 (-2 ^ 31) を10進整数リテラル ([整数リテラル](lexical-structure.md#integer-literals)) として書き込むことを許可するルールがあります。

   否定演算子のオペランドが `ulong`型である場合、コンパイル時エラーが発生します。 例外として、`long` 値-9223372036854775808 (-2 ^ 63) を10進数の整数リテラル ([整数リテラル](lexical-structure.md#integer-literals)) として書き込むことを許可するルールがあります。

*  浮動小数点否定:

   ```csharp
   float operator -(float x);
   double operator -(double x);
   ```

   結果は、符号が反転された `x` の値になります。 `x` が NaN の場合、結果は NaN にもなります。

*  10進数の否定:

   ```csharp
   decimal operator -(decimal x);
   ```

   結果は、0から `x` を減算することによって計算されます。 10進数の否定は、`System.Decimal`型の単項マイナス演算子を使用することと同じです。

### <a name="logical-negation-operator"></a>論理否定演算子

`!x`フォームの操作では、単項演算子のオーバーロードの解決 ([単項演算子のオーバーロードの解決](expressions.md#unary-operator-overload-resolution)) が適用され、特定の演算子の実装を選択します。 オペランドは選択された演算子のパラメーターの型に変換され、結果の型は演算子の戻り値の型になります。 定義済みの論理否定演算子は1つだけ存在します。
```csharp
bool operator !(bool x);
```

この演算子は、オペランドの論理否定を計算します。オペランドが `true`場合、結果は `false`になります。 オペランドが `false`場合、結果は `true`になります。

### <a name="bitwise-complement-operator"></a>ビットごとの補数演算子

`~x`フォームの操作では、単項演算子のオーバーロードの解決 ([単項演算子のオーバーロードの解決](expressions.md#unary-operator-overload-resolution)) が適用され、特定の演算子の実装を選択します。 オペランドは選択された演算子のパラメーターの型に変換され、結果の型は演算子の戻り値の型になります。 定義済みのビットごとの補数演算子は次のとおりです。
```csharp
int operator ~(int x);
uint operator ~(uint x);
long operator ~(long x);
ulong operator ~(ulong x);
```

操作の結果は、これらの各演算子について、`x`のビットごとの補数となります。

すべての列挙型 `E` は、暗黙的に次のビットごとの補数演算子を提供します。

```csharp
E operator ~(E x);
```

`~x`を評価した結果 `x` は、基になる型 `U`の列挙 `E` 型の式であり、`(E)(~(U)x)`への変換が `E` のコンテキスト ([checked および unchecked 演算子](expressions.md#the-checked-and-unchecked-operators)) の場合と同じように実行される点を除き、`unchecked` の評価とまったく同じです。

### <a name="prefix-increment-and-decrement-operators"></a>前置インクリメント演算子と前置デクリメント演算子

```antlr
pre_increment_expression
    : '++' unary_expression
    ;

pre_decrement_expression
    : '--' unary_expression
    ;
```

前置インクリメントまたはデクリメント演算のオペランドは、変数、プロパティアクセス、またはインデクサーアクセスとして分類される式である必要があります。 演算の結果は、オペランドと同じ型の値になります。

前置インクリメントまたはデクリメント演算のオペランドがプロパティまたはインデクサーアクセスの場合、プロパティまたはインデクサーには、`get` と `set` の両方のアクセサーが必要です。 そうでない場合は、バインド時エラーが発生します。

単項演算子のオーバーロードの解決 ([単項演算子のオーバーロードの解決](expressions.md#unary-operator-overload-resolution)) は、特定の演算子の実装を選択するために適用されます。 定義済みの `++` と `--` の演算子は、`sbyte`、`byte`、`short`、`ushort`、`int`、`uint`、`long`、`ulong`、`char`、`float`、`double`、`decimal`、列挙型の各型に存在します。 定義済みの `++` 演算子は、オペランドに1を加算して生成された値を返します。定義済みの `--` 演算子は、オペランドから1を減算して生成された値を返します。 `checked` コンテキストでは、この加算または減算の結果が結果型の範囲外で、結果型が整数型または列挙型の場合、`System.OverflowException` がスローされます。

`++x` または `--x` フォームのプレフィックスインクリメントまたはデクリメント操作の実行時処理は、次の手順で構成されています。

*   `x` が変数として分類される場合は、次のようになります。
    * 変数を生成するために `x` が評価されます。
    * 選択した演算子は、引数として `x` の値を使用して呼び出されます。
    * 演算子によって返される値は、`x`の評価によって指定された場所に格納されます。
    * 演算子によって返される値は、操作の結果になります。
*   `x` がプロパティまたはインデクサーアクセスとして分類される場合は、次のようになります。
    * インスタンス式 (`x` が `static`でない場合) と `x` に関連付けられている引数リスト (`x` がインデクサーアクセスの場合) が評価され、その結果が後続の `get` および `set` アクセサー呼び出しで使用されます。
    * `x` の `get` アクセサーが呼び出されます。
    * 選択した演算子は、引数として `get` アクセサーによって返された値を使用して呼び出されます。
    * `x` の `set` アクセサーは、`value` 引数として演算子によって返された値を使用して呼び出されます。
    * 演算子によって返される値は、操作の結果になります。

`++` 演算子と `--` 演算子は、後置表記 ([後置インクリメントおよびデクリメント演算子](expressions.md#postfix-increment-and-decrement-operators)) もサポートしています。 通常、`x++` または `x--` の結果は、操作の前の `x` の値になります。一方、`++x` または `--x` の結果は、操作後の `x` の値になります。 どちらの場合も、`x` 自体の値は、操作の後で同じになります。

`operator++` または `operator--` の実装は、後置表記またはプレフィックス表記のいずれかを使用して呼び出すことができます。 2つの表記に対して個別の演算子を実装することはできません。

### <a name="cast-expressions"></a>キャスト式

*Cast_expression*は、式を指定した型に明示的に変換するために使用されます。

```antlr
cast_expression
    : '(' type ')' unary_expression
    ;
```

フォーム `(T)E`の*cast_expression* 。 `T` は*型*で `E` は*unary_expression*であり、`E` の値の明示的な変換 ([明示的な変換](conversions.md#explicit-conversions)) を実行して `T`を入力します。 `E` から `T`への明示的な変換が存在しない場合は、バインド時エラーが発生します。 それ以外の場合、結果は明示的な変換によって生成される値になります。 `E` が変数を表している場合でも、結果は常に値として分類されます。

*Cast_expression*の文法によって、特定の構文のあいまいさが生じます。 たとえば、式 `(x)-y` は、 *cast_expression* (型 `x`に `-y` をキャスト) として解釈するか、additive_expression*と組み合わせて parenthesized_expression (* 値 *`x - y)`を計算*することができます。

*Cast_expression*のあいまいさを解決するために、次の規則が存在します。かっこで囲まれた1つ以上の*トークン*s ([空白](lexical-structure.md#white-space)) のシーケンスは、次のいずれかが true の場合にのみ、 *cast_expression*の開始と見なされます。

*  トークンのシーケンスは、*型*の正しい文法ですが、*式*には対応していません。
*  トークンのシーケンスは、*型*の正しい文法です。閉じかっこの直後に続くトークンは、トークン "`~`"、トークン "`!`"、トークン "`(`"、*識別子*([Unicode 文字のエスケープシーケンス](lexical-structure.md#unicode-character-escape-sequences))、*リテラル*([リテラル](lexical-structure.md#literals))、または `as` および `is`を除く任意の*キーワード*([キーワード](lexical-structure.md#keywords)) です。

上記の "正しい文法" という用語は、トークンのシーケンスが、特定の文章の作成に準拠している必要があることを意味します。 具体的には、構成要素の実際の意味は考慮されません。 たとえば、`x` と `y` が識別子の場合、`x.y` が実際に型を表していない場合でも、`x.y` は型の正しい文法です。

これは、`x` と `y` が識別子である場合、`(x)y`、`(x)(y)`、および `(x)(-y)` が*cast_expression*であるにもかかわらず、`(x)-y` が型を識別する場合でも、この規則に従っています。 ただし、`x` が定義済みの型 (`int`など) を識別するキーワードである場合、4つのすべての形式が*cast_expression*ます (このようなキーワードは、式自体ではない可能性があります)。

### <a name="await-expressions"></a>Await 式

Await 演算子は、オペランドによって表される非同期操作が完了するまで、外側の非同期関数の評価を中断するために使用されます。

```antlr
await_expression
    : 'await' unary_expression
    ;
```

*Await_expression*は、非同期関数 ([反復子](classes.md#iterators)) の本体でのみ使用できます。 最も近い外側の非同期関数内では、次の場所では*await_expression*が発生しない可能性があります。

*  入れ子になった (非同期ではない) 匿名関数内
*  *Lock_statement*のブロック内
*  Unsafe コンテキスト内

*Await_expression*は、非同期のラムダ式を使用するように構文的に変換されるため、 *query_expression*内のほとんどの場所では発生しないことに注意してください。

非同期関数の内部では、`await` を識別子として使用することはできません。 したがって、await 式と、識別子を含むさまざまな式の間に構文のあいまいさはありません。 非同期関数の外部では、`await` は通常の識別子として機能します。

*Await_expression*のオペランドは***タスク***と呼ばれます。 これは、 *await_expression*の評価時に完了しない可能性のある非同期操作を表します。 Await 演算子の目的は、待機中のタスクが完了するまで、外側の非同期関数の実行を中断し、その結果を取得することです。

#### <a name="awaitable-expressions"></a>待機可能式

Await 式のタスクは、***待機可能***である必要があります。 次のいずれかの場合、式 `t` は待機可能です。

*  `t` コンパイル時の型 `dynamic`
*  `t` には、`GetAwaiter` と呼ばれるアクセス可能なインスタンスまたは拡張メソッドがありますが、パラメーターがなく、型パラメーターもありません。戻り値の型 `A` は、次のすべてのを保持します。
   * `A` はインターフェイス `System.Runtime.CompilerServices.INotifyCompletion` を実装します (これは、簡潔に `INotifyCompletion` として知られています)。
   * `A` には、型の `IsCompleted` アクセス可能で読み取り可能なインスタンスプロパティがあり `bool`
   * `A` には、パラメーターを持たず、型パラメーターを持たない、アクセス可能なインスタンスメソッド `GetResult` があります

`GetAwaiter` メソッドの目的は、タスクの***awaiter***を取得することです。 `A` 型は、await 式の***awaiter 型***と呼ばれます。

`IsCompleted` プロパティの目的は、タスクが既に完了しているかどうかを判断することです。 その場合は、評価を中断する必要はありません。

`INotifyCompletion.OnCompleted` メソッドの目的は、タスクに "継続" をサインアップすることです。つまり、タスクが完了した後に呼び出されるデリゲート (型 `System.Action`)。

`GetResult` メソッドの目的は、完了後にタスクの結果を取得することです。 この結果は、正常に完了している可能性があります (結果値がある場合もあります)。または、`GetResult` メソッドによってスローされる例外の場合もあります。

#### <a name="classification-of-await-expressions"></a>Await 式の分類

式 `await t` は、式 `(t).GetAwaiter().GetResult()`と同じように分類されます。 したがって、`GetResult` の戻り値の型が `void`場合、 *await_expression*は nothing として分類されます。 `T`void 以外の戻り値の型がある場合、 *await_expression*は `T`型の値として分類されます。

#### <a name="runtime-evaluation-of-await-expressions"></a>Await 式のランタイム評価

実行時に `await t` 式は次のように評価されます。

*  式 `(t).GetAwaiter()`を評価することによって、awaiter `a` を取得します。
*  `bool` `b` は、式 `(a).IsCompleted`を評価することによって取得されます。
*  `b` が `false` 場合、評価は `a` がインターフェイス `System.Runtime.CompilerServices.ICriticalNotifyCompletion` を実装しているかどうかによって異なります (簡潔にするために `ICriticalNotifyCompletion` として知られています)。 このチェックは、バインド時に行われます。つまり、`a` がコンパイル時の型 `dynamic`であり、コンパイル時にそれ以外の場合は、実行時に実行されます。 再開デリゲート ([反復子](classes.md#iterators)) を示す `r` を使用します。
    * `a` が `ICriticalNotifyCompletion`を実装していない場合は、式 `(a as (INotifyCompletion)).OnCompleted(r)` が評価されます。
    * `a` が `ICriticalNotifyCompletion`を実装している場合、式 `(a as (ICriticalNotifyCompletion)).UnsafeOnCompleted(r)` が評価されます。
    * その後、評価は中断され、非同期関数の現在の呼び出し元に制御が返されます。
*  の直後 (`b` が `true`の場合)、または後で再開デリゲートを呼び出したとき (`b` が `false`の場合)、式 `(a).GetResult()` が評価されます。 値が返された場合、その値は*await_expression*の結果になります。 それ以外の場合、結果は nothing です。

インターフェイスメソッド `INotifyCompletion.OnCompleted` および `ICriticalNotifyCompletion.UnsafeOnCompleted` の awaiter の実装では、デリゲート `r` を最大で1回呼び出す必要があります。 それ以外の場合、外側の非同期関数の動作は未定義です。

## <a name="arithmetic-operators"></a>算術演算子

`*`、`/`、`%`、`+`、および `-` の各演算子は、算術演算子と呼ばれます。

```antlr
multiplicative_expression
    : unary_expression
    | multiplicative_expression '*' unary_expression
    | multiplicative_expression '/' unary_expression
    | multiplicative_expression '%' unary_expression
    ;

additive_expression
    : multiplicative_expression
    | additive_expression '+' multiplicative_expression
    | additive_expression '-' multiplicative_expression
    ;
```

算術演算子のオペランドに `dynamic`コンパイル時の型がある場合、式は動的にバインドされます ([動的バインド](expressions.md#dynamic-binding))。 この場合、式のコンパイル時の型は `dynamic`であり、以下に示す解決方法は、コンパイル時の型 `dynamic`を持つオペランドの実行時の型を使用して実行時に実行されます。

### <a name="multiplication-operator"></a>乗算演算子

`x * y`フォームの操作では、二項演算子のオーバーロードの解決 ([二項演算子のオーバーロードの解決](expressions.md#binary-operator-overload-resolution)) が適用され、特定の演算子の実装を選択します。 オペランドは選択した演算子のパラメーターの型に変換され、結果の型は演算子の戻り値の型になります。

定義済みの乗算演算子を以下に示します。 すべての演算子は、`x` と `y`の積を計算します。

*  整数乗算:

   ```csharp
   int operator *(int x, int y);
   uint operator *(uint x, uint y);
   long operator *(long x, long y);
   ulong operator *(ulong x, ulong y);
   ```

   `checked` コンテキストでは、製品が結果の型の範囲外の場合、`System.OverflowException` がスローされます。 `unchecked` のコンテキストでは、オーバーフローは報告されず、結果の型の範囲外の重要な上位ビットはすべて破棄されます。


*  浮動小数点乗算:

   ```csharp
   float operator *(float x, float y);
   double operator *(double x, double y);
   ```

   この製品は、IEEE 754 算術のルールに従って計算されます。 次の表に、0以外の有限値 (0、無限大、および NaN) のすべての可能な組み合わせの結果を示します。 テーブルでは、`x` と `y` が正の有限値になります。 `z` は `x * y`の結果です。 結果が変換先の型に対して大きすぎる場合、`z` は無限大です。 結果が変換先の型に対して小さすぎる場合、`z` は0になります。

   |      |      |      |     |     |      |      |     |
   |:----:|-----:|:----:|:---:|:---:|:----:|:----:|:----|
   |      | +y   | -y   | +0  | 横-0  | +inf | -inf | NaN | 
   | +x   | \+ z   | -z   | +0  | 横-0  | +inf | -inf | NaN | 
   | -x   | -z   | \+ z   | 横-0  | +0  | -inf | +inf | NaN | 
   | +0   | +0   | 横-0   | +0  | 横-0  | NaN  | NaN  | NaN | 
   | 横-0   | 横-0   | +0   | 横-0  | +0  | NaN  | NaN  | NaN | 
   | +inf | +inf | -inf | NaN | NaN | +inf | -inf | NaN | 
   | -inf | -inf | +inf | NaN | NaN | -inf | +inf | NaN | 
   | NaN  | NaN  | NaN  | NaN | NaN | NaN  | NaN  | NaN | 

*  10進数の乗算:

   ```csharp
   decimal operator *(decimal x, decimal y);
   ```

   結果の値が大きすぎて `decimal` 形式で表現できない場合は、`System.OverflowException` がスローされます。 結果値が小さすぎて `decimal` 形式で表現できない場合、結果は0になります。 結果の小数点以下桁数は、2つのオペランドのスケールの合計になります。

   Decimal 型の乗算は、`System.Decimal`型の乗算演算子を使用することと同じです。


### <a name="division-operator"></a>除算演算子

`x / y`フォームの操作では、二項演算子のオーバーロードの解決 ([二項演算子のオーバーロードの解決](expressions.md#binary-operator-overload-resolution)) が適用され、特定の演算子の実装を選択します。 オペランドは選択した演算子のパラメーターの型に変換され、結果の型は演算子の戻り値の型になります。

定義済みの除算演算子を以下に示します。 すべての演算子は、`x` と `y`の商を計算します。

*  整数除算:

   ```csharp
   int operator /(int x, int y);
   uint operator /(uint x, uint y);
   long operator /(long x, long y);
   ulong operator /(ulong x, ulong y);
   ```

   右オペランドの値が0の場合は、`System.DivideByZeroException` がスローされます。

   除算は、結果を0方向に丸めます。 したがって、結果の絶対値は、2つのオペランドの商の絶対値以下の最大の整数になります。 2つのオペランドの符号が逆の場合、結果は0または正になります。

   左側のオペランドが表現可能な最小 `int` または `long` 値で、右オペランドが `-1`の場合は、オーバーフローが発生します。 `checked` コンテキストでは、これにより `System.ArithmeticException` (またはサブクラス) がスローされます。 `unchecked` のコンテキストでは、`System.ArithmeticException` (またはサブクラス) がスローされるか、または、結果の値が左オペランドの値であることを示すオーバーフローが報告されます。

*  浮動小数点除算:

   ```csharp
   float operator /(float x, float y);
   double operator /(double x, double y);
   ```

   商は、IEEE 754 算術のルールに従って計算されます。 次の表に、0以外の有限値 (0、無限大、および NaN) のすべての可能な組み合わせの結果を示します。 テーブルでは、`x` と `y` が正の有限値になります。 `z` は `x / y`の結果です。 結果が変換先の型に対して大きすぎる場合、`z` は無限大です。 結果が変換先の型に対して小さすぎる場合、`z` は0になります。

   |      |      |      |      |      |      |      |      |
   |:----:|:----:|:----:|:----:|:----:|:----:|:----:|:----:|
   |      | +y   | -y   | +0   | 横-0   | +inf | -inf | NaN  | 
   | +x   | \+ z   | -z   | +inf | -inf | +0   | 横-0   | NaN  | 
   | -x   | -z   | \+ z   | -inf | +inf | 横-0   | +0   | NaN  | 
   | +0   | +0   | 横-0   | NaN  | NaN  | +0   | 横-0   | NaN  | 
   | 横-0   | 横-0   | +0   | NaN  | NaN  | 横-0   | +0   | NaN  | 
   | +inf | +inf | -inf | +inf | -inf | NaN  | NaN  | NaN  | 
   | -inf | -inf | +inf | -inf | +inf | NaN  | NaN  | NaN  | 
   | NaN  | NaN  | NaN  | NaN  | NaN  | NaN  | NaN  | NaN  | 

*  小数点以下桁数:

   ```csharp
   decimal operator /(decimal x, decimal y);
   ```

   右オペランドの値が0の場合は、`System.DivideByZeroException` がスローされます。 結果の値が大きすぎて `decimal` 形式で表現できない場合は、`System.OverflowException` がスローされます。 結果値が小さすぎて `decimal` 形式で表現できない場合、結果は0になります。 結果の小数点以下桁数は、実際の数値の結果に最も近い表現可能な10進値と等しい結果を保持する最小のスケールになります。

   小数点除算は、`System.Decimal`型の除算演算子を使用することと同じです。


### <a name="remainder-operator"></a>剰余演算子

`x % y`フォームの操作では、二項演算子のオーバーロードの解決 ([二項演算子のオーバーロードの解決](expressions.md#binary-operator-overload-resolution)) が適用され、特定の演算子の実装を選択します。 オペランドは選択した演算子のパラメーターの型に変換され、結果の型は演算子の戻り値の型になります。

定義済みの剰余演算子を次に示します。 すべての演算子は、`x` と `y`間の除算の剰余を計算します。

*  整数の剰余:

   ```csharp
   int operator %(int x, int y);
   uint operator %(uint x, uint y);
   long operator %(long x, long y);
   ulong operator %(ulong x, ulong y);
   ```

   `x % y` の結果は `x - (x / y) * y`によって生成される値です。 `y` がゼロの場合、`System.DivideByZeroException` がスローされます。

   左オペランドが最小 `int` 値または `long` 値で、右オペランドが `-1`の場合、`System.OverflowException` がスローされます。 `x / y` が例外をスローしない場合、`x % y` は例外をスローしません。

*  浮動小数点の剰余:

   ```csharp
   float operator %(float x, float y);
   double operator %(double x, double y);
   ```

   次の表に、0以外の有限値 (0、無限大、および NaN) のすべての可能な組み合わせの結果を示します。 テーブルでは、`x` と `y` が正の有限値になります。 `z` は `x % y` の結果であり、`x - n * y`として計算されます。 `n` は、`x / y`以下の最大の整数です。 余りを計算するこの方法は、整数オペランドに使用されるものと似ていますが、IEEE 754 定義とは異なります (`n` が `x / y`に最も近い整数)。

   |      |      |      |      |      |      |      |      |
   |:----:|:----:|:----:|:----:|:----:|:----:|:----:|:----:|
   |      | +y   | -y   | +0   | 横-0   | +inf | -inf | NaN  | 
   | +x   | \+ z   | \+ z   | NaN  | NaN  | X    | X    | NaN  | 
   | -x   | -z   | -z   | NaN  | NaN  | -x   | -x   | NaN  | 
   | +0   | +0   | +0   | NaN  | NaN  | +0   | +0   | NaN  | 
   | 横-0   | 横-0   | 横-0   | NaN  | NaN  | 横-0   | 横-0   | NaN  | 
   | +inf | NaN  | NaN  | NaN  | NaN  | NaN  | NaN  | NaN  | 
   | -inf | NaN  | NaN  | NaN  | NaN  | NaN  | NaN  | NaN  | 
   | NaN  | NaN  | NaN  | NaN  | NaN  | NaN  | NaN  | NaN  | 

*  10進数の剰余:

   ```csharp
   decimal operator %(decimal x, decimal y);
   ```

   右オペランドの値が0の場合は、`System.DivideByZeroException` がスローされます。 丸めの前の結果の小数点以下桁数は、2つのオペランドのスケールのうち、大きい方になります。0以外の場合は、結果の符号が `x`の値と同じになります。

   Decimal 剰余は、`System.Decimal`型の剰余演算子を使用することと同じです。


### <a name="addition-operator"></a>加算演算子

`x + y`フォームの操作では、二項演算子のオーバーロードの解決 ([二項演算子のオーバーロードの解決](expressions.md#binary-operator-overload-resolution)) が適用され、特定の演算子の実装を選択します。 オペランドは選択した演算子のパラメーターの型に変換され、結果の型は演算子の戻り値の型になります。

定義済みの加算演算子を以下に示します。 数値型と列挙型の場合、定義済みの加算演算子は、2つのオペランドの合計を計算します。 一方または両方のオペランドが string 型の場合、定義済みの加算演算子は、オペランドの文字列形式を連結します。

*  整数加算:

   ```csharp
   int operator +(int x, int y);
   uint operator +(uint x, uint y);
   long operator +(long x, long y);
   ulong operator +(ulong x, ulong y);
   ```

   `checked` のコンテキストでは、合計が結果の型の範囲外の場合、`System.OverflowException` がスローされます。 `unchecked` のコンテキストでは、オーバーフローは報告されず、結果の型の範囲外の重要な上位ビットはすべて破棄されます。

*  浮動小数点加算:

   ```csharp
   float operator +(float x, float y);
   double operator +(double x, double y);
   ```

   合計は、IEEE 754 算術のルールに従って計算されます。 次の表に、0以外の有限値 (0、無限大、および NaN) のすべての可能な組み合わせの結果を示します。 この表では、`x` と `y` は0以外の有限値であり、`z` は `x + y`の結果です。 `x` と `y` の大きさは同じですが、符号が逆の場合、`z` は正のゼロになります。 `x + y` が変換先の型で表すには大きすぎる場合、`z` は `x + y`と同じ符号を持つ無限大です。

   |      |      |      |      |      |      |      |
   |:----:|:----:|:----:|:----:|:----:|:----:|:----:|
   |      | Y    | +0   | 横-0   | +inf | -inf | NaN  | 
   | X    | z    | X    | X    | +inf | -inf | NaN  | 
   | +0   | Y    | +0   | +0   | +inf | -inf | NaN  | 
   | 横-0   | Y    | +0   | 横-0   | +inf | -inf | NaN  | 
   | +inf | +inf | +inf | +inf | +inf | NaN  | NaN  | 
   | -inf | -inf | -inf | -inf | NaN  | -inf | NaN  | 
   | NaN  | NaN  | NaN  | NaN  | NaN  | NaN  | NaN  | 

*  小数点の追加:

   ```csharp
   decimal operator +(decimal x, decimal y);
   ```

   結果の値が大きすぎて `decimal` 形式で表現できない場合は、`System.OverflowException` がスローされます。 結果の小数点以下の桁数は、2つのオペランドのスケールのうち、大きい方になります。

   Decimal 加算は、`System.Decimal`型の加算演算子を使用することと同じです。

*  列挙型の追加。 すべての列挙型には、暗黙的に次の定義済みの演算子が用意されています。 `E` は列挙型であり、`U` は `E`の基になる型です。

   ```csharp
   E operator +(E x, U y);
   E operator +(U x, E y);
   ```

   実行時に、これらの演算子は `(E)((U)x + (U)y)`として正確に評価されます。

*  文字列の連結:

   ```csharp
   string operator +(string x, string y);
   string operator +(string x, object y);
   string operator +(object x, string y);
   ```

   これらのバイナリ `+` 演算子のオーバーロードは、文字列の連結を実行します。 文字列連結のオペランドが `null`場合、空の文字列が置換されます。 それ以外の場合、文字列以外の引数は、型 `object`から継承された仮想 `ToString` メソッドを呼び出すことによって文字列形式に変換されます。 `ToString` が `null`を返す場合、空の文字列が置換されます。

   ```csharp
   using System;
   
   class Test
   {
       static void Main() {
           string s = null;
           Console.WriteLine("s = >" + s + "<");        // displays s = ><
           int i = 1;
           Console.WriteLine("i = " + i);               // displays i = 1
           float f = 1.2300E+15F;
           Console.WriteLine("f = " + f);               // displays f = 1.23E+15
           decimal d = 2.900m;
           Console.WriteLine("d = " + d);               // displays d = 2.900
       }
   }
   ```

   文字列連結演算子の結果は、左オペランドの文字と右オペランドの文字で構成される文字列です。 文字列連結演算子は、`null` 値を返しません。 結果の文字列を割り当てるために十分なメモリがない場合、`System.OutOfMemoryException` がスローされる可能性があります。

*  デリゲートの組み合わせ。 すべてのデリゲート型は、次の定義済み演算子を暗黙的に提供します。 `D` はデリゲート型です。

   ```csharp
   D operator +(D x, D y);
   ```

   二項 `+` 演算子は、両方のオペランドがデリゲート型 `D`である場合に、デリゲートの組み合わせを実行します。 (オペランドのデリゲート型が異なる場合、バインド時エラーが発生します)。最初のオペランドが `null`場合、演算の結果は2番目のオペランドの値になります (その場合も `null`)。 それ以外の場合、2番目のオペランドが `null`場合、演算の結果は最初のオペランドの値になります。 それ以外の場合、操作の結果は新しいデリゲートインスタンスになり、呼び出されると、最初のオペランドが呼び出され、2番目のオペランドが呼び出されます。 デリゲートの組み合わせの例については、「[減算演算子](expressions.md#subtraction-operator)と[デリゲート呼び出し](delegates.md#delegate-invocation)」を参照してください。 `System.Delegate` はデリゲート型ではないため、`operator` `+` は定義されていません。

### <a name="subtraction-operator"></a>減算演算子

`x - y`フォームの操作では、二項演算子のオーバーロードの解決 ([二項演算子のオーバーロードの解決](expressions.md#binary-operator-overload-resolution)) が適用され、特定の演算子の実装を選択します。 オペランドは選択した演算子のパラメーターの型に変換され、結果の型は演算子の戻り値の型になります。

次に、定義済みの減算演算子を示します。 すべての演算子は、`x`から `y` を減算します。

*  整数の減算:

   ```csharp
   int operator -(int x, int y);
   uint operator -(uint x, uint y);
   long operator -(long x, long y);
   ulong operator -(ulong x, ulong y);
   ```

   `checked` コンテキストでは、差分が結果の型の範囲外の場合、`System.OverflowException` がスローされます。 `unchecked` のコンテキストでは、オーバーフローは報告されず、結果の型の範囲外の重要な上位ビットはすべて破棄されます。

*  浮動小数点の減算:

   ```csharp
   float operator -(float x, float y);
   double operator -(double x, double y);
   ```

   この違いは、IEEE 754 算術のルールに従って計算されます。 次の表に、0以外の有限値、ゼロ、無限大、および Nan のすべての可能な組み合わせの結果を示します。 この表では、`x` と `y` は0以外の有限値であり、`z` は `x - y`の結果です。 `x` と `y` が等しい場合、`z` は正のゼロになります。 `x - y` が変換先の型で表すには大きすぎる場合、`z` は `x - y`と同じ符号を持つ無限大です。

   |      |      |      |      |      |      |     |
   |:----:|:----:|:----:|:----:|:----:|:----:|:---:|
   |      | Y    | +0   | 横-0   | +inf | -inf | NaN | 
   | X    | z    | X    | X    | -inf | +inf | NaN | 
   | +0   | -y   | +0   | +0   | -inf | +inf | NaN | 
   | 横-0   | -y   | 横-0   | +0   | -inf | +inf | NaN | 
   | +inf | +inf | +inf | +inf | NaN  | +inf | NaN | 
   | -inf | -inf | -inf | -inf | -inf | NaN  | NaN | 
   | NaN  | NaN  | NaN  | NaN  | NaN  | NaN  | NaN | 

*  10進数の減算:

   ```csharp
   decimal operator -(decimal x, decimal y);
   ```

   結果の値が大きすぎて `decimal` 形式で表現できない場合は、`System.OverflowException` がスローされます。 結果の小数点以下の桁数は、2つのオペランドのスケールのうち、大きい方になります。

   Decimal 減算は、`System.Decimal`型の減算演算子を使用することと同じです。

*  列挙型の減算。 すべての列挙型には、暗黙的に次の定義済みの演算子が用意されています。 `E` は列挙型であり、`U` は `E`の基になる型です。

   ```csharp
   U operator -(E x, E y);
   ```

   この演算子は `(U)((U)x - (U)y)`として正確に評価されます。 言い換えると、演算子は `x` と `y`の序数値の差を計算し、結果の型は列挙型の基になる型になります。

   ```csharp
   E operator -(E x, U y);
   ```

   この演算子は `(E)((U)x - y)`として正確に評価されます。 つまり、演算子は列挙体の基になる型から値を減算し、列挙体の値を生成します。

*  デリゲートの削除。 すべてのデリゲート型は、次の定義済み演算子を暗黙的に提供します。 `D` はデリゲート型です。

   ```csharp
   D operator -(D x, D y);
   ```

   二項 `-` 演算子は、両方のオペランドがデリゲート型 `D`である場合に、デリゲートの削除を実行します。 オペランドのデリゲート型が異なる場合、バインド時エラーが発生します。 最初のオペランドが `null` の場合は、演算結果は `null` になります。 それ以外の場合、2番目のオペランドが `null`場合、演算の結果は最初のオペランドの値になります。 それ以外の場合、どちらのオペランドも1つ以上のエントリを持つ呼び出しリスト ([デリゲート宣言](delegates.md#delegate-declarations)) を表します。結果は、2番目のオペランドのリストが最初ののサブリストである場合に、2番目のオペランドのエントリが削除された最初のオペランドリストで構成される新しい呼び出しリストになります。     (サブリストが等しいかどうかを判断するために、対応するエントリは、デリゲート等値演算子 ([デリゲート等値演算子](expressions.md#delegate-equality-operators)) と比較されます。それ以外の場合、結果は左オペランドの値になります。 このプロセスでは、オペランドのリストはいずれも変更されません。 2番目のオペランドのリストが、最初のオペランドのリスト内の連続するエントリの複数のサブリストと一致する場合、連続するエントリの右側に一致するサブリストが削除されます。 削除によりリストが空になる場合、結果は `null` になります。 例:

   ```csharp
   delegate void D(int x);
   
   class C
   {
       public static void M1(int i) { /* ... */ }
       public static void M2(int i) { /* ... */ }
   }

   class Test
   {
       static void Main() { 
           D cd1 = new D(C.M1);
           D cd2 = new D(C.M2);
           D cd3 = cd1 + cd2 + cd2 + cd1;   // M1 + M2 + M2 + M1
           cd3 -= cd1;                      // => M1 + M2 + M2
   
           cd3 = cd1 + cd2 + cd2 + cd1;     // M1 + M2 + M2 + M1
           cd3 -= cd1 + cd2;                // => M2 + M1
   
           cd3 = cd1 + cd2 + cd2 + cd1;     // M1 + M2 + M2 + M1
           cd3 -= cd2 + cd2;                // => M1 + M1
   
           cd3 = cd1 + cd2 + cd2 + cd1;     // M1 + M2 + M2 + M1
           cd3 -= cd2 + cd1;                // => M1 + M2
   
           cd3 = cd1 + cd2 + cd2 + cd1;     // M1 + M2 + M2 + M1
           cd3 -= cd1 + cd1;                // => M1 + M2 + M2 + M1
       }
   }
   ```

## <a name="shift-operators"></a>シフト演算子

`<<` 演算子と `>>` 演算子は、ビットシフト演算を実行するために使用されます。

```antlr
shift_expression
    : additive_expression
    | shift_expression '<<' additive_expression
    | shift_expression right_shift additive_expression
    ;
```

*Shift_expression*のオペランドにコンパイル時の型 `dynamic`がある場合、式は動的にバインドされます ([動的バインド](expressions.md#dynamic-binding))。 この場合、式のコンパイル時の型は `dynamic`であり、以下に示す解決方法は、コンパイル時の型 `dynamic`を持つオペランドの実行時の型を使用して実行時に実行されます。

`x << count` または `x >> count`の形式の操作では、二項演算子のオーバーロードの解決 ([二項演算子のオーバーロードの解決](expressions.md#binary-operator-overload-resolution)) が適用され、特定の演算子の実装を選択します。 オペランドは選択した演算子のパラメーターの型に変換され、結果の型は演算子の戻り値の型になります。

オーバーロードされたシフト演算子を宣言する場合、最初のオペランドの型は、常に演算子宣言を含むクラスまたは構造体である必要があります。また、2番目のオペランドの型は常に `int`である必要があります。

次に、定義済みのシフト演算子を示します。

*  左シフト:

   ```csharp
   int operator <<(int x, int count);
   uint operator <<(uint x, int count);
   long operator <<(long x, int count);
   ulong operator <<(ulong x, int count);
   ```

   `<<` 演算子は、次に示すように計算されたビット数だけ、`x` をシフトします。

   `x` の結果の型の範囲外の上位ビットは破棄され、残りのビットは左にシフトされ、下位の空のビット位置は0に設定されます。

*  右シフト:

   ```csharp
   int operator >>(int x, int count);
   uint operator >>(uint x, int count);
   long operator >>(long x, int count);
   ulong operator >>(ulong x, int count);
   ```

   `>>` 演算子は、次に示すように、計算されたビット数だけ右に `x` をシフトします。

   `x` が `int` または `long`型の場合、`x` の下位ビットは破棄され、残りのビットは右にシフトされます。また、`x` が負ではない場合、上位の空のビット位置は0に設定されます。

   `x` が `uint` または `ulong`型の場合、`x` の下位ビットは破棄され、残りのビットは右にシフトされ、上位の空のビット位置は0に設定されます。

定義済みの演算子の場合、シフトするビット数は次のように計算されます。

*  `x` の種類が `int` または `uint`の場合、シフト数は `count`の下位5ビットによって指定されます。 つまり、シフト数は `count & 0x1F`から計算されます。
*  `x` の種類が `long` または `ulong`の場合、シフト数は `count`の下位6ビットによって指定されます。 つまり、シフト数は `count & 0x3F`から計算されます。

結果として得られるシフト数が0の場合、シフト演算子は単に `x`の値を返します。

シフト操作ではオーバーフローが発生することはなく、`checked` と `unchecked` のコンテキストでも同じ結果が生成されます。

`>>` 演算子の左オペランドが符号付き整数型の場合、演算子は、オペランドの最上位ビット (符号ビット) の値が上位の空のビット位置に反映される、算術シフト右を実行します。 `>>` 演算子の左オペランドが符号なし整数型の場合、演算子は論理シフト右を実行します。この場合、上位の空のビット位置は常に0に設定されます。 オペランド型から推論されたの逆の演算を実行するには、明示的なキャストを使用できます。 たとえば、`x` が `int`型の変数である場合、操作 `unchecked((int)((uint)x >> y))` `x`の論理右シフトを実行します。

## <a name="relational-and-type-testing-operators"></a>関係演算子と型検査演算子

`==`、`!=`、`<`、`>`、`<=`、`>=`、`is`、および `as` の各演算子は、関係演算子と型テスト演算子と呼ばれます。

```antlr
relational_expression
    : shift_expression
    | relational_expression '<' shift_expression
    | relational_expression '>' shift_expression
    | relational_expression '<=' shift_expression
    | relational_expression '>=' shift_expression
    | relational_expression 'is' type
    | relational_expression 'as' type
    ;

equality_expression
    : relational_expression
    | equality_expression '==' relational_expression
    | equality_expression '!=' relational_expression
    ;
```

`is` 演算子は[is 演算子](expressions.md#the-is-operator)で説明されており、`as` 演算子は[as 演算子](expressions.md#the-as-operator)で説明されています。

`==`、`!=`、`<`、`>`、`<=`、および `>=` の各演算子は、***比較演算子***です。

比較演算子のオペランドに `dynamic`コンパイル時の型がある場合、式は動的にバインドされます ([動的バインド](expressions.md#dynamic-binding))。 この場合、式のコンパイル時の型は `dynamic`であり、以下に示す解決方法は、コンパイル時の型 `dynamic`を持つオペランドの実行時の型を使用して実行時に実行されます。

Op を `x` *op* `y`形式の操作では、 *op*は比較演算子であり、オーバーロードの解決 ([二項演算子のオーバーロードの解決](expressions.md#binary-operator-overload-resolution)) が適用され、特定の演算子の実装を選択します。 オペランドは選択した演算子のパラメーターの型に変換され、結果の型は演算子の戻り値の型になります。

定義済みの比較演算子については、次のセクションで説明します。 次の表で説明するように、すべての定義済みの比較演算子は `bool`型の結果を返します。


| __操作__ | __結果__                                                       |
|---------------|------------------------------------------------------------------|
| `x == y`      | `true` `x` が `y`に等しい場合は、それ以外の場合は `false`                 | 
| `x != y`      | `true` `x` が `y`と等しくない場合は、それ以外の場合は `false`             | 
| `x < y`       | `true` `x` が `y`より小さい場合は、それ以外の場合は `false`                | 
| `x > y`       | `true` `x` が `y`より大きい場合は、それ以外の場合は `false`             | 
| `x <= y`      | `true` `x` が `y`以下の場合は、それ以外の場合は `false`    | 
| `x >= y`      | `true` `x` が `y`以上の場合は、それ以外の場合は `false` | 

### <a name="integer-comparison-operators"></a>整数の比較演算子

定義済みの整数の比較演算子は次のとおりです。
```csharp
bool operator ==(int x, int y);
bool operator ==(uint x, uint y);
bool operator ==(long x, long y);
bool operator ==(ulong x, ulong y);

bool operator !=(int x, int y);
bool operator !=(uint x, uint y);
bool operator !=(long x, long y);
bool operator !=(ulong x, ulong y);

bool operator <(int x, int y);
bool operator <(uint x, uint y);
bool operator <(long x, long y);
bool operator <(ulong x, ulong y);

bool operator >(int x, int y);
bool operator >(uint x, uint y);
bool operator >(long x, long y);
bool operator >(ulong x, ulong y);

bool operator <=(int x, int y);
bool operator <=(uint x, uint y);
bool operator <=(long x, long y);
bool operator <=(ulong x, ulong y);

bool operator >=(int x, int y);
bool operator >=(uint x, uint y);
bool operator >=(long x, long y);
bool operator >=(ulong x, ulong y);
```

これらの各演算子は、2つの整数オペランドの数値を比較し、特定のリレーションシップが `true` または `false`かどうかを示す `bool` 値を返します。

### <a name="floating-point-comparison-operators"></a>浮動小数点比較演算子

定義済みの浮動小数点比較演算子は次のとおりです。
```csharp
bool operator ==(float x, float y);
bool operator ==(double x, double y);

bool operator !=(float x, float y);
bool operator !=(double x, double y);

bool operator <(float x, float y);
bool operator <(double x, double y);

bool operator >(float x, float y);
bool operator >(double x, double y);

bool operator <=(float x, float y);
bool operator <=(double x, double y);

bool operator >=(float x, float y);
bool operator >=(double x, double y);
```

演算子は、IEEE 754 標準の規則に従って、オペランドを比較します。

*  どちらかのオペランドが NaN の場合、結果は `!=`を除くすべての演算子に対して `false` ます。この場合、結果は `true`ます。 2つのオペランドの場合、`x != y` は常に `!(x == y)`と同じ結果を生成します。 一方または両方のオペランドが NaN の場合、`<`、`>`、`<=`、および `>=` の各演算子は、逆の演算子の論理否定と同じ結果を生成しません。 たとえば、`x` と `y` のいずれかが NaN の場合、`x < y` は `false`ますが、`!(x >= y)` は `true`です。
*  どちらのオペランドも NaN の場合、演算子は、2つの浮動小数点オペランドの値を順序付けと比較します。

   ```csharp
   -inf < -max < ... < -min < -0.0 == +0.0 < +min < ... < +max < +inf
   ```

   ここで `min` と `max` は、指定された浮動小数点形式で表すことができる最小値と最大値の正の有限値です。 この順序の主な影響は次のとおりです。
   * 負のゼロと正のゼロは等しいと見なされます。
   * 負の無限大は、他のすべての値よりも小さいと見なされますが、負の負の無限大と同じです。
   * 正の無限大は、他のすべての値よりも大きいと見なされますが、もう1つの正の無限大と同じです。

### <a name="decimal-comparison-operators"></a>10進数の比較演算子

定義済みの10進数比較演算子は次のとおりです。
```csharp
bool operator ==(decimal x, decimal y);
bool operator !=(decimal x, decimal y);
bool operator <(decimal x, decimal y);
bool operator >(decimal x, decimal y);
bool operator <=(decimal x, decimal y);
bool operator >=(decimal x, decimal y);
```

これらの各演算子は、2つの10進オペランドの数値を比較し、特定のリレーションシップが `true` または `false`かどうかを示す `bool` 値を返します。 各10進数の比較は、`System.Decimal`型の対応する関係演算子または等値演算子を使用することと同じです。

### <a name="boolean-equality-operators"></a>ブール等値演算子

定義済みのブール等価演算子は次のとおりです。
```csharp
bool operator ==(bool x, bool y);
bool operator !=(bool x, bool y);
```

`x` と `y` の両方が `true` である場合、または `x` と `y` の両方が `false`場合は、`==` の結果が `true` ます。 それ以外の場合、結果は `false` です。

`x` と `y` の両方が `true` である場合、または `x` と `y` の両方が `false`場合は、`!=` の結果が `false` ます。 それ以外の場合、結果は `true` です。 オペランドの型が `bool`の場合、`!=` 演算子は `^` 演算子と同じ結果を生成します。

### <a name="enumeration-comparison-operators"></a>列挙型の比較演算子

すべての列挙型には、次の定義済みの比較演算子が暗黙的に用意されています。
```csharp
bool operator ==(E x, E y);
bool operator !=(E x, E y);
bool operator <(E x, E y);
bool operator >(E x, E y);
bool operator <=(E x, E y);
bool operator >=(E x, E y);
```

`x op y`を評価した結果 `x` と `y` は、基になる型 `U`で `E` 列挙型の式であり、比較演算子の1つである `op` は `((U)x) op ((U)y)`の評価とまったく同じです。 つまり、列挙型の比較演算子は、単に2つのオペランドの基になる整数値を比較します。

### <a name="reference-type-equality-operators"></a>参照型等値演算子

定義済みの参照型等値演算子は次のとおりです。
```csharp
bool operator ==(object x, object y);
bool operator !=(object x, object y);
```

演算子は、2つの参照の等価性または非等価性を比較した結果を返します。

定義済みの参照型等値演算子は `object`型のオペランドを受け入れるため、適用可能な `operator ==` および `operator !=` メンバーを宣言しないすべての型に適用されます。 反対に、適用可能なユーザー定義等値演算子は、定義済みの参照型等値演算子を効果的に非表示にします。

定義済みの参照型等値演算子には、次のいずれかが必要です。

*  どちらのオペランドも、 *reference_type*またはリテラル `null`であると認識される型の値です。 さらに、明示的な参照変換 ([明示的な参照](conversions.md#explicit-reference-conversions)変換) は、いずれかのオペランドの型からもう一方のオペランドの型に存在します。
*  1つのオペランドは `T` 型の値で、`T` は*type_parameter*であり、もう一方のオペランドはリテラル `null`です。 さらに `T` には値型の制約がありません。

これらの条件のいずれかが満たされていない限り、バインド時エラーが発生します。 これらの規則の主な影響は次のとおりです。

*  定義済みの参照型等値演算子を使用して、バインド時に異なることがわかっている2つの参照を比較するためのバインド時エラーです。 たとえば、オペランドのバインド時の型が `A` および `B`の2つのクラス型であり、どちらも `A` も `B` も派生していない場合は、2つのオペランドが同じオブジェクトを参照することはできません。 このため、この操作はバインド時エラーと見なされます。
*  定義済みの参照型等値演算子では、値型のオペランドを比較することはできません。 したがって、構造体型で独自の等値演算子が宣言されていない限り、その構造体型の値を比較することはできません。
*  定義済みの参照型等値演算子は、オペランドに対してボックス化操作が発生することはありません。 新しく割り当てられたボックス化されたインスタンスへの参照は、他のすべての参照とは必ず異なるため、このようなボックス化操作を実行することは無意味です。
*  `T` 型パラメーター型のオペランドが `null`と比較され、`T` の実行時の型が値型である場合、比較の結果は `false`になります。

次の例では、制約のない型パラメーター型の引数が `null`かどうかを確認します。
```csharp
class C<T>
{
    void F(T x) {
        if (x == null) throw new ArgumentNullException();
        ...
    }
}
```

`x == null` コンストラクトは、`T` が値型を表している場合でも許可されます。 `T` が値型の場合、結果は単純に `false` されるように定義されます。

`x == y` または `x != y`の形式の操作では、適用可能な `operator ==` または `operator !=` が存在する場合、演算子のオーバーロードの解決 ([二項演算子のオーバーロードの解決](expressions.md#binary-operator-overload-resolution)) ルールによって、定義済みの参照型等値演算子ではなく、その演算子が選択されます。 ただし、オペランドの一方または両方を明示的に `object`型にキャストすることで、定義済みの参照型等値演算子を常に選択できます。 例
```csharp
using System;

class Test
{
    static void Main() {
        string s = "Test";
        string t = string.Copy(s);
        Console.WriteLine(s == t);
        Console.WriteLine((object)s == t);
        Console.WriteLine(s == (object)t);
        Console.WriteLine((object)s == (object)t);
    }
}
```
この例では、次のように出力されます。
```console
True
False
False
False
```

`s` 変数と `t` 変数は、同じ文字を含む2つの異なる `string` インスタンスを参照します。 2つのオペランドの型が `string`の場合、定義済みの文字列等値演算子 ([文字列等値](expressions.md#string-equality-operators)演算子) が選択されているので、最初の比較で `True` が出力されます。 一方または両方のオペランドが `object`型の場合、定義済みの参照型等値演算子が選択されているので、残りのすべての出力 `False` になります。

上記の手法は、値型では意味がないことに注意してください。 例
```csharp
class Test
{
    static void Main() {
        int i = 123;
        int j = 123;
        System.Console.WriteLine((object)i == (object)j);
    }
}
```
キャストによって、ボックス化された `int` 値の2つの異なるインスタンスへの参照が作成されるため、`False` 出力されます。

### <a name="string-equality-operators"></a>文字列等値演算子

事前定義された文字列等値演算子は次のとおりです。
```csharp
bool operator ==(string x, string y);
bool operator !=(string x, string y);
```

次のいずれかに該当する場合、2つの `string` 値は等しいと見なされます。

*  両方の値が `null`ます。
*  両方の値は、長さが同じ文字列インスタンスへの null 参照と、各文字位置に同一の文字を持ちます。

文字列の等値演算子は、文字列参照ではなく文字列値を比較します。 2つの個別の文字列インスタンスにまったく同じ文字シーケンスが含まれている場合、文字列の値は同じですが、参照が異なります。 「[参照型等値演算子](expressions.md#reference-type-equality-operators)」で説明されているように、参照型等値演算子を使用すると、文字列値ではなく文字列参照を比較できます。

### <a name="delegate-equality-operators"></a>デリゲート等値演算子

すべてのデリゲート型には、次の定義済みの比較演算子が暗黙的に用意されています。

```csharp
bool operator ==(System.Delegate x, System.Delegate y);
bool operator !=(System.Delegate x, System.Delegate y);
```

次の2つのデリゲートインスタンスが等しいと見なされます。

*  いずれかのデリゲートインスタンスが `null`場合、両方が `null`場合に限り、これらのインスタンスは等しいと見なされます。
*  デリゲートの実行時の型が異なる場合、それらは等しくなりません。
*  両方のデリゲートインスタンスが呼び出しリスト ([デリゲート宣言](delegates.md#delegate-declarations)) を持っている場合、それらのインスタンスは、呼び出しリストが同じ長さであり、1つの呼び出しリスト内の各エントリが、他の呼び出しリストにおいて、対応するエントリに順番に等しいと見なされます。

次の規則は、呼び出しリストエントリが等しいかどうかを制御します。

*  2つの呼び出しリストエントリが両方とも同じ静的メソッドを参照している場合、エントリは同じになります。
*  2つの呼び出しリストエントリが、(参照等値演算子で定義されているように) 同じターゲットオブジェクトで同じ非静的メソッドを参照している場合、エントリは同じになります。
*  同じ (場合によっては空の) キャプチャされた外部変数インスタンスのセットを持つ、意味的に同一の*anonymous_method_expression*s または*lambda_expression*の評価から生成された呼び出しリストのエントリは、同じにすることができます (ただし、必須ではありません)。

### <a name="equality-operators-and-null"></a>等値演算子と null

`==` 演算子と `!=` 演算子では、1つのオペランドを null 許容型の値にすることができます。また、操作に対して定義済みまたはユーザー定義の演算子 (unlifted またはリフト形式) が存在しない場合でも、一方のオペランドは `null` リテラルになります。

いずれかの形式の操作の場合
```csharp
x == null
null == x
x != null
null != x
```
ここで `x` は null 許容型の式で、演算子のオーバーロード解決 ([二項演算子のオーバーロードの解決](expressions.md#binary-operator-overload-resolution)) が適用可能な演算子を見つけることができない場合、結果は `x`の `HasValue` プロパティから計算されます。 具体的には、最初の2つの形式は `!x.HasValue`に変換され、最後の2つの形式は `x.HasValue`に変換されます。

### <a name="the-is-operator"></a>Is 演算子

`is` 演算子は、オブジェクトの実行時の型が特定の型と互換性があるかどうかを動的に確認するために使用されます。 演算の結果 `E is T`。ここで `E` は式で、`T` は型であり、参照変換、ボックス化変換、またはボックス化解除変換によって `E` を `T` 型に正常に変換できるかどうかを示すブール値です。 型引数がすべての型パラメーターに置き換えられた後、演算は次のように評価されます。

*  `E` が匿名関数の場合、コンパイル時エラーが発生します。
*  `E` がメソッドグループまたは `null` リテラルである場合、`E` の型が参照型または null 許容型で、`E` の値が null の場合、結果は false になります。
*  それ以外の場合は、次のように `E` の動的な型を `D` します。
   * `E` の型が参照型の場合、`D` は `E`によってインスタンス参照の実行時の型になります。
   * `E` の型が null 許容型である場合、`D` はその null 許容型の基になる型です。
   * `E` の型が null 非許容の値型の場合、`D` は `E`の型になります。
*  操作の結果は `D` と `T` によって次のように異なります。
   * `T` が参照型の場合、結果は true になります。これは、`D` と `T` が同じ型である場合、`D` が参照型である場合、および `D` から `T` 存在する暗黙的な参照変換である場合、または `D` から `D` へのボックス変換が存在する場合に発生します。
   * `T` が null 許容型である場合、`D` が `T`の基になる型である場合、結果は true になります。
   * `T` が null 非許容の値型である場合、`D` と `T` が同じ型である場合、結果は true になります。
   * それ以外の場合、結果は false になります。

ユーザー定義の変換は、`is` 演算子では考慮されません。

### <a name="the-as-operator"></a>As 演算子

`as` 演算子は、特定の参照型または null 許容型に値を明示的に変換するために使用されます。 キャスト式 ([cast 式](expressions.md#cast-expressions)) とは異なり、`as` 演算子は例外をスローしません。 代わりに、指定された変換ができない場合、結果の値は `null`になります。

`E as T`フォームの操作では、`E` は式である必要があり、`T` は参照型、参照型であることがわかっている型パラメーター、または null 許容型である必要があります。 さらに、次のうち少なくとも1つが true である必要があります。そうでない場合は、コンパイル時エラーが発生します。

*  Id ([id 変換](conversions.md#identity-conversion))、暗黙の null 許容型変換 ([暗黙の null 許容](conversions.md#implicit-nullable-conversions)型変換)、暗黙的参照 ([暗黙的な参照変換](conversions.md#implicit-reference-conversions))、ボックス化 ([ボックス](conversions.md#boxing-conversions)化変換)、明示的な null 許容型変換[(明示的](conversions.md#explicit-reference-conversions)な[Null 許容変換](conversions.md#explicit-nullable-conversions))、またはボックス化解除 ([ボックス化変換](conversions.md#unboxing-conversions)) 変換は、`E` から `T`に存在します。
*  `E` または `T` の型がオープン型です。
*  `E` は `null` リテラルです。

`E` のコンパイル時の型が `dynamic`でない場合、操作 `E as T` によって同じ結果が生成されます。
```csharp
E is T ? (T)(E) : (T)null
```
ただし、`E` が評価されるのは 1 回だけです。 コンパイラは、上記の拡張によって暗黙的に指定された2つの動的な型チェックではなく、最大で1つの動的な型チェックを実行するように `E as T` を最適化することを想定できます。

`E` のコンパイル時の型が `dynamic`場合、cast 演算子とは異なり、`as` 演算子は動的にバインドされません ([動的バインド](expressions.md#dynamic-binding))。 したがって、この場合の展開は次のようになります。
```csharp
E is T ? (T)(object)(E) : (T)null
```

ユーザー定義変換など、一部の変換は `as` 演算子では実行できません。代わりに、キャスト式を使用して実行する必要があります。

この例では、
```csharp
class X
{

    public string F(object o) {
        return o as string;        // OK, string is a reference type
    }

    public T G<T>(object o) where T: Attribute {
        return o as T;             // Ok, T has a class constraint
    }

    public U H<U>(object o) {
        return o as U;             // Error, U is unconstrained 
    }
}
```
`G` の型パラメーター `T` は、クラスの制約があるため、参照型であることがわかっています。 `H` の型パラメーター `U` がではありません。したがって、`H` での `as` 演算子の使用は許可されていません。

## <a name="logical-operators"></a>論理演算子

`&`、`^`、および `|` の各演算子は、論理演算子と呼ばれます。

```antlr
and_expression
    : equality_expression
    | and_expression '&' equality_expression
    ;

exclusive_or_expression
    : and_expression
    | exclusive_or_expression '^' and_expression
    ;

inclusive_or_expression
    : exclusive_or_expression
    | inclusive_or_expression '|' exclusive_or_expression
    ;
```

論理演算子のオペランドに `dynamic`コンパイル時の型がある場合、式は動的にバインドされます ([動的バインド](expressions.md#dynamic-binding))。 この場合、式のコンパイル時の型は `dynamic`であり、以下に示す解決方法は、コンパイル時の型 `dynamic`を持つオペランドの実行時の型を使用して実行時に実行されます。

`x op y`形式の操作の場合、`op` は論理演算子の1つであるため、オーバーロードの解決 ([二項演算子のオーバーロードの解決](expressions.md#binary-operator-overload-resolution)) が適用され、特定の演算子の実装を選択します。 オペランドは選択した演算子のパラメーターの型に変換され、結果の型は演算子の戻り値の型になります。

定義済みの論理演算子については、次のセクションで説明します。

### <a name="integer-logical-operators"></a>整数の論理演算子

定義済みの整数の論理演算子は次のとおりです。
```csharp
int operator &(int x, int y);
uint operator &(uint x, uint y);
long operator &(long x, long y);
ulong operator &(ulong x, ulong y);

int operator |(int x, int y);
uint operator |(uint x, uint y);
long operator |(long x, long y);
ulong operator |(ulong x, ulong y);

int operator ^(int x, int y);
uint operator ^(uint x, uint y);
long operator ^(long x, long y);
ulong operator ^(ulong x, ulong y);
```

`&` 演算子は、2つのオペランドのビットごとの論理 `AND` を計算します。 `|` `OR` 演算子は、2つのオペランドのビットごとの論理和を計算し、`^` 演算子は2つのオペランドのビットごとの論理和を計算します。 これらの操作によってオーバーフローが発生することはありません。

### <a name="enumeration-logical-operators"></a>列挙論理演算子

すべての列挙型 `E` は、次の定義済みの論理演算子を暗黙的に提供します。

```csharp
E operator &(E x, E y);
E operator |(E x, E y);
E operator ^(E x, E y);
```

`x op y`を評価した結果 `x` と `y` は、基になる型 `U`で `E` 列挙型の式であり、`op` は論理演算子の1つであり、`(E)((U)x op (U)y)`の評価とまったく同じです。 言い換えると、列挙型の論理演算子は、2つのオペランドの基になる型に対して論理演算を実行するだけです。

### <a name="boolean-logical-operators"></a>ブール論理演算子

定義済みのブール型の論理演算子は次のとおりです。
```csharp
bool operator &(bool x, bool y);
bool operator |(bool x, bool y);
bool operator ^(bool x, bool y);
```

`x` と `y` の両方が `true` であれば、`x & y` の結果は `true` です。 それ以外の場合、結果は `false` です。

`x` または `y` が `true`の場合、`x | y` の結果は `true` です。 それ以外の場合、結果は `false` です。

`x` が `true` で `y` が `false`である場合、または `x` が `false` で `y` が `true`場合、`x ^ y` の結果は `true` ます。 それ以外の場合、結果は `false` です。 オペランドの型が `bool`の場合、`^` 演算子は `!=` 演算子と同じ結果を計算します。

### <a name="nullable-boolean-logical-operators"></a>Null 許容のブール型論理演算子

Null 許容型 `bool?` は、3つの値、`true`、`false`、および `null`を表すことができ、概念的には、SQL のブール式に使用される3つの値の型に似ています。 `bool?` オペランドの `&` および `|` 演算子によって生成された結果が SQL の3つの値のロジックと一致することを確認するために、次の定義済みの演算子が用意されています。

```csharp
bool? operator &(bool? x, bool? y);
bool? operator |(bool? x, bool? y);
```

次の表に、`true`、`false`、および `null`値のすべての組み合わせについて、これらの演算子によって生成される結果を示します。

| `x`     | `y`     | `x & y` | <code>x &#124; y</code> |
|:-------:|:-------:|:-------:|:-------:|
| `true`  | `true`  | `true`  | `true`  | 
| `true`  | `false` | `false` | `true`  | 
| `true`  | `null`  | `null`  | `true`  | 
| `false` | `true`  | `false` | `true`  | 
| `false` | `false` | `false` | `false` | 
| `false` | `null`  | `false` | `null`  | 
| `null`  | `true`  | `null`  | `true`  | 
| `null`  | `false` | `false` | `null`  | 
| `null`  | `null`  | `null`  | `null`  | 

## <a name="conditional-logical-operators"></a>条件付き論理演算子

`&&` 演算子と `||` 演算子は、条件付き論理演算子と呼ばれます。 "ショートサーキット" 論理演算子とも呼ばれます。

```antlr
conditional_and_expression
    : inclusive_or_expression
    | conditional_and_expression '&&' inclusive_or_expression
    ;

conditional_or_expression
    : conditional_and_expression
    | conditional_or_expression '||' conditional_and_expression
    ;
```

`&&` 演算子と `||` 演算子は、`&` および `|` 演算子の条件付きバージョンです。

*  操作 `x && y` は操作 `x & y`に対応しますが、`x` が `false`されていない場合にのみ `y` が評価される点が異なります。
*  操作 `x || y` は操作 `x | y`に対応しますが、`x` が `true`されていない場合にのみ `y` が評価される点が異なります。

条件付き論理演算子のオペランドに `dynamic`コンパイル時の型がある場合、式は動的にバインドされます ([動的バインド](expressions.md#dynamic-binding))。 この場合、式のコンパイル時の型は `dynamic`であり、以下に示す解決方法は、コンパイル時の型 `dynamic`を持つオペランドの実行時の型を使用して実行時に実行されます。

`x && y` または `x || y` の形式の操作は、操作が `x & y` または `x | y`に記述されているかのように、オーバーロードの解決 ([二項演算子のオーバーロードの解決](expressions.md#binary-operator-overload-resolution)) を適用することによって処理されます。 このとき、次のようになります。

*  オーバーロードの解決が1つの最適な演算子を見つけることができない場合、またはオーバーロードの解決で定義済みの整数の論理演算子が1つ選択された場合、バインド時エラーが発生します。
*  それ以外の場合、選択した演算子が、定義済みのブール型論理演算子 ([ブール](expressions.md#boolean-logical-operators)型論理演算子) または null 許容ブール値論理演算子 ([null 許容のブール値論理](expressions.md#nullable-boolean-logical-operators)演算子) のいずれかである場合、この操作は、「[ブール条件論理演算子](expressions.md#boolean-conditional-logical-operators)」の説明に従って処理されます。
*  それ以外の場合、選択された演算子はユーザー定義の演算子であり、操作は[ユーザー定義の条件付き論理演算子](expressions.md#user-defined-conditional-logical-operators)の説明に従って処理されます。

条件付き論理演算子を直接オーバーロードすることはできません。 ただし、条件付き論理演算子は、通常の論理演算子の観点で評価されるため、通常の論理演算子のオーバーロードは、特定の制限がある、条件付き論理演算子のオーバーロードとも見なされます。 詳細については[、ユーザー定義の条件付き論理演算子](expressions.md#user-defined-conditional-logical-operators)に関するページを参照してください。

### <a name="boolean-conditional-logical-operators"></a>ブール条件論理演算子

`&&` または `||` のオペランドが `bool`型である場合、またはオペランドが適用可能な `operator &` または `operator |`を定義しない型の場合、または `bool`への暗黙的な変換を定義する場合、操作は次のように処理されます。

*  操作 `x && y` は `x ? y : false`として評価されます。 つまり、`x` は最初に評価され、`bool`型に変換されます。 次に、`x` が `true`場合、`y` が評価され `bool`型に変換され、これが操作の結果になります。 それ以外の場合、操作の結果は `false`ます。
*  操作 `x || y` は `x ? true : y`として評価されます。 つまり、`x` は最初に評価され、`bool`型に変換されます。 次に、`x` が `true`場合、操作の結果は `true`ます。 それ以外の場合、`y` が評価され `bool`型に変換され、これが操作の結果になります。

### <a name="user-defined-conditional-logical-operators"></a>ユーザー定義の条件付き論理演算子

`&&` または `||` のオペランドが、適用可能なユーザー定義の `operator &` または `operator |`を宣言する型である場合、次の両方が true である必要があります。ここで、`T` は、選択した演算子が宣言されている型です。

*  戻り値の型と、選択した演算子の各パラメーターの型は `T`である必要があります。 言い換えると、演算子は `T`型の2つのオペランドの論理 `AND` または論理 `OR` を計算する必要があり、型 `T`の結果を返す必要があります。
*  `T` に `operator true` と `operator false`の宣言が含まれている必要があります。

これらの要件のいずれかが満たされていない場合、バインド時エラーが発生します。 それ以外の場合、`&&` または `||` 操作は、ユーザー定義の `operator true` または `operator false` を選択したユーザー定義演算子と組み合わせて評価されます。

*  操作 `x && y` は `T.false(x) ? x : T.&(x, y)`として評価されます。 `T.false(x)` は `T`で宣言された `operator false` の呼び出しで、`T.&(x, y)` は選択した `operator &`の呼び出しです。 つまり、`x` は最初に評価され、結果に対して `operator false` が呼び出され、`x` が確実に false であるかどうかが判断されます。 `x` が確実に false の場合、操作の結果は、以前に `x`に対して計算された値になります。 それ以外の場合、`y` が評価され、選択した `operator &` が `x` に対して以前に計算された値と、操作の結果を生成するために `y` に対して計算された値に対して呼び出されます。
*  操作 `x || y` は `T.true(x) ? x : T.|(x, y)`として評価されます。 `T.true(x)` は `T`で宣言された `operator true` の呼び出しで、`T.|(x,y)` は選択した `operator|`の呼び出しです。 つまり、`x` が最初に評価され、結果に対して `operator true` が呼び出され、`x` が確実に真であるかどうかが判断されます。 `x` が確実に true の場合、操作の結果は、以前に `x`に対して計算された値になります。 それ以外の場合、`y` が評価され、選択した `operator |` が `x` に対して以前に計算された値と、操作の結果を生成するために `y` に対して計算された値に対して呼び出されます。

これらのいずれの操作でも、`x` によって指定された式は1回だけ評価され、`y` によって指定された式は評価されず、正確には評価されません。

`operator true` と `operator false`を実装する型の例については、「[データベースのブール型](structs.md#database-boolean-type)」を参照してください。

## <a name="the-null-coalescing-operator"></a>Null 合体演算子

`??` 演算子は、null 合体演算子と呼ばれます。

```antlr
null_coalescing_expression
    : conditional_or_expression
    | conditional_or_expression '??' null_coalescing_expression
    ;
```

`a ?? b` 形式の null 結合式では、`a` null 許容型または参照型である必要があります。 `a` が null 以外の場合、`a ?? b` の結果は `a`ます。それ以外の場合、結果は `b`になります。 操作は、`a` が null の場合にのみ `b` を評価します。

Null 合体演算子は、右から左の操作がグループ化されていることを意味します。 たとえば、`a ?? b ?? c` フォームの式は `a ?? (b ?? c)`として評価されます。 一般的に、`E1 ?? E2 ?? ... ?? En` 形式の式では、null 以外のオペランドの最初の値が返されます。すべてのオペランドが null の場合は null になります。

`a ?? b` 式の型は、オペランドで使用できる暗黙の変換によって異なります。 優先順位では、`a ?? b` の型は `A0`、`A`、または `B`です。ここで `A` は `a` の型 (`a` に型がある場合)、`B` が null 許容型である場合は `b` の基になる型であり、それ以外の場合は `b` になります。 具体的には、`a ?? b` は次のように処理されます。

*  `A` が存在し、null 許容型または参照型でない場合は、コンパイル時エラーが発生します。
*  `b` が動的な式の場合、結果の型は `dynamic`になります。 実行時には、`a` が最初に評価されます。 `a` が null でない場合、`a` は動的に変換され、これが結果になります。 それ以外の場合は `b` が評価され、これが結果になります。
*  それ以外の場合、`A` 存在し、null 許容型であり、`b` から `A0`への暗黙的な変換が存在する場合、結果の型は `A0`になります。 実行時には、`a` が最初に評価されます。 `a` が null でない場合、`a` は `A0`型にラップ解除され、結果になります。 それ以外の場合、`b` が評価され、`A0`型に変換されて、結果になります。
*  それ以外の場合、`A` が存在し、`b` から `A`への暗黙的な変換が存在する場合、結果の型は `A`になります。 実行時には、`a` が最初に評価されます。 `a` が null でない場合、`a` が結果になります。 それ以外の場合、`b` が評価され、`A`型に変換されて、結果になります。
*  それ以外の場合、`b` に `B` 型があり、`a` から `B`への暗黙的な変換が存在する場合、結果の型は `B`になります。 実行時には、`a` が最初に評価されます。 `a` が null でない場合、`a` は `A0` 型にラップ解除され (`A` 存在し、null 値が許容される場合)、型 `B`に変換され、これが結果になります。 それ以外の場合、`b` が評価され、結果になります。
*  それ以外の場合、`a` と `b` に互換性がなく、コンパイル時にエラーが発生します。

## <a name="conditional-operator"></a>条件演算子

`?:` 演算子は、条件演算子と呼ばれます。 これは、三項演算子とも呼ばれます。

```antlr
conditional_expression
    : null_coalescing_expression
    | null_coalescing_expression '?' expression ':' expression
    ;
```

`b ? x : y` フォームの条件式は、最初に条件 `b`を評価します。 次に、`b` が `true`場合、`x` が評価され、操作の結果になります。 それ以外の場合、`y` が評価され、操作の結果になります。 条件式では、`x` と `y`の両方が評価されることはありません。

条件演算子は、右から左の操作がグループ化されていることを意味します。 たとえば、`a ? b : c ? d : e` フォームの式は `a ? b : (c ? d : e)`として評価されます。

`?:` 演算子の最初のオペランドは、`bool`、または `operator true`を実装する型の式に暗黙的に変換できる式である必要があります。 これらの要件のいずれも満たされない場合、コンパイル時エラーが発生します。

`?:` 演算子の2番目と3番目のオペランドである `x` および `y`は、条件式の型を制御します。

*  `x` の型が `X` で `y` 型がある場合は `Y`
   * 暗黙の変換 ([暗黙](conversions.md#implicit-conversions)の変換) が `X` から `Y`に存在するが、`Y` から `X`には存在しない場合、`Y` が条件式の型になります。
   * 暗黙の変換 ([暗黙](conversions.md#implicit-conversions)の変換) が `Y` から `X`に存在するが、`X` から `Y`には存在しない場合、`X` が条件式の型になります。
   * それ以外の場合は、式の型を特定できないため、コンパイル時エラーが発生します。
*  `x` と `y` の1つだけが型を持ち、`x` と `y`の両方がその型に暗黙的に変換可能な場合は、それが条件式の型になります。
*  それ以外の場合は、式の型を特定できないため、コンパイル時エラーが発生します。

`b ? x : y` フォームの条件式の実行時処理は、次の手順で構成されています。

*  まず、`b` が評価され、`b` の `bool` 値が決定されます。
   * `b` の型から `bool` への暗黙的な変換が存在する場合、この暗黙の変換は `bool` 値を生成するために実行されます。
   * それ以外の場合、`b` の型によって定義された `operator true` は、`bool` 値を生成するために呼び出されます。
*  上記の手順で生成された `bool` 値が `true`場合、`x` が評価され、条件式の型に変換され、これが条件式の結果になります。
*  それ以外の場合、`y` が評価され、条件式の型に変換されます。これは条件式の結果になります。

## <a name="anonymous-function-expressions"></a>匿名関数式

***匿名関数***は、"インライン" メソッド定義を表す式です。 匿名関数は、それ自体の値または型を持っていませんが、互換性のあるデリゲートまたは式ツリー型に変換できます。 匿名関数の変換の評価は、変換の対象の型によって異なります。これがデリゲート型である場合、変換は、匿名関数が定義するメソッドを参照するデリゲート値に評価されます。 式ツリー型の場合、変換は、オブジェクト構造としてのメソッドの構造を表す式ツリーに評価されます。

歴史的な理由により、匿名関数には2つの構文があります。つまり*lambda_expression*s と*anonymous_method_expression*s です。 ほとんどの場合、 *lambda_expression*は*anonymous_method_expression*より簡潔で表現力が豊かで、下位互換性のために言語に残されています。

```antlr
lambda_expression
    : anonymous_function_signature '=>' anonymous_function_body
    ;

anonymous_method_expression
    : 'delegate' explicit_anonymous_function_signature? block
    ;

anonymous_function_signature
    : explicit_anonymous_function_signature
    | implicit_anonymous_function_signature
    ;

explicit_anonymous_function_signature
    : '(' explicit_anonymous_function_parameter_list? ')'
    ;

explicit_anonymous_function_parameter_list
    : explicit_anonymous_function_parameter (',' explicit_anonymous_function_parameter)*
    ;

explicit_anonymous_function_parameter
    : anonymous_function_parameter_modifier? type identifier
    ;

anonymous_function_parameter_modifier
    : 'ref'
    | 'out'
    ;

implicit_anonymous_function_signature
    : '(' implicit_anonymous_function_parameter_list? ')'
    | implicit_anonymous_function_parameter
    ;

implicit_anonymous_function_parameter_list
    : implicit_anonymous_function_parameter (',' implicit_anonymous_function_parameter)*
    ;

implicit_anonymous_function_parameter
    : identifier
    ;

anonymous_function_body
    : expression
    | block
    ;
```

`=>` 演算子と代入 (`=`) は優先順位が同じで、結合規則が右から左です。

`async` 修飾子を持つ匿名関数は、非同期関数であり、「[反復子](classes.md#iterators)」で説明されている規則に従います。

*Lambda_expression*形式の匿名関数のパラメーターは、明示的または暗黙的に型指定できます。 明示的に型指定されたパラメーターリストでは、各パラメーターの型が明示的に指定されます。 暗黙的に型指定されたパラメーターリストでは、匿名関数が発生したコンテキストからパラメーターの型が推論されます。具体的には、匿名関数が互換性のあるデリゲート型または式ツリー型に変換されると、その型はパラメーターの型 ([匿名関数の変換](conversions.md#anonymous-function-conversions)) を提供します。

暗黙的に型指定された単一のパラメーターを持つ匿名関数では、パラメーターリストからかっこを省略できます。 つまり、という形式の匿名関数
```csharp
( param ) => expr
```
をに短縮できます。
```csharp
param => expr
```

*Anonymous_method_expression*形式の匿名関数のパラメーターリストは省略可能です。 指定されている場合は、パラメーターを明示的に型指定する必要があります。 それ以外の場合、匿名関数は `out` パラメーターを含まない任意のパラメーターリストを持つデリゲートに変換できます。

匿名関数の*ブロック*本体に到達可能 ([エンドポイントと到達可能性](statements.md#end-points-and-reachability)) は、匿名関数が到達できないステートメントの内部にある場合を除きます。

次に、匿名関数の例をいくつか示します。

```csharp
x => x + 1                              // Implicitly typed, expression body
x => { return x + 1; }                  // Implicitly typed, statement body
(int x) => x + 1                        // Explicitly typed, expression body
(int x) => { return x + 1; }            // Explicitly typed, statement body
(x, y) => x * y                         // Multiple parameters
() => Console.WriteLine()               // No parameters
async (t1,t2) => await t1 + await t2    // Async
delegate (int x) { return x + 1; }      // Anonymous method expression
delegate { return 1 + 1; }              // Parameter list omitted
```

*Lambda_expression*s と*anonymous_method_expression*s の動作は、次の点を除いて同じです。

*  *anonymous_method_expression*s を使用すると、パラメーターリストを完全に省略でき、値パラメーターのリストのデリゲート型に convertibility が生成されます。
*  *lambda_expression*s では、パラメーターの型を省略し、推論することができますが、 *anonymous_method_expression*s ではパラメーターの型を明示的に指定する必要があります。
*  *Lambda_expression*の本体は、式またはステートメントブロックにすることができます。一方、 *anonymous_method_expression*の本体は、ステートメントブロックである必要があります。
*  互換性のある式ツリー型 ([式ツリー型](types.md#expression-tree-types)) に変換できるのは*lambda_expression*s だけです。

### <a name="anonymous-function-signatures"></a>匿名関数のシグネチャ

匿名関数の省略可能な*anonymous_function_signature*は、匿名関数の名前と、必要に応じて、仮パラメーターの型を定義します。 匿名関数のパラメーターのスコープは、 *anonymous_function_body*です。 ([スコープ](basic-concepts.md#scopes))パラメーターリストと共に (指定されている場合)、匿名メソッド本体は宣言空間 ([宣言](basic-concepts.md#declarations)) を構成します。 したがって、匿名関数のパラメーター名がローカル変数の名前、ローカル定数、またはスコープに*anonymous_method_expression*または*lambda_expression*が含まれている場合、コンパイル時にエラーが発生します。

匿名関数に*explicit_anonymous_function_signature*がある場合、互換性のあるデリゲート型と式ツリー型のセットは、同じ順序で同じパラメーターの型と修飾子を持つものに制限されます。 メソッドグループの変換 ([メソッドグループの変換](conversions.md#method-group-conversions)) とは対照的に、匿名関数のパラメーター型の反変性はサポートされていません。 匿名関数に*anonymous_function_signature*がない場合、互換性のあるデリゲート型と式ツリー型のセットは、`out` パラメーターを持たない型に制限されます。

*Anonymous_function_signature*には、属性またはパラメーター配列を含めることはできません。 ただし、パラメーターリストにパラメーター配列が含まれているデリゲート型との互換性がある*anonymous_function_signature* 。

互換性がある場合でも、式ツリー型への変換は、コンパイル時 ([式ツリー型](types.md#expression-tree-types)) で失敗する可能性があることにも注意してください。

### <a name="anonymous-function-bodies"></a>匿名関数本体

匿名関数の本体 (*式*または*ブロック*) には、次の規則が適用されます。

*  匿名関数に署名が含まれている場合は、署名に指定されているパラメーターを本文で使用できます。 匿名関数にシグネチャがない場合は、パラメーターを持つデリゲート型または式の型に変換できます ([匿名関数の変換](conversions.md#anonymous-function-conversions))。ただし、本文内のパラメーターにアクセスすることはできません。
*  最も近い外側にある匿名関数のシグネチャ (存在する場合) に指定された `ref` パラメーターまたは `out` パラメーターを除き、本文が `ref` または `out` パラメーターにアクセスする場合、コンパイル時エラーになります。
*  `this` の型が構造体型の場合、本文が `this`にアクセスするためのコンパイル時エラーになります。 これは、アクセスが明示的 (`this.x`) であるか暗黙である (`x` のように、`x` が構造体のインスタンスメンバーである) かどうかによっても当てはまります。 この規則は、このようなアクセスを禁止するだけで、メンバーの参照結果が構造体のメンバーであるかどうかには影響しません。
*  本文は、匿名関数の外部変数 ([外部変数](expressions.md#outer-variables)) にアクセスできます。 外部変数にアクセスすると、 *lambda_expression*または*anonymous_method_expression*の評価時 ([匿名関数式の評価](expressions.md#evaluation-of-anonymous-function-expressions)) にアクティブになっている変数のインスタンスが参照されます。
*  本文に含まれている `goto` ステートメント、`break` ステートメント、または `continue` ステートメントが本体の外部または含まれている匿名関数の本体内に含まれている場合は、コンパイル時にエラーが発生します。
*  本体の `return` ステートメントは、外側の関数メンバーからではなく、最も近い外側の匿名関数の呼び出しから制御を返します。 `return` ステートメントで指定された式は、最も近い外側の*lambda_expression*または*anonymous_method_expression*が変換されるデリゲート型または式ツリー型の戻り値の型に暗黙的に変換可能である必要があります ([匿名関数の変換](conversions.md#anonymous-function-conversions))。

*Lambda_expression*または*anonymous_method_expression*の評価と呼び出し以外で匿名関数のブロックを実行する方法があるかどうかは、明示的に指定されていません。 特に、コンパイラは、1つまたは複数の名前付きメソッドまたは型をからことによって、匿名関数を実装することができます。 このような合成された要素の名前は、コンパイラ用に予約された形式である必要があります。

### <a name="overload-resolution-and-anonymous-functions"></a>オーバーロードの解決と匿名関数

引数リスト内の匿名関数は、型の推定とオーバーロードの解決に関与します。 厳密なルールについては、 [「型の推定](expressions.md#type-inference)と[オーバーロードの解決](expressions.md#overload-resolution)」を参照してください。

次の例は、オーバーロードの解決での匿名関数の効果を示しています。

```csharp
class ItemList<T>: List<T>
{
    public int Sum(Func<T,int> selector) {
        int sum = 0;
        foreach (T item in this) sum += selector(item);
        return sum;
    }

    public double Sum(Func<T,double> selector) {
        double sum = 0;
        foreach (T item in this) sum += selector(item);
        return sum;
    }
}
```

`ItemList<T>` クラスには、2つの `Sum` メソッドがあります。 各は `selector` 引数を受け取ります。これにより、リスト項目から合計値が抽出されます。 抽出された値には、`int` または `double` のいずれかを指定できます。また、結果として得られる合計は、`int` または `double`のいずれかになります。

たとえば、`Sum` メソッドを使用して、詳細行のリストから注文の合計を計算できます。

```csharp
class Detail
{
    public int UnitCount;
    public double UnitPrice;
    ...
}

void ComputeSums() {
    ItemList<Detail> orderDetails = GetOrderDetails(...);
    int totalUnits = orderDetails.Sum(d => d.UnitCount);
    double orderTotal = orderDetails.Sum(d => d.UnitPrice * d.UnitCount);
    ...
}
```

`orderDetails.Sum`の最初の呼び出しでは、匿名関数 `d => d. UnitCount` が `Func<Detail,int>` と `Func<Detail,double>`の両方と互換性があるため、両方の `Sum` メソッドが適用されます。 ただし、オーバーロードの解決では、最初の `Sum` メソッドが選択されます。これは、`Func<Detail,int>` への変換が `Func<Detail,double>`への変換よりも優れているためです。

`orderDetails.Sum`の2番目の呼び出しでは、匿名関数 `d => d.UnitPrice * d.UnitCount` が `double`型の値を生成するため、2番目の `Sum` メソッドのみが適用されます。 したがって、オーバーロードの解決は、その呼び出しの2つ目の `Sum` メソッドを選択します。

### <a name="anonymous-functions-and-dynamic-binding"></a>匿名関数と動的バインド

匿名関数は、動的にバインドされた操作のレシーバー、引数、またはオペランドにすることはできません。

### <a name="outer-variables"></a>外部変数

スコープに*lambda_expression*または*anonymous_method_expression*が含まれているすべてのローカル変数、値パラメーター、またはパラメーター配列は、匿名関数の***外部変数***と呼ばれます。 クラスのインスタンス関数メンバーでは、`this` 値は値パラメーターと見なされ、関数メンバー内に含まれるすべての匿名関数の外部変数になります。

#### <a name="captured-outer-variables"></a>キャプチャされた外部変数

外部変数が匿名関数によって参照されている場合、外部変数は匿名関数によって***キャプチャ***されたと言います。 通常、ローカル変数の有効期間は、関連付けられているブロックまたはステートメント ([ローカル変数](variables.md#local-variables)) の実行に制限されます。 ただし、取得した外部変数の有効期間は、匿名関数から作成されたデリゲートまたは式ツリーがガベージコレクションの対象になるまで、少なくとも拡張されます。

この例では、
```csharp
using System;

delegate int D();

class Test
{
    static D F() {
        int x = 0;
        D result = () => ++x;
        return result;
    }

    static void Main() {
        D d = F();
        Console.WriteLine(d());
        Console.WriteLine(d());
        Console.WriteLine(d());
    }
}
```
ローカル変数 `x` は匿名関数によってキャプチャされ、`F` から返されたデリゲートがガベージコレクションの対象になるまで、`x` の有効期間が少なくとも拡張されます (これは、プログラムの終わりまで発生しません)。 匿名関数の各呼び出しは `x`の同じインスタンスで動作するため、この例の出力は次のようになります。
```console
1
2
3
```

ローカル変数または値パラメーターが匿名関数によってキャプチャされると、ローカル変数またはパラメーターは固定変数 ([固定変数および](unsafe-code.md#fixed-and-moveable-variables)移動可能変数) とは見なされなくなりますが、代わりに移動可能な変数と見なされます。 したがって、キャプチャされた外部変数のアドレスを取得する `unsafe` コードでは、まず `fixed` ステートメントを使用して変数を修正する必要があります。

Uncaptured 変数とは異なり、キャプチャされたローカル変数は複数の実行スレッドに同時に公開できます。

#### <a name="instantiation-of-local-variables"></a>ローカル変数のインスタンス化

ローカル変数は、実行時に変数のスコープに入ると、***インスタンス化***されると見なされます。 たとえば、次のメソッドが呼び出されると、ローカル変数 `x` がインスタンス化され、ループの反復ごとに3回初期化されます。

```csharp
static void F() {
    for (int i = 0; i < 3; i++) {
        int x = i * 2 + 1;
        ...
    }
}
```

ただし、`x` の宣言をループの外側に移動すると、`x`の1つのインスタンスが生成されます。
```csharp
static void F() {
    int x;
    for (int i = 0; i < 3; i++) {
        x = i * 2 + 1;
        ...
    }
}
```

キャプチャされていない場合、ローカル変数がインスタンス化される頻度を正確に観察する方法はありません。インスタンス化の有効期間が不整合になるため、各インスタンス化で同じストレージの場所を使用することができます。 ただし、匿名関数がローカル変数をキャプチャすると、インスタンス化の効果が明らかになります。

例
```csharp
using System;

delegate void D();

class Test
{
    static D[] F() {
        D[] result = new D[3];
        for (int i = 0; i < 3; i++) {
            int x = i * 2 + 1;
            result[i] = () => { Console.WriteLine(x); };
        }
        return result;
    }

    static void Main() {
        foreach (D d in F()) d();
    }
}
```
この例では、次のように出力されます。
```console
1
3
5
```

ただし、`x` の宣言をループの外側に移動した場合は、次のようになります。
```csharp
static D[] F() {
    D[] result = new D[3];
    int x;
    for (int i = 0; i < 3; i++) {
        x = i * 2 + 1;
        result[i] = () => { Console.WriteLine(x); };
    }
    return result;
}
```
この場合、出力は次のようになります。
```console
5
5
5
```

For ループが反復変数を宣言している場合、その変数自体がループの外側で宣言されていると見なされます。 したがって、反復変数自体をキャプチャするように例が変更された場合は、次のようになります。

```csharp
static D[] F() {
    D[] result = new D[3];
    for (int i = 0; i < 3; i++) {
        result[i] = () => { Console.WriteLine(i); };
    }
    return result;
}
```
次のように出力を生成する反復変数のインスタンスは1つだけキャプチャされます。
```console
3
3
3
```

匿名関数デリゲートは、キャプチャされたいくつかの変数を共有し、他の変数のインスタンスを個別に持つことができます。 たとえば、`F` がに変更された場合、次のようになります。
```csharp
static D[] F() {
    D[] result = new D[3];
    int x = 0;
    for (int i = 0; i < 3; i++) {
        int y = 0;
        result[i] = () => { Console.WriteLine("{0} {1}", ++x, ++y); };
    }
    return result;
}
```
この3つのデリゲートは、`x` の同じインスタンスをキャプチャし、`y`のインスタンスを分離します。出力は次のようになります。
```console
1 1
2 1
3 1
```

個別の匿名関数は、外部変数の同じインスタンスをキャプチャできます。 次に例を示します。
```csharp
using System;

delegate void Setter(int value);

delegate int Getter();

class Test
{
    static void Main() {
        int x = 0;
        Setter s = (int value) => { x = value; };
        Getter g = () => { return x; };
        s(5);
        Console.WriteLine(g());
        s(10);
        Console.WriteLine(g());
    }
}
```
この2つの匿名関数は、ローカル変数 `x`の同じインスタンスをキャプチャし、その変数を使用して "通信" できます。 この例の出力は次のとおりです。
```console
5
10
```

### <a name="evaluation-of-anonymous-function-expressions"></a>匿名関数式の評価

匿名関数 `F` は、直接的に、またはデリゲート作成式 `new D(F)`の実行を通じて、デリゲート型 `D` または式ツリー `E`型に常に変換される必要があります。 この変換は、「[匿名関数の変換](conversions.md#anonymous-function-conversions)」で説明されているように、匿名関数の結果を決定します。

## <a name="query-expressions"></a>クエリ式

***クエリ式***には、SQL や XQuery などのリレーショナルクエリ言語と階層クエリ言語に似たクエリの言語統合構文が用意されています。

```antlr
query_expression
    : from_clause query_body
    ;

from_clause
    : 'from' type? identifier 'in' expression
    ;

query_body
    : query_body_clauses? select_or_group_clause query_continuation?
    ;

query_body_clauses
    : query_body_clause
    | query_body_clauses query_body_clause
    ;

query_body_clause
    : from_clause
    | let_clause
    | where_clause
    | join_clause
    | join_into_clause
    | orderby_clause
    ;

let_clause
    : 'let' identifier '=' expression
    ;

where_clause
    : 'where' boolean_expression
    ;

join_clause
    : 'join' type? identifier 'in' expression 'on' expression 'equals' expression
    ;

join_into_clause
    : 'join' type? identifier 'in' expression 'on' expression 'equals' expression 'into' identifier
    ;

orderby_clause
    : 'orderby' orderings
    ;

orderings
    : ordering (',' ordering)*
    ;

ordering
    : expression ordering_direction?
    ;

ordering_direction
    : 'ascending'
    | 'descending'
    ;

select_or_group_clause
    : select_clause
    | group_clause
    ;

select_clause
    : 'select' expression
    ;

group_clause
    : 'group' expression 'by' expression
    ;

query_continuation
    : 'into' identifier query_body
    ;
```

クエリ式が `from` 句で始まり、`select` または `group` 句のいずれかで終わります。 最初の `from` 句の後には、0個以上の `from`、`let`、`where`、`join` または `orderby` 句を指定できます。 各 `from` 句は、***シーケンス***の要素を範囲とする***範囲変数***を導入するジェネレーターです。 各 `let` 句には、前の範囲変数によって計算された値を表す範囲変数が導入されています。 各 `where` 句は、結果から項目を除外するフィルターです。 各 `join` 句は、ソースシーケンスの指定されたキーを別のシーケンスのキーと比較し、一致するペアを生成します。 各 `orderby` 句は、指定された条件に従って項目を並べ替えます。最後の `select` 句または `group` 句は、範囲変数の観点から結果の形状を指定します。 最後に、1つのクエリの結果を後続のクエリでジェネレーターとして扱うことによって、`into` 句を使用してクエリを "スプライス" できます。

### <a name="ambiguities-in-query-expressions"></a>クエリ式のあいまいさ

クエリ式には、さまざまな "コンテキストキーワード" が含まれています。つまり、特定のコンテキストで特別な意味を持つ識別子です。 具体的には、`from`、`where`、`join`、`on`、`equals`、`into`、`let`、`orderby`、`ascending`、`descending`、`select`、`group`、`by`です。 これらの識別子をキーワードまたは単純名として使用することによるクエリ式のあいまいさを回避するために、これらの識別子は、クエリ式内の任意の場所で出現するときにキーワードと見なされます。

このため、クエリ式は、"`from identifier`" で始まり、"`;`"、"`=`"、または "`,`" 以外の任意のトークンで始まる任意の式です。

これらの単語をクエリ式内で識別子として使用するために、プレフィックスとして "`@`" ([識別子](lexical-structure.md#identifiers)) を付けることができます。

### <a name="query-expression-translation"></a>クエリ式の変換

このC#言語では、クエリ式の実行セマンティクスが指定されていません。 代わりに、クエリ式は、クエリ*式パターン*([クエリ式パターン](expressions.md#the-query-expression-pattern)) に準拠するメソッドの呼び出しに変換されます。 具体的には、クエリ式は、`Where`、`Select`、`SelectMany`、`Join`、`GroupJoin`、`OrderBy`、`OrderByDescending`、`ThenBy`、`ThenByDescending`、`GroupBy`、`Cast`という名前のメソッドの呼び出しに変換されます。これらのメソッドには、[クエリ式パターン](expressions.md#the-query-expression-pattern)で説明されているように、特定のシグネチャと結果型が必要です。 これらのメソッドは、クエリを実行するオブジェクトのインスタンスメソッド、またはオブジェクトの外部にある拡張メソッドにすることができ、クエリの実際の実行を実装します。

クエリ式からメソッド呼び出しへの変換は、型のバインディングまたはオーバーロードの解決が行われる前に行われる構文のマッピングです。 変換は構文的に正しいことが保証されていますが、意味のC#ある正しいコードを生成することは保証されていません。 クエリ式の変換に続くと、結果として得られるメソッド呼び出しは通常のメソッド呼び出しとして処理され、メソッドが存在しない場合、引数の型が正しくない場合、またはメソッドがジェネリックで、型の推定は失敗します。

クエリ式は、さらに縮小することができなくなるまで、次の変換を繰り返し適用することで処理されます。 翻訳はアプリケーション順に一覧表示されます。各セクションでは、前のセクションで説明した翻訳が徹底的に実行されたことを前提としています。また、1つのセクションは、後で同じクエリ式の処理中に再検討されることはありません。

範囲変数への代入は、クエリ式では許可されていません。 ただし、 C#実装では、この制限を常に適用しないようにすることができます。これは、ここで説明する構文変換スキームでは不可能な場合があるためです。

特定の翻訳では、`*`によって示される透過的な識別子を使用して範囲変数が挿入されます。 透過的な識別子の特別なプロパティについては、「[透過的識別子](expressions.md#transparent-identifiers)」で詳しく説明します。

#### <a name="select-and-groupby-clauses-with-continuations"></a>継続を含む Select および groupby 句

継続を含むクエリ式
```csharp
from ... into x ...
```
はに変換されます。
```csharp
from x in ( from ... ) ...
```

以降のセクションの変換では、クエリに `into` 継続がないことを前提としています。

例
```csharp
from c in customers
group c by c.Country into g
select new { Country = g.Key, CustCount = g.Count() }
```
はに変換されます。
```csharp
from g in
    from c in customers
    group c by c.Country
select new { Country = g.Key, CustCount = g.Count() }
```
最終的な変換は、
```csharp
customers.
GroupBy(c => c.Country).
Select(g => new { Country = g.Key, CustCount = g.Count() })
```

#### <a name="explicit-range-variable-types"></a>明示的な範囲変数の型

範囲変数の型を明示的に指定する `from` 句
```csharp
from T x in e
```
はに変換されます。
```csharp
from x in ( e ) . Cast < T > ( )
```

範囲変数の型を明示的に指定する `join` 句
```csharp
join T x in e on k1 equals k2
```
はに変換されます。
```csharp
join x in ( e ) . Cast < T > ( ) on k1 equals k2
```

以降のセクションの変換では、クエリに明示的な範囲変数の型がないと想定しています。

例
```csharp
from Customer c in customers
where c.City == "London"
select c
```
はに変換されます。
```csharp
from c in customers.Cast<Customer>()
where c.City == "London"
select c
```
最終的な変換は、
```csharp
customers.
Cast<Customer>().
Where(c => c.City == "London")
```

明示的な範囲変数型は、非ジェネリック `IEnumerable` インターフェイスを実装するコレクションに対してクエリを実行する場合に便利ですが、ジェネリック `IEnumerable<T>` インターフェイスを実装することはできません。 上記の例では、`customers` が `ArrayList`型である場合、これが当てはまります。

#### <a name="degenerate-query-expressions"></a>逆クエリ式

フォームのクエリ式
```csharp
from x in e select x
```
はに変換されます。
```csharp
( e ) . Select ( x => x )
```

例
```csharp
from c in customers
select c
```
はに変換されます。
```csharp
customers.Select(c => c)
```

逆クエリ式とは、ソースの要素を普通に選択したものです。 変換の後の段階では、他の変換ステップによって導入された逆のクエリをソースに置き換えることによって削除します。 ただし、クエリ式の結果がソースオブジェクト自体にならないようにすることが重要です。これにより、クエリのクライアントに対するソースの型と id が明らかになります。 したがって、この手順では、ソースで `Select` を明示的に呼び出すことによって、ソースコードに直接書き込まれた低次元クエリを保護します。 その後、これらのメソッドがソースオブジェクト自体を返さないようにするために、`Select` およびその他のクエリ演算子を実装する必要があります。

#### <a name="from-let-where-join-and-orderby-clauses"></a>From、let、where、join、orderby 句

2番目の `from` 句の後に `select` 句を指定したクエリ式
```csharp
from x1 in e1
from x2 in e2
select v
```
はに変換されます。
```csharp
( e1 ) . SelectMany( x1 => e2 , ( x1 , x2 ) => v )
```

2番目の `from` 句の後に `select` 句以外のものが続くクエリ式:

```csharp
from x1 in e1
from x2 in e2
...
```
はに変換されます。
```csharp
from * in ( e1 ) . SelectMany( x1 => e2 , ( x1 , x2 ) => new { x1 , x2 } )
...
```

`let` 句を含むクエリ式
```csharp
from x in e
let y = f
...
```
はに変換されます。
```csharp
from * in ( e ) . Select ( x => new { x , y = f } )
...
```

`where` 句を含むクエリ式
```csharp
from x in e
where f
...
```
はに変換されます。
```csharp
from x in ( e ) . Where ( x => f )
...
```

`into` の後に `select` 句が指定されていない `join` 句を含むクエリ式
```csharp
from x1 in e1
join x2 in e2 on k1 equals k2
select v
```
はに変換されます。
```csharp
( e1 ) . Join( e2 , x1 => k1 , x2 => k2 , ( x1 , x2 ) => v )
```

`into` の後に `select` 句以外のものが指定されていない `join` 句を含むクエリ式
```csharp
from x1 in e1
join x2 in e2 on k1 equals k2
...
```
はに変換されます。
```csharp
from * in ( e1 ) . Join( e2 , x1 => k1 , x2 => k2 , ( x1 , x2 ) => new { x1 , x2 })
...
```

`into` の後に `select` 句が続く `join` 句を含むクエリ式
```csharp
from x1 in e1
join x2 in e2 on k1 equals k2 into g
select v
```
はに変換されます。
```csharp
( e1 ) . GroupJoin( e2 , x1 => k1 , x2 => k2 , ( x1 , g ) => v )
```

`into` の後に `select` 句以外のものが含まれている `join` 句を含むクエリ式
```csharp
from x1 in e1
join x2 in e2 on k1 equals k2 into g
...
```
はに変換されます。
```csharp
from * in ( e1 ) . GroupJoin( e2 , x1 => k1 , x2 => k2 , ( x1 , g ) => new { x1 , g })
...
```

`orderby` 句を含むクエリ式
```csharp
from x in e
orderby k1 , k2 , ..., kn
...
```
はに変換されます。
```csharp
from x in ( e ) . 
OrderBy ( x => k1 ) . 
ThenBy ( x => k2 ) .
... .
ThenBy ( x => kn )
...
```

順序句で `descending` 方向インジケーターが指定されている場合は、代わりに `OrderByDescending` または `ThenByDescending` の呼び出しが生成されます。

次の変換では、`let`、`where`、`join`、または `orderby` 句がなく、各クエリ式に1つの初期 `from` 句が含まれていないことを前提としています。

例
```csharp
from c in customers
from o in c.Orders
select new { c.Name, o.OrderID, o.Total }
```
はに変換されます。
```csharp
customers.
SelectMany(c => c.Orders,
     (c,o) => new { c.Name, o.OrderID, o.Total }
)
```

例
```csharp
from c in customers
from o in c.Orders
orderby o.Total descending
select new { c.Name, o.OrderID, o.Total }
```
はに変換されます。
```csharp
from * in customers.
    SelectMany(c => c.Orders, (c,o) => new { c, o })
orderby o.Total descending
select new { c.Name, o.OrderID, o.Total }
```
最終的な変換は、
```csharp
customers.
SelectMany(c => c.Orders, (c,o) => new { c, o }).
OrderByDescending(x => x.o.Total).
Select(x => new { x.c.Name, x.o.OrderID, x.o.Total })
```
ここで `x` はコンパイラによって生成される識別子であり、それ以外は非表示でアクセスできません。

例
```csharp
from o in orders
let t = o.Details.Sum(d => d.UnitPrice * d.Quantity)
where t >= 1000
select new { o.OrderID, Total = t }
```
はに変換されます。
```csharp
from * in orders.
    Select(o => new { o, t = o.Details.Sum(d => d.UnitPrice * d.Quantity) })
where t >= 1000 
select new { o.OrderID, Total = t }
```
最終的な変換は、
```csharp
orders.
Select(o => new { o, t = o.Details.Sum(d => d.UnitPrice * d.Quantity) }).
Where(x => x.t >= 1000).
Select(x => new { x.o.OrderID, Total = x.t })
```
ここで `x` はコンパイラによって生成される識別子であり、それ以外は非表示でアクセスできません。

例
```csharp
from c in customers
join o in orders on c.CustomerID equals o.CustomerID
select new { c.Name, o.OrderDate, o.Total }
```
はに変換されます。
```csharp
customers.Join(orders, c => c.CustomerID, o => o.CustomerID,
    (c, o) => new { c.Name, o.OrderDate, o.Total })
```

例
```csharp
from c in customers
join o in orders on c.CustomerID equals o.CustomerID into co
let n = co.Count()
where n >= 10
select new { c.Name, OrderCount = n }
```
はに変換されます。
```csharp
from * in customers.
    GroupJoin(orders, c => c.CustomerID, o => o.CustomerID,
        (c, co) => new { c, co })
let n = co.Count()
where n >= 10 
select new { c.Name, OrderCount = n }
```
最終的な変換は、
```csharp
customers.
GroupJoin(orders, c => c.CustomerID, o => o.CustomerID,
    (c, co) => new { c, co }).
Select(x => new { x, n = x.co.Count() }).
Where(y => y.n >= 10).
Select(y => new { y.x.c.Name, OrderCount = y.n)
```
`x` と `y` は、非表示でアクセスできない、コンパイラによって生成される識別子です。

例
```csharp
from o in orders
orderby o.Customer.Name, o.Total descending
select o
```
最終翻訳
```csharp
orders.
OrderBy(o => o.Customer.Name).
ThenByDescending(o => o.Total)
```

#### <a name="select-clauses"></a>Select 句

フォームのクエリ式
```csharp
from x in e select v
```
はに変換されます。
```csharp
( e ) . Select ( x => v )
```
v が識別子 x の場合を除き、変換は単純です。
```csharp
( e )
```

次に例を示します。
```csharp
from c in customers.Where(c => c.City == "London")
select c
```
は単にに変換されます。
```csharp
customers.Where(c => c.City == "London")
```

#### <a name="groupby-clauses"></a>Groupby 句

フォームのクエリ式
```csharp
from x in e group v by k
```
はに変換されます。
```csharp
( e ) . GroupBy ( x => k , x => v )
```
v が識別子 x である場合を除き、変換は
```csharp
( e ) . GroupBy ( x => k )
```

例
```csharp
from c in customers
group c.Name by c.Country
```
はに変換されます。
```csharp
customers.
GroupBy(c => c.Country, c => c.Name)
```

#### <a name="transparent-identifiers"></a>透過的な識別子

特定の翻訳では、`*`によって示される***透過的な識別子***を使用して範囲変数が挿入されます。 透過的な識別子は、適切な言語機能ではありません。これらは、クエリ式の変換プロセスの中間手順としてのみ存在します。

クエリ変換によって透過的識別子が挿入されると、その後の変換ステップによって透過的識別子が匿名関数および匿名オブジェクト初期化子に反映されます。 これらのコンテキストでは、透過的な識別子の動作は次のようになります。

*  匿名関数のパラメーターとして透過的識別子が発生した場合、関連付けられた匿名型のメンバーは、匿名関数の本体のスコープ内に自動的に含まれます。
*  透過的な識別子を持つメンバーがスコープ内にある場合、そのメンバーのメンバーもスコープ内にあります。
*  透過的な識別子が匿名オブジェクト初期化子のメンバー宣言子として発生すると、透過的な識別子を持つメンバーが導入されます。
*  前述の変換手順では、透過的識別子は常に匿名型と共に導入され、複数の範囲変数を1つのオブジェクトのメンバーとしてキャプチャすることを目的としています。 のC#実装では、匿名型とは異なる機構を使用して複数の範囲変数をグループ化することが許可されています。 次の変換例では、匿名型が使用されていることを前提として、透過的な識別子をどのように変換できるかを示します。

例
```csharp
from c in customers
from o in c.Orders
orderby o.Total descending
select new { c.Name, o.Total }
```
はに変換されます。
```csharp
from * in customers.
    SelectMany(c => c.Orders, (c,o) => new { c, o })
orderby o.Total descending
select new { c.Name, o.Total }
```

これは、さらにに変換されます。
```csharp
customers.
SelectMany(c => c.Orders, (c,o) => new { c, o }).
OrderByDescending(* => o.Total).
Select(* => new { c.Name, o.Total })
```
これは、透過的な識別子が消去されると、
```csharp
customers.
SelectMany(c => c.Orders, (c,o) => new { c, o }).
OrderByDescending(x => x.o.Total).
Select(x => new { x.c.Name, x.o.Total })
```
ここで `x` はコンパイラによって生成される識別子であり、それ以外は非表示でアクセスできません。

例
```csharp
from c in customers
join o in orders on c.CustomerID equals o.CustomerID
join d in details on o.OrderID equals d.OrderID
join p in products on d.ProductID equals p.ProductID
select new { c.Name, o.OrderDate, p.ProductName }
```
はに変換されます。
```csharp
from * in customers.
    Join(orders, c => c.CustomerID, o => o.CustomerID, 
        (c, o) => new { c, o })
join d in details on o.OrderID equals d.OrderID
join p in products on d.ProductID equals p.ProductID
select new { c.Name, o.OrderDate, p.ProductName }
```
これは、
```csharp
customers.
Join(orders, c => c.CustomerID, o => o.CustomerID, (c, o) => new { c, o }).
Join(details, * => o.OrderID, d => d.OrderID, (*, d) => new { *, d }).
Join(products, * => d.ProductID, p => p.ProductID, (*, p) => new { *, p }).
Select(* => new { c.Name, o.OrderDate, p.ProductName })
```
最終的な変換は、
```csharp
customers.
Join(orders, c => c.CustomerID, o => o.CustomerID,
    (c, o) => new { c, o }).
Join(details, x => x.o.OrderID, d => d.OrderID,
    (x, d) => new { x, d }).
Join(products, y => y.d.ProductID, p => p.ProductID,
    (y, p) => new { y, p }).
Select(z => new { z.y.x.c.Name, z.y.x.o.OrderDate, z.p.ProductName })
```
`x`、`y`、および `z` は、それ以外は非表示でアクセスできない、コンパイラによって生成される識別子です。

### <a name="the-query-expression-pattern"></a>クエリ式パターン

***クエリ式パターン***は、型がクエリ式をサポートするために実装できるメソッドのパターンを確立します。 クエリ式は構文マッピングによってメソッドの呼び出しに変換されるため、型はクエリ式パターンを実装する方法において非常に柔軟です。 たとえば、パターンのメソッドは、インスタンスメソッドとして実装することも、拡張メソッドとして実装することもできます。これは、2つの呼び出し構文が同じであるためです。また、匿名関数は両方に変換可能であるため、メソッドはデリゲートまたは式ツリーを要求できます。

次に、クエリ式パターンをサポートするジェネリック型 `C<T>` の推奨される図形を示します。 ジェネリック型は、パラメーターと結果の型の間の適切なリレーションシップを示すために使用されますが、非ジェネリック型のパターンを実装することもできます。

```csharp
delegate R Func<T1,R>(T1 arg1);

delegate R Func<T1,T2,R>(T1 arg1, T2 arg2);

class C
{
    public C<T> Cast<T>();
}

class C<T> : C
{
    public C<T> Where(Func<T,bool> predicate);

    public C<U> Select<U>(Func<T,U> selector);

    public C<V> SelectMany<U,V>(Func<T,C<U>> selector,
        Func<T,U,V> resultSelector);

    public C<V> Join<U,K,V>(C<U> inner, Func<T,K> outerKeySelector,
        Func<U,K> innerKeySelector, Func<T,U,V> resultSelector);

    public C<V> GroupJoin<U,K,V>(C<U> inner, Func<T,K> outerKeySelector,
        Func<U,K> innerKeySelector, Func<T,C<U>,V> resultSelector);

    public O<T> OrderBy<K>(Func<T,K> keySelector);

    public O<T> OrderByDescending<K>(Func<T,K> keySelector);

    public C<G<K,T>> GroupBy<K>(Func<T,K> keySelector);

    public C<G<K,E>> GroupBy<K,E>(Func<T,K> keySelector,
        Func<T,E> elementSelector);
}

class O<T> : C<T>
{
    public O<T> ThenBy<K>(Func<T,K> keySelector);

    public O<T> ThenByDescending<K>(Func<T,K> keySelector);
}

class G<K,T> : C<T>
{
    public K Key { get; }
}
```

上記のメソッドでは、ジェネリックデリゲート型 `Func<T1,R>` および `Func<T1,T2,R>`が使用されますが、パラメーターと結果型では、他のデリゲート型または式ツリー型を同じリレーションシップで使用することもできます。

`C<T>` と `O<T>` の間に推奨されるリレーションシップがあることに注意してください。これにより、`ThenBy` および `ThenByDescending` メソッドを、`OrderBy` または `OrderByDescending`の結果でのみ使用できるようになります。 また、`GroupBy` の結果の推奨される図形に注目してください。各内部シーケンスには、追加の `Key` プロパティがあります。

`System.Linq` 名前空間は、`System.Collections.Generic.IEnumerable<T>` インターフェイスを実装する任意の型に対するクエリ演算子パターンの実装を提供します。

## <a name="assignment-operators"></a>代入演算子

代入演算子は、変数、プロパティ、イベント、またはインデクサー要素に新しい値を代入します。

```antlr
assignment
    : unary_expression assignment_operator expression
    ;

assignment_operator
    : '='
    | '+='
    | '-='
    | '*='
    | '/='
    | '%='
    | '&='
    | '|='
    | '^='
    | '<<='
    | right_shift_assignment
    ;
```

代入の左オペランドは、変数、プロパティアクセス、インデクサーアクセス、またはイベントアクセスとして分類される式である必要があります。

`=` 演算子は、***単純代入演算子***と呼ばれます。 右オペランドの値を、左オペランドによって指定された変数、プロパティ、またはインデクサー要素に代入します。 単純代入演算子の左オペランドは、イベントアクセスでない可能性があります (「[フィールドに似たイベント](classes.md#field-like-events)」で説明されている場合を除く)。 単純な代入演算子については、「[単純な代入](expressions.md#simple-assignment)」を参照してください。

`=` 演算子以外の代入演算子は、***複合代入演算子***と呼ばれます。 これらの演算子は、2つのオペランドに対して指定された演算を実行し、結果の値を、左オペランドによって指定された変数、プロパティ、またはインデクサー要素に代入します。 複合代入演算子の詳細については、「[複合代入](expressions.md#compound-assignment)」を参照してください。

左オペランドとしてイベントアクセス式を持つ `+=` 演算子と `-=` 演算子は、*イベント代入演算子*と呼ばれます。 左オペランドとしてイベントアクセスが有効な他の代入演算子はありません。 イベント代入演算子の詳細については、「[イベントの割り当て](expressions.md#event-assignment)」を参照してください。

代入演算子は、右から左にグループ化されます。 たとえば、`a = b = c` フォームの式は `a = (b = c)`として評価されます。

### <a name="simple-assignment"></a>単純代入

`=` 演算子は、単純代入演算子と呼ばれます。

単純な代入の左側のオペランドが `E.P` または `E[Ei]` の形式であり、`E` にコンパイル時の型 `dynamic`がある場合、割り当ては動的にバインドされます ([動的バインド](expressions.md#dynamic-binding))。 この場合、代入式のコンパイル時の型は `dynamic`であり、以下に説明する解決方法は、`E`の実行時の型に基づいて実行時に行われます。

単純な代入では、右オペランドは左オペランドの型に暗黙的に変換できる式である必要があります。 操作は、左オペランドによって指定された変数、プロパティ、またはインデクサー要素に右オペランドの値を割り当てます。

単純な代入式の結果は、左側のオペランドに割り当てられた値になります。 結果は左オペランドと同じ型であり、常に値として分類されます。

左オペランドがプロパティまたはインデクサーアクセスの場合、プロパティまたはインデクサーには `set` アクセサーが必要です。 そうでない場合は、バインド時エラーが発生します。

フォーム `x = y` の単純な割り当ての実行時処理は、次の手順で構成されています。

*  `x` が変数として分類される場合は、次のようになります。
   * 変数を生成するために `x` が評価されます。
   * `y` が評価され、必要に応じて、暗黙的な変換 ([暗黙](conversions.md#implicit-conversions)の変換) によって `x` の型に変換されます。
   * `x` によって指定された変数が*reference_type*の配列要素である場合は、`y` に対して計算された値が、`x` が要素である配列インスタンスと互換性があることを確認するために、実行時チェックが実行されます。 `y` が `null`場合、または `y` によって参照されるインスタンスの実際の型から `x`を含む配列インスタンスの実際の要素型への暗黙の参照変換 ([暗黙的な参照](conversions.md#implicit-reference-conversions)変換) が存在する場合、チェックは成功します。 それ以外の場合は、`System.ArrayTypeMismatchException` がスローされます。
   * `y` の評価および変換の結果として得られる値は、`x`の評価によって指定された場所に格納されます。
*  `x` がプロパティまたはインデクサーアクセスとして分類される場合は、次のようになります。
   * インスタンス式 (`x` が `static`でない場合) と `x` に関連付けられている引数リスト (`x` がインデクサーアクセスの場合) が評価され、その結果が後続の `set` アクセサー呼び出しで使用されます。
   * `y` が評価され、必要に応じて、暗黙的な変換 ([暗黙](conversions.md#implicit-conversions)の変換) によって `x` の型に変換されます。
   * `x` の `set` アクセサーは、`value` 引数として `y` に対して計算された値を使用して呼び出されます。

配列のクロス分散規則 ([配列の共変性](arrays.md#array-covariance)) では、配列型の値を `A[]` 配列型のインスタンスへの参照にすることが許可されています。これは、`B` から `A`への暗黙的な参照変換が存在する場合に `B[]`です。 これらのルールにより、 *reference_type*の配列要素への代入では、割り当てられている値が配列インスタンスと互換性があることを確認するためにランタイムチェックが必要になります。 この例では、
```csharp
string[] sa = new string[10];
object[] oa = sa;

oa[0] = null;               // Ok
oa[1] = "Hello";            // Ok
oa[2] = new ArrayList();    // ArrayTypeMismatchException
```
`ArrayList` のインスタンスを `string[]`の要素に格納することはできないため、最後の割り当てによって `System.ArrayTypeMismatchException` がスローされます。

*Struct_type*で宣言されたプロパティまたはインデクサーが割り当てのターゲットである場合は、プロパティまたはインデクサーアクセスに関連付けられているインスタンス式を変数として分類する必要があります。 インスタンス式が値として分類されている場合、バインド時エラーが発生します。 [メンバーアクセス](expressions.md#member-access)により、同じ規則がフィールドにも適用されます。

次の宣言を指定します。
```csharp
struct Point
{
    int x, y;

    public Point(int x, int y) {
        this.x = x;
        this.y = y;
    }

    public int X {
        get { return x; }
        set { x = value; }
    }

    public int Y {
        get { return y; }
        set { y = value; }
    }
}

struct Rectangle
{
    Point a, b;

    public Rectangle(Point a, Point b) {
        this.a = a;
        this.b = b;
    }

    public Point A {
        get { return a; }
        set { a = value; }
    }

    public Point B {
        get { return b; }
        set { b = value; }
    }
}
```
この例では、
```csharp
Point p = new Point();
p.X = 100;
p.Y = 100;
Rectangle r = new Rectangle();
r.A = new Point(10, 10);
r.B = p;
```
`p.X`、`p.Y`、`r.A`、および `r.B` への割り当ては、`p` と `r` が変数であるため、許可されます。 ただし、この例では
```csharp
Rectangle r = new Rectangle();
r.A.X = 10;
r.A.Y = 10;
r.B.X = 100;
r.B.Y = 100;
```
`r.A` と `r.B` は変数ではないため、割り当てはすべて無効です。

### <a name="compound-assignment"></a>複合代入。

複合代入の左オペランドが `E.P` または `E[Ei]` の形式で、`E` がコンパイル時の型 `dynamic`を持つ場合、割り当ては動的にバインドされます ([動的バインド](expressions.md#dynamic-binding))。 この場合、代入式のコンパイル時の型は `dynamic`であり、以下に説明する解決方法は、`E`の実行時の型に基づいて実行時に行われます。

`x op= y` フォームの操作は、演算が `x op y`書き込まれたかのように、二項演算子のオーバーロードの解決 ([二項演算子のオーバーロードの解決](expressions.md#binary-operator-overload-resolution)) を適用することによって処理されます。 このとき、次のようになります。

*  選択した演算子の戻り値の型が `x`の型に暗黙的に変換可能な場合、`x` が1回だけ評価される点を除いて、操作は `x = x op y`として評価されます。
*  また、選択した演算子が定義済みの演算子である場合、選択した演算子の戻り値の型が `x`の型に明示的に変換可能で、`y` が `x` の型に暗黙的に変換可能であるか、または演算子がシフト演算子の場合は、`T` が1回だけ評価される点を除い `x = (T)(x op y)`て、`x`は `x` の型です
*  それ以外の場合、複合代入は無効であり、バインド時エラーが発生します。

"評価された1回のみ" という用語は、`x op y`の評価では、`x` の構成式の結果が一時的に保存され、`x`への割り当てを実行するときに再利用されることを意味します。 `A()[B()] += C()`たとえば、`A` が `int[]`を返すメソッドであり、`B` および `C` が `int`を返すメソッドである場合、メソッドは、順序 `A`、`B`、`C`で一度だけ呼び出されます。

複合代入の左オペランドがプロパティアクセスまたはインデクサーアクセスの場合、プロパティまたはインデクサーには `get` アクセサーと `set` アクセサーの両方が必要です。 そうでない場合は、バインド時エラーが発生します。

上記の2番目のルールでは、`x op= y` を特定のコンテキストで `x = (T)(x op y)` として評価することを許可します。 この規則は、左側のオペランドの型が `sbyte`、`byte`、`short`、`ushort`、または `char`の場合に、定義済みの演算子を複合演算子として使用できるようにするために存在します。 両方の引数がこれらの型のいずれかであっても、定義済みの演算子は、「[バイナリ数値の上位](expressions.md#binary-numeric-promotions)変換」で説明されているように `int`型の結果を生成します。 したがって、キャストがないと、結果を左オペランドに代入できません。

定義済みの演算子のルールの直感的な効果は、`x op y` と `x = y` の両方が許可されている場合に `x op= y` が許可されることです。 この例では、
```csharp
byte b = 0;
char ch = '\0';
int i = 0;

b += 1;             // Ok
b += 1000;          // Error, b = 1000 not permitted
b += i;             // Error, b = i not permitted
b += (byte)i;       // Ok

ch += 1;            // Error, ch = 1 not permitted
ch += (char)1;      // Ok
```
各エラーの直感的な理由は、対応する単純な割り当てもエラーになることです。

これは、複合代入演算でリフト演算がサポートされていることも意味します。 この例では、
```csharp
int? i = 0;
i += 1;             // Ok
```
リフトされた演算子 `+(int?,int?)` が使用されます。

### <a name="event-assignment"></a>イベントの割り当て

`+=` または `-=` 演算子の左オペランドがイベントアクセスとして分類されている場合、式は次のように評価されます。

*  イベントアクセスのインスタンス式 (存在する場合) が評価されます。
*  `+=` または `-=` 演算子の右オペランドが評価され、必要に応じて、暗黙的な変換 ([暗黙](conversions.md#implicit-conversions)の変換) によって左オペランドの型に変換されます。
*  イベントのイベントアクセサーが呼び出されます。引数リストは右オペランド、評価後、必要に応じて変換されます。 演算子が `+=`場合は、`add` アクセサーが呼び出されます。演算子が `-=`されている場合は、`remove` アクセサーが呼び出されます。

イベントの割り当て式では、値は生成されません。 したがって、イベントの割り当て式は、 *statement_expression* ([式ステートメント](statements.md#expression-statements)) のコンテキストでのみ有効です。

## <a name="expression"></a>[式]

*式*は、 *non_assignment_expression*または*代入*のいずれかです。

```antlr
expression
    : non_assignment_expression
    | assignment
    ;

non_assignment_expression
    : conditional_expression
    | lambda_expression
    | query_expression
    ;
```

## <a name="constant-expressions"></a>定数式

*Constant_expression*は、コンパイル時に完全に評価できる式です。

```antlr
constant_expression
    : expression
    ;
```

定数式は、`null` リテラル、または次のいずれかの型の値である必要があります: `sbyte`、`byte`、`short`、`ushort`、`int`、`uint`、`long`、`ulong`、`char`、`float`、`double`、または任意の列挙型。 定数式では、次のコンストラクトのみを使用できます。

*  リテラル (`null` リテラルを含む)。
*  クラス型および構造体型の `const` メンバーへの参照。
*  列挙型のメンバーへの参照。
*  `const` パラメーターまたはローカル変数への参照
*  かっこで囲まれたサブ式は、それ自体が定数式です。
*  キャスト式は、ターゲット型が上記のいずれかの型である場合に指定します。
*  `checked` と `unchecked` 式
*  既定値の式
*  すべてのの表記
*  定義済みの `+`、`-`、`!`、および `~` 単項演算子。
*  定義済みの `+`、`-`、`*`、`/`、`%`、`<<`、`>>`、`&`、`|`、`^`、`&&`、`||`、`==`、`!=`、`<`、`>`、`<=`、`>=` の各オペランドが上記の型である場合は、二項演算子が定義されています。
*  `?:` 条件演算子。

定数式では、次の変換が許可されます。

*  Id 変換
*  数値変換
*  列挙型変換
*  定数式の変換
*  変換元が null 値に評価される定数式である場合、暗黙的および明示的な参照変換。

非 null 値のボックス化、ボックス化解除、および暗黙的な参照変換を含むその他の変換は、定数式では許可されません。 例:
```csharp
class C {
    const object i = 5;         // error: boxing conversion not permitted
    const object str = "hello"; // error: implicit reference conversion
}
```
ボックス化変換が必要なため、i の初期化はエラーになります。 Null 以外の値からの暗黙的な参照変換が必要であるため、str の初期化はエラーになります。

式が上記の要件を満たしている場合は、コンパイル時に式が評価されます。 これは、式が定数以外の構造を含む大きな式のサブ式である場合にも当てはまります。

定数式のコンパイル時の評価では、非定数式の実行時の評価と同じ規則が使用されます。ただし、ランタイム評価で例外がスローされた場合は、コンパイル時の評価によってコンパイル時エラーが発生します。

定数式が `unchecked` コンテキストに明示的に配置されていない限り、式のコンパイル時の評価時に、整数型の算術演算および変換で発生したオーバーフローは、常にコンパイル時エラー ([定数式](expressions.md#constant-expressions)) を発生させます。

定数式は、以下に示すコンテキストで発生します。 これらのコンテキストでは、コンパイル時に式を完全に評価できない場合、コンパイル時エラーが発生します。

*  定数宣言 ([定数](classes.md#constants))。
*  列挙メンバー宣言 ([列挙型メンバー](enums.md#enum-members))。
*  仮パラメーターリストの既定の引数 ([メソッドパラメーター](classes.md#method-parameters))
*  `switch` ステートメント ([switch ステートメント](statements.md#the-switch-statement)) のラベルを `case` します。
*  `goto case` ステートメント ([goto ステートメント](statements.md#the-goto-statement))。
*  初期化子を含む配列作成式 ([配列作成](expressions.md#array-creation-expressions)式) の次元の長さ。
*  属性 ([属性](attributes.md))。

暗黙の定数式の変換 ([暗黙の定数](conversions.md#implicit-constant-expression-conversions)式の変換) を使用すると、定数式の値が変換先の型の範囲内にある場合に、`int` 型の定数式を `sbyte`、`byte`、`short`、`ushort`、`uint`、または `ulong`に変換できます。

## <a name="boolean-expressions"></a>ブール式

*Boolean_expression*は `bool`型の結果を生成する式です。次のように指定されている特定のコンテキストで、直接または `operator true` のアプリケーションによって実行します。

```antlr
boolean_expression
    : expression
    ;
```

*If_statement* ([if ステートメント](statements.md#the-if-statement))、 *while_statement* ([while ステートメント](statements.md#the-while-statement))、 *do_statement* ([do ステートメント](statements.md#the-do-statement))、または*for_statement* ([for ステートメント](statements.md#the-for-statement)) の制御条件式は、 *boolean_expression*です。 `?:` 演算子 ([条件演算子](expressions.md#conditional-operator)) の制御条件式は、 *boolean_expression*と同じ規則に従いますが、演算子の優先順位の理由は*conditional_or_expression*として分類されます。

次のように `bool`型の値を生成できるようにするには、 *boolean_expression* `E` が必要です。

*  `E` が暗黙的 `bool` に変換可能な場合は、実行時に暗黙的な変換が適用されます。
*  それ以外の場合は、単項演算子のオーバーロードの解決 ([単項演算子のオーバーロードの解決](expressions.md#unary-operator-overload-resolution)) を使用して、`E`での演算子 `true` の一意の最適な実装を検索し、その実装を実行時に適用します。
*  そのような演算子が見つからない場合は、バインド時エラーが発生します。

[データベースブール型](structs.md#database-boolean-type)の `DBBool` 構造体型は、`operator true` と `operator false`を実装する型の例を提供します。
