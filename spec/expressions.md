---
ms.openlocfilehash: 67019511d49a786a5d6edf6fea442f745fc40f3f
ms.sourcegitcommit: 0a80f26b8e455c4f09843a10e11e29c24d2d922e
ms.translationtype: HT
ms.contentlocale: ja-JP
ms.lasthandoff: 03/05/2019
ms.locfileid: "57347275"
---
# <a name="expressions"></a>式

式は、演算子とオペランドのシーケンスです。 この章では、構文、オペランドと演算子の評価と式の意味の順序を定義します。

## <a name="expression-classifications"></a>式の分類

式は、次のいずれかに分類されます。

*  値。 すべての値には、型が関連付けられています。
*  変数です。 すべての変数は、関連付けられた型、変数の宣言型つまりを持っています。
*  名前空間。 この分類の式の左側にあることができますのみに、 *member_access* ([メンバー アクセス](expressions.md#member-access))。 他のコンテキストでは、名前空間として分類される式は、コンパイル時エラーを発生します。
*  型。 この分類の式の左側にあることができますのみに、 *member_access* ([メンバー アクセス](expressions.md#member-access))、またはオペランドとして、`as`演算子 ([演算子として、](expressions.md#the-as-operator))、`is`演算子 ([、演算子は、](expressions.md#the-is-operator))、または`typeof`演算子 ([typeof 演算子](expressions.md#the-typeof-operator))。 他のコンテキストでは、型として分類される式は、コンパイル時エラーを発生します。
*  一連のオーバー ロードされたメソッドをメンバー検索の結果は、メソッド グループ ([メンバー ルックアップ](expressions.md#member-lookup))。 メソッド グループには、関連付けられたインスタンス式と関連付けられている型の引数リストがあります。 インスタンス式の評価の結果になりますで表されるインスタンスがインスタンス メソッドが呼び出されたときに`this`([このアクセス](expressions.md#this-access))。 メソッド グループが許可されている、 *invocation_expression* ([Invocation 式](expressions.md#invocation-expressions))、 *delegate_creation_expression* ([デリゲートの作成式](expressions.md#delegate-creation-expressions)) の左側として、演算子、および互換性のあるデリゲート型に暗黙的に変換できます ([メソッド グループ変換](conversions.md#method-group-conversions))。 他のコンテキストでは、メソッド グループに分類される式は、コンパイル時エラーを発生します。
*  Null リテラルです。 この分類の式は、参照型または null 許容型に暗黙的に変換できます。
*  匿名関数です。 この分類の式は、互換性のあるデリゲート型または式ツリー型に暗黙的に変換できます。
*  プロパティ アクセス。 すべてのプロパティ アクセスは、関連付けられた型、つまり、プロパティの型を持ちます。 さらに、プロパティ アクセスには、関連付けられたインスタンス式があります。 アクセサー (、`get`または`set`ブロック) のインスタンスのプロパティへのアクセスが呼び出される、インスタンス式の評価の結果によって表されるインスタンスになります`this`([このアクセス](expressions.md#this-access))。
*  イベントへのアクセス。 イベントのすべてのアクセスが、関連付けられた型、つまり、イベントの種類。 さらに、イベントへのアクセスには、関連付けられたインスタンス式があります。 左側のオペランドとして、イベントへのアクセスがあります、`+=`と`-=`演算子 ([イベント割り当て](expressions.md#event-assignment))。 他のコンテキストでは、イベント アクセスとして分類される式は、コンパイル時エラーを発生します。
*  インデクサー アクセス。 すべてのインデクサー アクセスは、関連付けられた型、インデクサーの要素型つまりを持ちます。 さらに、インデクサー アクセスは、関連付けられたインスタンス式と、関連する引数リストがいます。 アクセサー (、`get`または`set`ブロック)、インデクサーのアクセスが呼び出される、インスタンス式の評価の結果によって表されるインスタンスになります`this`([このアクセス](expressions.md#this-access))、およびの結果引数リストを評価するには、呼び出しのパラメーター リストになります。
*  何もない。 これは、式の戻り値の型には、メソッドの呼び出しは、するときに発生します。`void`します。 コンテキストで有効では何もとして分類される式を*statement_expression* ([式ステートメント](statements.md#expression-statements))。

式の最終的な結果は、名前空間、型、メソッド グループ、またはイベントへのアクセスには。 代わりに、前述のように、これらの式のカテゴリには特定のコンテキストでのみ許可されている中間的な構造です。

プロパティ アクセスまたはインデクサーのアクセスは常に再分類を値としての呼び出しを実行することによって、 *get アクセサー*または*set アクセサー*します。 特定のアクセサーは、プロパティまたはインデクサーのアクセスのコンテキストによって決まります。アクセスが、割り当ての対象である場合、 *set アクセサー*新しい値を割り当てるために呼び出される ([単純な代入](expressions.md#simple-assignment))。 それ以外の場合、 *get アクセサー* 、現在の値を取得するために呼び出す ([式の値](expressions.md#values-of-expressions))。

### <a name="values-of-expressions"></a>式の値

式を伴う構造のほとんどは最終的に式を表すことを必要とする***値***します。 このような場合は、実際の式は、名前空間、型、メソッド グループ、または、何を表す場合、コンパイル時エラーが発生します。 ただし、式では、プロパティ アクセス、インデクサー アクセス、または変数を表して、プロパティ、インデクサー、または変数の値に暗黙的に代入します。

*  変数の値は、変数で識別される記憶域の場所に格納されている値だけです。 変数は、明示的に代入考慮する必要があります ([確実な代入](variables.md#definite-assignment)) 前に、その値を取得する、またはそれ以外の場合、コンパイル時エラーが発生します。
*  呼び出して、プロパティ アクセス式の値を取得、 *get アクセサー*プロパティ。 プロパティがにない場合*get アクセサー*コンパイル時エラーが発生します。 それ以外の場合、関数メンバーの呼び出し ([コンパイル時の動的なオーバー ロードの解決チェック](expressions.md#compile-time-checking-of-dynamic-overload-resolution)) が実行され、呼び出しの結果、プロパティ アクセス式の値になります。
*  呼び出してインデクサー アクセス式の値を取得、 *get アクセサー*のインデクサー。 インデクサーがにない場合*get アクセサー*コンパイル時エラーが発生します。 それ以外の場合、関数メンバーの呼び出し ([コンパイル時の動的なオーバー ロードの解決チェック](expressions.md#compile-time-checking-of-dynamic-overload-resolution)) 引数で実行されるインデクサー アクセス式に関連付けられているリストと呼び出しの結果値になりますインデクサー アクセス式。

## <a name="static-and-dynamic-binding"></a>静的および動的バインディング

型または構成する式 (引数、オペランド、受信側) の値に基づく操作の意味を決定するプロセスとして呼ば***バインド***します。 たとえば、受信側と引数の型に基づいて、メソッド呼び出しの意味が決まります。 演算子の意味では、そのオペランドの型に基づいて決定されます。

に基づいてその構成要素である式のコンパイル時の型にコンパイル時に、操作の意味が決定されます、通常、C# でします。 同様に、式にエラーが含まれている場合、エラーが検出され、コンパイラによって報告されました。 このアプローチと呼ばれる***静的バインディング***します。

ただし、式が動的な式である場合 (つまり、型を持つ`dynamic`) に含まれている任意のバインディングである型ではなくの実行時の型 (つまりの実際の型オブジェクトの実行時にことを示します) に基づく必要があることを示しますこのコンパイル時。 このような操作のバインディングはそのため、操作がプログラムの実行中に実行時まで延期されます。 呼ばれる***動的バインド***します。

操作が動的にバインドされている場合は、コンパイラによって実行がほとんどまたはまったくないチェックします。 代わりに、実行時間のバインドに失敗した場合、実行時に例外としてエラーが報告されます。

C# では、次の操作は、バインドが適用されます。

*  メンバー アクセス。 `e.M`
*  メソッドの呼び出し: `e.M(e1, ..., eN)`
*  デリゲートの呼び出し:`e(e1, ..., eN)`
*  要素へのアクセス: `e[e1, ..., eN]`
*  オブジェクトの作成: `new C(e1, ..., eN)`
*  オーバー ロードされた単項演算子: `+`、 `-`、 `!`、 `~`、 `++`、 `--`、 `true`、 `false`
*  オーバー ロードされた二項演算子: `+`、 `-`、 `*`、 `/`、 `%`、 `&`、 `&&`、 `|`、 `||`、 `??`、 `^`、 `<<`, `>>`, `==`,`!=`, `>`, `<`, `>=`, `<=`
*  代入演算子: `=`、 `+=`、 `-=`、 `*=`、 `/=`、 `%=`、 `&=`、 `|=`、 `^=`、 `<<=`、 `>>=`
*  明示的および暗黙的な変換

動的な式が使用されないときに C# 既定値は静的バインディングは、構成する式のコンパイル時の型が、選択プロセスで使用されることを意味します。 ただし、動的な式は、上記の操作で構成する式のいずれかが、操作は代わりに動的にバインドされます。

### <a name="binding-time"></a>バインディング時間

静的バインディングは、動的バインドが実行時に行いますが、コンパイル時に、配置します。 次のセクションで、用語***バインド時***コンパイル時または実行時にバインディングが行われる時期に応じてのいずれかを参照します。

次の例は、静的および動的バインディングおよびバインド時の概念を示しています。
```csharp
object  o = 5;
dynamic d = 5;

Console.WriteLine(5);  // static  binding to Console.WriteLine(int)
Console.WriteLine(o);  // static  binding to Console.WriteLine(object)
Console.WriteLine(d);  // dynamic binding to Console.WriteLine(int)
```

最初の 2 つの呼び出しが静的にバインドされている: のオーバー ロード`Console.WriteLine`引数のコンパイル時の型に基づいて取得されます。 したがって、バインド時は、コンパイル時です。

3 番目の呼び出しが動的にバインドされている: のオーバー ロード`Console.WriteLine`引数の実行時の型に基づいて取得されます。 引数は、動的な式--、コンパイル時の型は`dynamic`します。 そのため、3 番目の呼び出しのバインド時は、実行時です。

### <a name="dynamic-binding"></a>動的バインド

動的バインドの目的は、C# プログラムとの対話ができるように、***動的オブジェクト***、つまり、C# の通常の規則に従っていないオブジェクトがシステムを入力します。 さまざまな種類のシステムと他のプログラミング言語からオブジェクトを動的オブジェクトがあります。 またはさまざまな操作の独自のバインディング セマンティクスを実装するためにセットアップ プログラムであるオブジェクトがあります。

動的オブジェクトが自身のセマンティクスを実装するメカニズムは、実装定義です。 --もう一度実装定義 - 特定のインターフェイスは、C# で実行時に特別な意味があることを通知する動的オブジェクトによって実装されます。 したがっての動的オブジェクトの操作が動的にバインドされている、ときに、このドキュメントで指定されている C# のではなく、独自のバインディング セマンティクスを引き継ぎます。

動的バインドの目的は、動的オブジェクトとの相互運用を許可するが、C# では、動的バインド、すべてのオブジェクトでは動的かどうかどうか。 これにより、それらに対する操作の結果が、動的なオブジェクト自体ではありませんが、プログラマがコンパイル時に不明な型のままの動的オブジェクトは、スムーズに統合できます。 動的バインドが含まれるオブジェクトには、動的オブジェクトがない場合でも、リフレクション ベースのエラーを起こしやすいコードを排除を支援することができます。

動的バインドを適用した場合、何のコンパイル時のチェック - - いずれかが適用される場合と、どのようなコンパイル結果と式分類が正確には、言語では、各構成要素の次のセクションでは、について説明します。

### <a name="types-of-constituent-expressions"></a>構成要素である式の種類

操作が静的にバインドされている場合 (例: 受信側、引数、インデックスまたはオペランド) の構成要素である式の型は常と見なされますその式のコンパイル時の型。

操作が動的にバインドされている場合は、構成要素である式のコンパイル時の型に応じてさまざまな方法で構成要素である式の型が決定されます。

*  コンパイル時の型の構成要素である式`dynamic`式は、実行時に評価されます実際の値の型を持つと見なされます。
*  コンパイル時の型は型パラメーターの構成要素である式は実行時に、型パラメーターがバインドされている型であると見なされます
*  それ以外の場合、構成要素である式は、コンパイル時の型であると見なされます。

## <a name="operators"></a>演算子

式がから構築された***オペランド***と***演算子***します。 式の演算子は、オペランドに適用する演算を表します。 演算子の例として、`+`、`-`、`*`、`/`、および `new` などがあります。 オペランドの例としては、リテラル、フィールド、ローカル変数、式などがあります。

演算子の 3 つの種類があります。

*  単項演算子。 単項演算子が 1 つのオペランドを受け取り、いずれかのプレフィックス表記を使用して (よう`--x`) または notation の後置 (など`x++`)。
*  二項演算子。 二項演算子が 2 つのオペランドを取るし、挿入辞表記を使用して、すべて (など`x + y`)。
*  三項演算子。 1 つだけの三項演算子`?:`が存在する 3 つのオペランドを受け取るし、挿入辞表記を使用して (`c ? x : y`)。

式の演算子の評価の順序が続く、***優先順位***と***結合規則***演算子の ([演算子の優先順位と結合規則](expressions.md#operator-precedence-and-associativity)).

式のオペランドは、左から右に評価されます。 たとえば、 `F(i) + G(i++) * H(i)`、メソッド`F`の古い値を使用して呼び出された`i`、then メソッド`G`の古い値を使用して呼び出した`i`、および、最後に、メソッド`H`の新しい値を使用して呼び出した`i`. 演算子の優先順位とは別と関連付けられていないではありません。

特定の演算子を指定できます***オーバー ロードされた***します。 演算子のオーバー ロードは、1 つの操作に対して指定するユーザー定義演算子の実装を許可またはユーザー定義のクラスまたは構造体型の両方のオペランドは ([演算子のオーバー ロード](expressions.md#operator-overloading))。

### <a name="operator-precedence-and-associativity"></a>演算子の優先順位と結合規則

複数の演算子を含む式の場合、演算子の***優先順位***によって各々の演算子が評価される順序が決定されます。 たとえば、式`x + y * z`として評価されます`x + (y * z)`ため、`*`演算子は、バイナリよりも優先順位の高い`+`演算子。 演算子の優先順位は、その関連する文法の運用環境の定義によって確立されます。 たとえば、 *additive_expression*のシーケンスから成る*multiplicative_expression*で区切られた s`+`または`-`ため、演算子、`+`と`-`演算子よりも優先順位を下げる、 `*`、 `/`、および`%`演算子。

次の表は、優先順位の高いものから最下位の順序ですべての演算子をまとめたものです。

| __セクション__                                                                                   | __カテゴリ__                | __演算子__ | 
|-----------------------------------------------------------------------------------------------|-----------------------------|---------------|
| [一次式](expressions.md#primary-expressions)                                     | 1 次式                     | `x.y`  `f(x)`  `a[x]`  `x++`  `x--`  `new`  `typeof`  `default`  `checked`  `unchecked`  `delegate` | 
| [単項演算子](expressions.md#unary-operators)                                             | 単項                       | `+`  `-`  `!`  `~`  `++x`  `--x`  `(T)x` | 
| [算術演算子](expressions.md#arithmetic-operators)                                   | 乗法              | `*`  `/`  `%` | 
| [算術演算子](expressions.md#arithmetic-operators)                                   | 加法                    | `+`  `-`      | 
| [シフト演算子](expressions.md#shift-operators)                                             | シフト                       | `<<`  `>>`    | 
| [関係演算子と型検査演算子](expressions.md#relational-and-type-testing-operators) | 関係式と型検査 | `<`  `>`  `<=`  `>=`  `is`  `as` | 
| [関係演算子と型検査演算子](expressions.md#relational-and-type-testing-operators) | 等価比較                    | `==`  `!=`    | 
| [論理演算子](expressions.md#logical-operators)                                         | 論理 AND                 | `&`           | 
| [論理演算子](expressions.md#logical-operators)                                         | 論理 XOR                 | `^`           | 
| [論理演算子](expressions.md#logical-operators)                                         | 論理 OR                  | <code>&#124;</code>           |
| [条件論理演算子](expressions.md#conditional-logical-operators)                 | 条件 AND             | `&&`          | 
| [条件論理演算子](expressions.md#conditional-logical-operators)                 | 条件 OR              | <code>&#124;&#124;</code>          | 
| [null 合体演算子](expressions.md#the-null-coalescing-operator)                   | Null 合体演算子             | `??`          | 
| [条件演算子](expressions.md#conditional-operator)                                   | 条件                 | `?:`          | 
| [代入演算子](expressions.md#assignment-operators)、[匿名関数式](expressions.md#anonymous-function-expressions)  | 代入式とラムダ式 | `=`  `*=`  `/=`  `%=`  `+=`  `-=`  `<<=`  `>>=`  `&=`  `^=`  <code>&#124;=</code>  `=>` | 

優先順位が同じ 2 つの演算子のオペランドが発生したときに、演算子の結合規則操作が実行される順序を制御します。

*  すべてのバイナリ演算子は、代入演算子と null 合体演算子を除く***左結合***、左から右に操作を実行することを意味します。 たとえば、`x + y + z` は `(x + y) + z` と評価されます。
*  代入演算子、null 合体演算子と条件演算子 (`?:`) は***右から左***、つまり演算は右から左に実行されます。 たとえば、`x = y = z` は `x = (y = z)` と評価されます。

優先順位と結合性は、かっこを使用して制御することができます。 たとえば、`x + y * z` は最初に `y` と `z` を掛け、そして結果を `x` に足しますが、`(x + y) * z` では最初に `x` と `y` を足してから `z` を掛けます。

### <a name="operator-overloading"></a>演算子のオーバーロード

すべての単項および二項演算子には定義済みの実装では、任意の式で自動的に利用可能があります。 定義済みの実装だけでなくユーザー定義の実装を導入できます`operator`クラスと構造体の宣言 ([演算子](classes.md#operators))。 ユーザー定義演算子の実装に常に優先定義済みの演算子の実装。該当するユーザー定義演算子の実装には存在しない場合、定義済みの演算子の実装と見なされるで説明されている専用[単項演算子のオーバー ロードの解決](expressions.md#unary-operator-overload-resolution)と[二項演算子のオーバー ロード解像度](expressions.md#binary-operator-overload-resolution)します。

***オーバー ロードされた単項演算子***は。
```csharp
+   -   !   ~   ++   --   true   false
```

`true`と`false`式で明示的に使用されていない (そのため、優先順位表では含まれませんと[演算子の優先順位と結合規則](expressions.md#operator-precedence-and-associativity))、いるため、演算子と見なされますいくつかの式のコンテキストで呼び出される: ブール式 ([ブール式](expressions.md#boolean-expressions)) と、条件式を含む式 ([条件演算子](expressions.md#conditional-operator))、および論理条件演算子 ([条件付き論理演算子](expressions.md#conditional-logical-operators))。

***二項演算子のオーバー ロード可能な***は。
```csharp
+   -   *   /   %   &   |   ^   <<   >>   ==   !=   >   <   >=   <=
```

上記の演算子のみをオーバー ロードできます。 具体的には、メンバー アクセスは、メソッドの呼び出しのオーバー ロードすることはできませんまたは`=`、 `&&`、 `||`、 `??`、 `?:`、 `=>`、 `checked`、 `unchecked`、 `new`、 `typeof`、 `default`、 `as`、および`is`演算子。

二項演算子をオーバーロードすると、対応する代入演算子がある場合、これも暗黙的にオーバーロードされます。 演算子のオーバー ロードではたとえば、`*`演算子のオーバー ロードも`*=`します。 詳細についてはこの[複合代入](expressions.md#compound-assignment)します。 なお、代入演算子自体 (`=`) オーバー ロードできません。 常に割り当てでは、変数に値の単純なビットごとのコピーを実行します。

キャスト演算など`(T)x`、ユーザー定義の変換を提供することではオーバー ロード ([ユーザー定義の変換](conversions.md#user-defined-conversions))。

要素にアクセスするよう`a[x]`、オーバー ロードされた演算子とは見なされません。 代わりに、インデクサーによってサポートがユーザー定義のインデックス作成 ([インデクサー](classes.md#indexers))。

式では、演算子が演算子の表記を使用して参照されているし、機能の表記を使用して、宣言で演算子が参照されます。 次の表では、演算子と単項および二項演算子関数の表記の間の関係を示します。 最初のエントリで*op*プレフィックスのオーバー ロードされた単項演算子を表します。 2 番目のエントリで*op*単項後置形式を表します`++`と`--`演算子。 3 番目のエントリで*op*オーバー ロード可能な 2 項演算子を表します。


| __演算子表記__ | __機能の表記__ |
|-----------------------|-------------------------|
| `op x`                | `operator op(x)`        | 
| `x op`                | `operator op(x)`        | 
| `x op y`              | `operator op(x,y)`      | 

ユーザー定義演算子の宣言では、少なくとも 1 つのパラメーターは、演算子の宣言を含むクラスまたは構造体の型が常に要求します。 したがって、定義済みの演算子と同じシグネチャを持つユーザー定義演算子のことはできません。

ユーザー定義演算子の宣言には、構文、優先順位、または演算子の結合規則を変更できません。 たとえば、`/`演算子は常に二項演算子では、常には、優先順位レベルで指定[演算子の優先順位と結合規則](expressions.md#operator-precedence-and-associativity)、左からの結合は常にします。

どのような計算を実行するユーザー定義演算子のことはできますが、直感的に予想されるもの以外の結果を生成するための実装は使用しないでください。 実装ではたとえば、 `operator ==` 2 つのオペランドが等しいかどうかを比較し、適切なを返す必要があります`bool`結果。

個々 の演算子の説明については、[一次式](expressions.md#primary-expressions)を通じて[条件付き論理演算子](expressions.md#conditional-logical-operators)演算子および適用される追加の規則の定義済みの実装を指定します。それぞれの演算子。 説明の用語を使用して、***単項演算子のオーバー ロードの解決***、***二項演算子のオーバー ロードの解決***、および***数値プロモーション***は他の定義次のセクションでは、記載されています。

### <a name="unary-operator-overload-resolution"></a>単項演算子のオーバー ロードの解決

フォームの操作を`op x`または`x op`ここで、`op`オーバー ロードされた単項演算子、および`x`型の式は、 `X`、次のように処理されます。

*  一連の候補ユーザー定義の演算子によって提供される`X`操作`operator op(x)`の規則を使用して決定されます[候補ユーザー定義演算子](expressions.md#candidate-user-defined-operators)します。
*  ユーザー定義演算子の候補のセットが空でない場合は、この操作の演算子の候補のセットをなります。 それ以外の場合、定義済みの単項`operator op`がリフトのフォームを含めて、実装操作の演算子の候補の集合になります。 特定の演算子の定義済みの実装が演算子の説明で指定されます ([一次式](expressions.md#primary-expressions)と[単項演算子](expressions.md#unary-operators))。
*  オーバー ロード解決規則[オーバー ロードの解決](expressions.md#overload-resolution)引数リストに対して最適な演算子を選択する演算子を候補のセットに適用される`(x)`、この演算子のオーバー ロードの結果になります解決プロセスです。 1 つの最適な演算子を選択するオーバー ロードの解決に失敗した場合、バインド時のエラーが発生します。

### <a name="binary-operator-overload-resolution"></a>二項演算子のオーバー ロードの解決

フォームの操作を`x op y`ここで、 `op` 、オーバー ロードされた二項演算子は、`x`型の式は、 `X`、および`y`型の式は、 `Y`、次のように処理されます。

*  一連の候補ユーザー定義の演算子によって提供される`X`と`Y`操作`operator op(x,y)`決定されます。 セットによって提供される演算子の候補の和集合から成る`X`によって提供される演算子の候補と`Y`それぞれ特定の規則を使用して、[候補ユーザー定義演算子](expressions.md#candidate-user-defined-operators)します。 場合`X`と`Y`は同じ型の場合、または`X`と`Y`演算子候補、結合されたセットで 1 回しか発生し、共通の基本型から派生します。
*  ユーザー定義演算子の候補のセットが空でない場合は、この操作の演算子の候補のセットをなります。 それ以外の場合、定義済みのバイナリ`operator op`がリフトのフォームを含めて、実装操作の演算子の候補の集合になります。 特定の演算子の定義済みの実装が演算子の説明で指定されます ([算術演算子](expressions.md#arithmetic-operators)を通じて[条件付き論理演算子](expressions.md#conditional-logical-operators))。 定義済みの列挙型とデリゲートの演算子と見なされる演算子のみでは、オペランドの 1 つのバインド時の型である列挙型、またはデリゲートの型で定義されています。
*  オーバー ロード解決規則[オーバー ロードの解決](expressions.md#overload-resolution)引数リストに対して最適な演算子を選択する演算子を候補のセットに適用される`(x,y)`、この演算子のオーバー ロードの結果になります解決プロセスです。 1 つの最適な演算子を選択するオーバー ロードの解決に失敗した場合、バインド時のエラーが発生します。

### <a name="candidate-user-defined-operators"></a>ユーザー定義演算子の候補

型を指定して`T`と操作`operator op(A)`ここで、`op`オーバー ロードされた演算子と`A`引数リストを候補のセットによって提供されるユーザー定義の演算子は、`T`の`operator op(A)`決定されます次のようにします。

*  種類を決定`T0`します。 場合`T`が null 許容型では、`T0`基になる型をそれ以外の場合は`T0`と等しい`T`します。
*  すべての`operator op`内の宣言`T0`と少なくとも 1 つの演算子が適用可能な場合は、すべてのリフトのような演算子では、形式 ([適用可能な関数メンバー](expressions.md#applicable-function-member)) 引数リストに対して`A`のセットでは、演算子の候補のような該当するすべての演算子から成る`T0`します。
*  の場合`T0`は`object`、演算子の候補のセットが空です。
*  によって提供される演算子の候補のセットの場合は、`T0`の直接の基本クラスによって提供される演算子の候補のセットは、 `T0`、または有効な基本クラスの`T0`場合`T0`型パラメーターします。

### <a name="numeric-promotions"></a>数値の上位変換

数値の上位変換は、定義済みの単項および二項の数値演算子のオペランドの特定の暗黙的な変換を自動的に実行するので構成されます。 数値の上位変換はなく、個別のメカニズムではなく、定義済みの演算子をオーバー ロードの解決を適用する効果です。 数値の上位変換具体的には影響しませんユーザー定義の演算子の評価のような影響が発生するユーザー定義演算子を実装することができます。

数値の上位変換の例は、としては、定義済みのバイナリの実装を考えてみましょう。`*`演算子。

```csharp
int operator *(int x, int y);
uint operator *(uint x, uint y);
long operator *(long x, long y);
ulong operator *(ulong x, ulong y);
float operator *(float x, float y);
double operator *(double x, double y);
decimal operator *(decimal x, decimal y);
```

ときにオーバー ロードの解決ルール ([オーバー ロードの解決](expressions.md#overload-resolution)) このセットに適用される演算子の結果はオペランドの型から最初の暗黙的な変換が存在する演算子を選択します。 操作の例では、`b * s`ここで、`b`は、`byte`と`s`は、 `short`、オーバー ロードの解決方法の選択`operator *(int,int)`最善の演算子として。 そのため、効果は`b`と`s`に変換されます`int`、および結果の型は`int`します。 同様に、操作の`i * d`ここで、`i`は、`int`と`d`は、 `double`、オーバー ロードの解決方法の選択`operator *(double,double)`最善の演算子として。

#### <a name="unary-numeric-promotions"></a>単項の数値の上位変換

定義済みのオペランドの単項の数値の昇格が発生した`+`、 `-`、および`~`単項演算子。 単項の数値の上位変換は、型のオペランドを変換するだけで構成される`sbyte`、 `byte`、 `short`、 `ushort`、または`char`入力`int`します。 さらに、単項の`-`演算子、単項の数値の上位変換型のオペランドの変換`uint`入力`long`します。

#### <a name="binary-numeric-promotions"></a>バイナリ数値プロモーション

定義済みのオペランドのバイナリ数値昇格が発生した`+`、 `-`、 `*`、 `/`、 `%`、 `&`、 `|`、 `^`、 `==`、 `!=`、`>`、 `<`、 `>=`、および`<=`二項演算子。 バイナリ数値の上位変換は、非リレーショナルの演算子が発生した場合、操作の結果の型にもなりますが、共通の型に暗黙的に両方のオペランドを変換します。 数値のバイナリの上位変換は、ここに表示される順序で、次の規則を適用することで構成されます。

*  いずれかのオペランドの型の場合`decimal`、もう一方のオペランドを型に変換されます`decimal`、バインド時のエラーは、もう一方のオペランドの型の場合に発生します。 または`float`または`double`します。
*  それ以外の場合、いずれかのオペランドの型の場合`double`、もう一方のオペランドを型に変換されます`double`します。
*  それ以外の場合、いずれかのオペランドの型の場合`float`、もう一方のオペランドを型に変換されます`float`します。
*  それ以外の場合、いずれかのオペランドの型の場合`ulong`、もう一方のオペランドを型に変換されます`ulong`、バインド時のエラーは、もう一方のオペランドの型の場合に発生します。 または`sbyte`、 `short`、 `int`、または`long`します。
*  それ以外の場合、いずれかのオペランドの型の場合`long`、もう一方のオペランドを型に変換されます`long`します。
*  それ以外の場合、いずれかのオペランドの型の場合`uint`ともう一方のオペランド型`sbyte`、 `short`、または`int`、両方のオペランドを型に変換されます`long`します。
*  それ以外の場合、いずれかのオペランドの型の場合`uint`、もう一方のオペランドを型に変換されます`uint`します。
*  それ以外の場合、両方のオペランドは、型に変換されます`int`します。

最初の規則が混在するすべての操作を禁止することに注意してください、`decimal`の種類を`double`と`float`型。 間の暗黙的な変換がないという事実から、ルールに依存して、`decimal`型と`double`と`float`型。

なお、オペランドの型のことはできません`ulong`もう一方のオペランドが符号付き整数型の場合します。 理由は、整数型が存在しないことの全範囲を表すことができます`ulong`と符号付き整数型。

どちらの場合も、もう一方のオペランドと互換性がある型に 1 つのオペランドを明示的に変換するキャスト式を使用できます。

例
```csharp
decimal AddPercent(decimal x, double percent) {
    return x * (1.0 + percent / 100.0);
}
```
バインディング時のエラーが発生、`decimal`によって乗算することはできません、`double`します。 2 番目のオペランドを明示的な変換によって、エラーが解決`decimal`、次のようにします。

```csharp
decimal AddPercent(decimal x, double percent) {
    return x * (decimal)(1.0 + percent / 100.0);
}
```

### <a name="lifted-operators"></a>リフトされた演算子

***リフト演算子***もそれらの型の null 許容のフォームで使用する null 非許容値型を操作する定義済み、ユーザー定義の演算子を許可します。 リフトされた演算子は、次の説明に従って特定の要件を満たしている定義済み、ユーザー定義の演算子から構築されます。

*   単項演算子

    ```csharp
    +  ++  -  --  !  ~
    ```

    場合、オペランドと結果の型は両方が null 非許容値型にリフトされた演算子のフォームが存在します。 リフトの形式が、1 つを追加することで構築された`?`修飾子をオペランドと結果の型。 リフトされた演算子は、オペランドが null の場合、null 値を生成します。 それ以外の場合、リフトされた演算子はオペランドのラップを解除し、基になる演算子を適用し、結果をラップします。

*   2 項演算子

    ```csharp
    +  -  *  /  %  &  |  ^  <<  >>
    ```

    オペランドと結果の型がすべての null 非許容値型である場合、リフトされた演算子のフォームが存在します。 リフトの形式が、1 つを追加することで構築された`?`オペランドと結果の種類ごとに修飾子。 1 つの場合、リフトされた演算子は null 値を生成または両方のオペランドが null (例外である、`&`と`|`の演算子、 `bool?` 」の説明に従って、入力[ブール論理演算子](expressions.md#boolean-logical-operators))。 それ以外の場合、リフトされた演算子はオペランドのラップを解除し、基になる演算子を適用し、結果をラップします。

*   等値演算子の

    ```csharp
    ==  !=
    ```

    オペランドの型が null 非許容値型と結果型がある場合は、リフトされた演算子のフォームが存在する`bool`します。 リフトの形式が、1 つを追加することで構築された`?`修飾子を追加します。 リフトされた演算子には、2 つの null 値は等しく、および null 値が null 以外の値に等しくないです。 両方のオペランドが null 以外の場合は、リフトされた演算子はオペランドのラップを解除しを生成する基になる演算子を適用、`bool`結果。

*   関係演算子

    ```csharp
    <  >  <=  >=
    ```

    オペランドの型が null 非許容値型と結果型がある場合は、リフトされた演算子のフォームが存在する`bool`します。 リフトの形式が、1 つを追加することで構築された`?`修飾子を追加します。 リフトされた演算子の値を生成する`false`1 つまたは両方のオペランドが null の場合。 それ以外の場合、リフトされた演算子はオペランドのラップを解除し、生成するために基になる演算子を適用、`bool`結果。

## <a name="member-lookup"></a>メンバー ルックアップ

メンバー検索は、型のコンテキストで名前の意味を決定するというプロセスです。 メンバー参照が評価の一部として発生することが、 *simple_name* ([簡易名](expressions.md#simple-names)) または*member_access* ([メンバー アクセス](expressions.md#member-access)) で、式。 場合、 *simple_name*または*member_access*として発生する、 *primary_expression*の*invocation_expression* ([メソッドの呼び出し](expressions.md#method-invocations))、呼び出されるメンバーと呼びます。

メンバーがメソッドまたはイベントの場合、または定数、フィールド、またはデリゲート型のプロパティである場合 ([デリゲート](delegates.md))、または型`dynamic`([動的な型](types.md#the-dynamic-type))、メンバーはと呼ばれますし、*invocable*します。

メンバー参照では、メンバーが型パラメーターと、メンバーがアクセスできるかどうかの数が、メンバーの名前だけでなくと見なします。 メンバー検索のためには、それぞれの宣言に示されている型パラメーターの数であるジェネリック メソッドと入れ子になったジェネリック型とその他のすべてのメンバーは、0 個の型パラメーターを指定します。

名前のメンバー検索 `N`で`K` 型にパラメーターを入力 `T`ように処理されます。

*  最初に、アクセス可能なメンバーがという名前のセットを `N`決定されます。
    * 場合`T`、型パラメーター セットがアクセス可能なメンバーがという名前のセットの和集合が `N`制約のプライマリまたはセカンダリの制約として指定された型の各 ([パラメーターの制約入力](classes.md#type-parameter-constraints)) の `T`、アクセス可能なメンバーがという名前のセットと共に `N`で`object`します。
    * それ以外の場合、すべてにアクセスできるのセットが ([メンバー アクセス](basic-concepts.md#member-access)) という名前のメンバー `N`で `T`継承されたメンバーと名前付きアクセス可能なメンバーを含めて、 `N`で`object`します。 場合`T`構築された型は、メンバーのセットが」の説明に従って、型引数を代入することによって取得した[構築された型のメンバー](classes.md#members-of-constructed-types)します。 メンバーが含まれる、`override`修飾子は、セットから除外されます。
*  次に、if`K`は 0、型の宣言には、型パラメーターが含まれては削除が入れ子になったすべてです。 場合`K`、異なる数のパラメーターを削除する型を持つすべてのメンバーに 0 以外です。 場合`K`が 0 個、メソッドのある型の型の推論プロセス以降のパラメーターは削除されません ([型推論](expressions.md#type-inference)) 型引数の推論できる場合があります。
*  次に、メンバーがある場合*呼び出さ*、以外のすべて-*invocable*メンバーをセットから削除します。
*  次に、他のメンバーが隠ぺいされているメンバーは、セットから削除されます。 すべてのメンバーの`S.M`、セット内で`S`の種類は、メンバー `M`宣言されると、次の規則が適用されます。
    * 場合`M`の基本型で宣言されているすべてのメンバー、定数、フィールド、プロパティ、イベント、または列挙型のメンバーは、`S`セットから削除されます。
    * 場合`M`が型の宣言型以外のすべての基本型で宣言された`S`、セットから削除はすべて、同じ数と型パラメーターの宣言型と`M`の基本型で宣言された`S`が削除されますセット。
    * 場合`M`、メソッドの基本型で宣言されているすべてのメソッド以外のメンバーが`S`セットから削除されます。
*  次に、クラス メンバーが隠ぺいされているインターフェイス メンバーは、セットから削除されます。 ここでは、場合にのみ`T`型パラメーターと`T`以外の両方を有効な基本クラスを持つ`object`と空でない有効なインターフェイス セット ([パラメーターの制約入力](classes.md#type-parameter-constraints))。 すべてのメンバーの`S.M`、セット内で`S`の種類は、メンバー`M`が宣言されている場合に、次の規則が適用される`S`以外のクラス宣言は、 `object`:
    * 場合`M`が定数、フィールド、プロパティ、イベント、列挙型メンバー、または型の宣言、インターフェイス宣言で宣言されているすべてのメンバーは、セットから削除されます。
    * 場合`M`、インターフェイス宣言で宣言されているすべてのメソッド以外のメンバーは、セット、およびと同じシグネチャを持つすべてのメソッドから削除されますが、メソッド、`M`宣言インターフェイスの宣言は、セットから削除されます。
*  最後に、非表示のメンバーを削除すると、検索の結果が決定されます。
    * セット メソッドではない 1 つのメンバーの場合、このメンバーは、参照の結果です。
    * それ以外の場合、セットにメソッドのみが含まれている場合、参照の結果はメソッドのこのグループにします。
    * それ以外の場合、参照があいまいであり、バインド エラーが発生します。

型パラメーターとのインターフェイス以外の型のメンバーの検索と厳密な単一継承インターフェイス メンバーの検索 (継承チェーン内の各インターフェイスが厳密に 0 個または 1 つの直接基底インターフェイス)、参照ルールの影響は、同じ名前またはシグネチャを持つメンバーの非表示にする基本メンバーを派生するだけです。 このような単一継承の参照があいまいなことはできません。 多重継承インターフェイス メンバー検索から発生する可能性のあいまいさが記載されて[インターフェイス メンバーへのアクセス](interfaces.md#interface-member-access)します。

### <a name="base-types"></a>基本データ型

メンバーの検索、一種の目的で`T`次の基本型を持つと見なされます。

*  場合`T`は`object`、し`T`基本データ型がありません。
*  場合`T`は、 *enum_type*の基本型`T`クラス型である`System.Enum`、 `System.ValueType`、および`object`します。
*  場合`T`は、 *struct_type*の基本型`T`クラス型である`System.ValueType`と`object`します。
*  場合`T`は、 *class_type*の基本型`T`の基本クラス`T`、クラス型を含む`object`します。
*  場合`T`は、 *interface_type*の基本型`T`の基本インターフェイス`T`クラス型と`object`します。
*  場合`T`は、 *array_type*の基本型`T`クラス型である`System.Array`と`object`します。
*  場合`T`は、 *delegate_type*の基本型`T`クラス型である`System.Delegate`と`object`します。

## <a name="function-members"></a>関数メンバー

関数メンバーは、実行可能なステートメントが含まれているメンバーです。 関数メンバーは型のメンバーでは常に、名前空間のメンバーであることはできません。 C# 関数メンバーの次のカテゴリを定義します。

*  メソッド
*  プロパティ
*  イベント
*  インデクサー
*  ユーザー定義演算子
*  インスタンス コンストラクター
*  静的コンストラクター
*  デストラクター

デストラクター (これは、明示的に呼び出すことはできません)、静的コンストラクターを除く、関数メンバーに含まれているステートメントは、関数メンバーの呼び出しを通じて実行されます。 関数メンバーの呼び出しを記述するための実際の構文は、特定の関数メンバーのカテゴリに依存します。

引数リスト ([引数リスト](expressions.md#argument-lists)) 関数メンバーの呼び出しでは、実際の値または変数参照、関数メンバーのパラメーター。

ジェネリック メソッドの呼び出しは、メソッドに渡す型引数のセットを決定する型の推定を採用できます。 このプロセスについては、「[型推論](expressions.md#type-inference)します。

メソッド、インデクサー、演算子、およびインスタンス コンストラクターの呼び出しは、候補の関数メンバーを呼び出す一連の判断するためにオーバー ロードの解決を使用します。 このプロセスについては、「[オーバー ロードの解決](expressions.md#overload-resolution)します。

バインディング時に特定の関数メンバーを特定したら、可能性があるオーバー ロードの解決、関数メンバーを呼び出して実際の実行時プロセスがで説明されている[コンパイル時の動的なオーバー ロードの解決のチェック](expressions.md#compile-time-checking-of-dynamic-overload-resolution).

次の表では、明示的に呼び出される関数メンバーの 6 つのカテゴリに関連する構成要素で発生する処理をまとめたものです。 表に、 `e`、 `x`、 `y`、および`value`変数または値として分類される式を示す`T`型として分類される式を示します`F`メソッドをおよびの単純な名前を指定`P`プロパティの単純な名前を指定します。


| __コンストラクター__     | __例__    | __説明__ |
|-------------------|----------------|-----------------|
| メソッドの呼び出し | `F(x,y)`       | 最適な方法を選択するオーバー ロードの解決が適用される`F`包含クラスまたは構造体でします。 引数リストを持つメソッドが呼び出される`(x,y)`します。 メソッドではない場合`static`、インスタンス式が`this`します。 | 
|                   | `T.F(x,y)`     | 最適な方法を選択するオーバー ロードの解決が適用される`F`クラスまたは構造体で`T`します。 メソッドではない場合、バインド時のエラーが発生する`static`します。 引数リストを持つメソッドが呼び出される`(x,y)`します。 | 
|                   | `e.F(x,y)`     | クラス、構造体、またはインターフェイスの型で指定された F の最適な方法を選択するオーバー ロードの解決が適用される`e`します。 メソッドの場合、バインド時のエラーが発生する`static`します。 インスタンス式が、このメソッドは`e`および引数リスト`(x,y)`します。 | 
| 「プロパティ アクセス」   | `P`            | `get`プロパティのアクセサー`P`包含クラスまたは構造体でが呼び出されます。 コンパイル時エラーが発生します`P`は書き込み専用です。 場合`P`ない`static`、インスタンス式が`this`します。 | 
|                   | `P = value`    | `set`プロパティのアクセサー`P`包含クラスまたは構造体では引数リストによって呼び出される`(value)`します。 コンパイル時エラーが発生します`P`は読み取り専用です。 場合`P`ない`static`、インスタンス式が`this`します。 | 
|                   | `T.P`          | `get`プロパティのアクセサー`P`クラスまたは構造体で`T`が呼び出されます。 コンパイル時エラーが発生します`P`ない`static`場合`P`は書き込み専用です。 | 
|                   | `T.P = value`  | `set`プロパティのアクセサー`P`クラスまたは構造体で`T`が呼び出されると、引数リスト`(value)`します。 コンパイル時エラーが発生します`P`ない`static`場合`P`は読み取り専用です。 | 
|                   | `e.P`          | `get`プロパティのアクセサー`P`クラス、構造体、またはインターフェイスの型で指定された`e`が呼び出されるインスタンス式と`e`します。 バインディング時のエラーが発生します`P`は`static`場合`P`は書き込み専用です。 | 
|                   | `e.P = value`  | `set`プロパティのアクセサー`P`クラス、構造体、またはインターフェイスの型で指定された`e`が呼び出されるインスタンス式と`e`および引数リスト`(value)`します。 バインディング時のエラーが発生します`P`は`static`場合`P`は読み取り専用です。 | 
| イベントへのアクセス      | `E += value`   | `add`イベントのアクセサー`E`包含クラスまたは構造体でが呼び出されます。 場合`E`は静的でないインスタンス式が`this`します。 | 
|                   | `E -= value`   | `remove`イベントのアクセサー`E`包含クラスまたは構造体でが呼び出されます。 場合`E`は静的でないインスタンス式が`this`します。 | 
|                   | `T.E += value` | `add`イベントのアクセサー`E`クラスまたは構造体で`T`が呼び出されます。 バインディング時のエラーが発生します`E`は静的でありません。 | 
|                   | `T.E -= value` | `remove`イベントのアクセサー`E`クラスまたは構造体で`T`が呼び出されます。 バインディング時のエラーが発生します`E`は静的でありません。 | 
|                   | `e.E += value` | `add`イベントのアクセサー`E`クラス、構造体、またはインターフェイスの型で指定された`e`が呼び出されるインスタンス式と`e`します。 バインディング時のエラーが発生します`E`は静的です。 | 
|                   | `e.E -= value` | `remove`イベントのアクセサー`E`クラス、構造体、またはインターフェイスの型で指定された`e`が呼び出されるインスタンス式と`e`します。 バインディング時のエラーが発生します`E`は静的です。 | 
| インデクサーへのアクセス    | `e[x,y]`       | クラス、構造体、または電子メールの種類によって指定されたインターフェイスで最適なインデクサーを選択するのには、オーバー ロードの解決が適用されます。 `get`インスタンス式が、インデクサーのアクセサーが呼び出される`e`および引数リスト`(x,y)`します。 インデクサーが書き込み専用の場合は、バインド エラーになります。 | 
|                   | `e[x,y] = value` | クラス、構造体、またはインターフェイスの型で指定された最適なインデクサーを選択するオーバー ロードの解決が適用される`e`します。 `set`インスタンス式が、インデクサーのアクセサーが呼び出される`e`および引数リスト`(x,y,value)`します。 バインディング エラーは、インデクサーは読み取り専用である場合に発生します。 | 
| 演算子の呼び出し | `-x`         | クラスまたは構造体の型で指定されたで最善の単項演算子を選択するオーバー ロードの解決が適用される`x`します。 引数リストで選択した演算子が呼び出される`(x)`します。 | 
|                     | `x + y`      | クラスまたは構造体の型で指定された、最適な二項演算子を選択するオーバー ロードの解決が適用される`x`と`y`します。 引数リストで選択した演算子が呼び出される`(x,y)`します。 | 
| インスタンス コンストラクターの呼び出し | `new T(x,y)` | クラスまたは構造体で最適なインスタンス コンストラクターを選択するオーバー ロードの解決が適用される`T`します。 インスタンス コンストラクターが呼び出される引数リストと`(x,y)`します。 | 

### <a name="argument-lists"></a>引数リスト

すべての関数メンバーおよびデリゲートの呼び出しには、関数メンバーのパラメーターの実際の値または変数参照を提供する引数リストが含まれています。 関数メンバーの呼び出しの引数リストを指定する構文は、関数メンバーのカテゴリによって異なります。

*  インスタンスのコンストラクター、メソッド、インデクサー、およびデリゲートを引数は、 *argument_list*以下の説明に従って、します。 インデクサーの場合を呼び出すときに、`set`アクセサー、さらに含まれています、代入演算子の右側のオペランドとして指定された式の引数リスト。
*  プロパティについては、引数リストが空を呼び出すときに、`get`アクセサーを呼び出すときに、代入演算子の右側のオペランドとして指定された式で構成されて、`set`アクセサー。
*  右側のオペランドとして指定された式の引数リストは、イベントの場合、`+=`または`-=`演算子。
*  ユーザー定義演算子では、引数リストは、単項演算子の 1 つのオペランドまたは二項演算子の 2 つのオペランドで構成されます。

プロパティの引数 ([プロパティ](classes.md#properties))、イベント ([イベント](classes.md#events))、およびユーザー定義演算子 ([演算子](classes.md#operators)) は、常に値パラメーターとして渡されます ([パラメーターの値](classes.md#value-parameters))。 インデクサーの引数 ([インデクサー](classes.md#indexers)) は、常に値パラメーターとして渡されます ([パラメーターの値](classes.md#value-parameters)) またはパラメーターの配列 ([パラメーター配列](classes.md#parameter-arrays))。 これらの関数メンバーのカテゴリでは、パラメーターの参照を出力パラメーターはサポートされていません。

インスタンス コンストラクター、メソッド、インデクサー、またはデリゲート呼び出しの引数として指定されます、 *argument_list*:

```antlr
argument_list
    : argument (',' argument)*
    ;

argument
    : argument_name? argument_value
    ;

argument_name
    : identifier ':'
    ;

argument_value
    : expression
    | 'ref' variable_reference
    | 'out' variable_reference
    ;
```

*Argument_list* 1 つまたは複数から成る*引数*s、コンマで区切られました。 省略可能なは、各引数*argument_name*続けて、 *argument_value*します。 *引数*で、 *argument_name*と呼ばれます、***名前付き引数***であるのに対し、*引数*せず、 *argument_name*は、***位置指定引数***します。 位置指定引数の名前付き引数の後に表示されるエラーは、 *argument_list*します。

*Argument_value*形式は次のいずれかを実行します。

*  *式*を示す値を持つパラメーターとして渡される引数 ([パラメーターの値](classes.md#value-parameters))。
*  キーワード`ref`続けて、 *variable_reference* ([変数参照](variables.md#variable-references))、参照パラメーターとして渡される引数を示す ([パラメーターを参照](classes.md#reference-parameters)). 変数を明示的に代入する必要があります ([確実な代入](variables.md#definite-assignment)) 前に、参照パラメーターとして渡すことができます。 キーワード`out`続けて、 *variable_reference* ([変数参照](variables.md#variable-references))、出力パラメーターとして渡される引数を示す ([出力パラメーター](classes.md#output-parameters)). 変数が確実に割り当てられていると見なされます ([確実な代入](variables.md#definite-assignment)) 次の変数が出力パラメーターとして渡された関数メンバーの呼び出し。

#### <a name="corresponding-parameters"></a>対応するパラメーター

引数リストの各引数の関数メンバーまたは呼び出されるデリゲートに対応するパラメーターがあります。

次で使用されるパラメーターのリストは、次のように決定されます。

*  仮想メソッドとクラスで定義されているインデクサーでは、パラメーター リストの最も固有の宣言からピッキングまたは以降で、受信側の静的な型とその基本クラスを検索、関数メンバーのオーバーライドします。
*  パラメーター リストを取得するインターフェイスのメソッドとインデクサーはインターフェイス型で始まると、基本インターフェイスを検索、メンバーの最も固有の定義を形成します。 一意のパラメーター リストが見つからないかどうか、アクセスできない名前と省略可能なパラメーターなしのパラメーター リストが構築するための呼び出しが名前付きパラメーターを使用して、または省略可能な引数を省略することはできません。
*  部分メソッドの定義の部分メソッド宣言のパラメーター リストが使用されます。
*  その他のすべての関数メンバーとデリゲートを使用する 1 つのパラメーター リストだけがあります。

引数またはパラメーターの位置は、引数または引数のリストまたはパラメーター リスト内の前のパラメーターの数として定義されます。

関数メンバーの引数に対応するパラメーターは、次のように確立されています。

*  引数、 *argument_list*インスタンス コンストラクター、メソッド、インデクサー、およびデリゲートの。
    * パラメーター リスト内の同じ位置に固定のパラメーターが発生した位置指定引数は、そのパラメーターに対応します。
    * 標準形式で呼び出されたパラメーター配列を持つ関数メンバーの位置指定引数は、パラメーター リストの同じ位置にある必要がありますをパラメーター配列に対応します。
    * 拡張形式、場所、パラメーター リスト内の同じ位置で固定のパラメーターは行われませんで呼び出されたパラメーター配列を持つ関数メンバーの位置指定引数は、パラメーター配列内の要素に対応します。
    * 名前付き引数は、パラメーター リスト内の同じ名前のパラメーターに対応します。
    * インデクサーの場合を呼び出すときに、`set`アクセサー、暗黙に対応する代入演算子の右側のオペランドとして指定された式`value`のパラメーター、`set`アクセサーの宣言。
*  呼び出すときに、プロパティの`get`ありますアクセサーに引数がありません。 呼び出すときに、`set`アクセサー、暗黙に対応する代入演算子の右側のオペランドとして指定された式`value`のパラメーター、`set`アクセサーの宣言。
*  (変換を含む) ユーザー定義の単項演算子の 1 つのオペランドは、演算子の宣言の 1 つのパラメーターに対応します。
*  二項演算子のユーザー定義の最初のパラメーターに対応する左のオペランドと右のオペランドが演算子の宣言の 2 番目のパラメーターに対応しています。

#### <a name="run-time-evaluation-of-argument-lists"></a>引数リストの実行時の評価

関数メンバーの呼び出しの実行時の処理中に ([コンパイル時の動的なオーバー ロードの解決チェック](expressions.md#compile-time-checking-of-dynamic-overload-resolution))、式または引数リストの変数の参照として、左から順番に評価されます次に示します。

*  引数式の評価の値を持つパラメーター、および暗黙的な変換 ([暗黙的な変換](conversions.md#implicit-conversions)) の対応するパラメーター型が実行されます。 結果の値では、関数メンバーの呼び出しで値パラメーターの初期値になります。
*  参照または出力パラメーターの場合は、変数参照が評価され、結果ストレージの場所は、関数メンバーの呼び出しでパラメーターによって表される記憶域の場所になります。 参照または出力パラメーターとして指定された変数の参照の配列要素である場合、 *reference_type*配列の要素の型がパラメーターの型と同じであることを確認する実行時チェックが行われます。 このチェックに失敗した場合、`System.ArrayTypeMismatchException`がスローされます。

メソッド、インデクサー、およびインスタンス コンストラクターはパラメーター配列の最も右にあるパラメーターを宣言できます ([パラメーター配列](classes.md#parameter-arrays))。 このような関数メンバーは、標準形式、またはどちらが該当するによって、拡張の形式で呼び出される ([適用可能な関数メンバー](expressions.md#applicable-function-member))。

*  パラメーター配列を持つ関数メンバーが、標準形式で呼び出されると、パラメーター配列の指定された引数が暗黙的に変換可能である 1 つの式をある必要があります ([暗黙的な変換](conversions.md#implicit-conversions)) に、パラメーター配列の型。 この場合、パラメーター配列は、値を持つパラメーターとまったく同じように機能します。
*  拡張形式でパラメーター配列を持つ関数メンバーが呼び出されると、呼び出しがそれぞれの引数が、暗黙的に変換する式は、パラメーター配列の 0 個以上の位置指定引数を指定する必要があります ([暗黙の型変換](conversions.md#implicit-conversions)) パラメーターの配列の要素の型にします。 ここでは、呼び出し引数の数に対応する長さを持つパラメーターの配列型のインスタンスを作成します。 指定された引数に値を使用して、配列インスタンスの要素を初期化し、実際に新しく作成された配列のインスタンスを使用引数。

引数リストの式は常に記述されている順序で評価します。 例では、そのため、
```csharp
class Test
{
    static void F(int x, int y = -1, int z = -2) {
        System.Console.WriteLine("x = {0}, y = {1}, z = {2}", x, y, z);
    }

    static void Main() {
        int i = 0;
        F(i++, i++, i++);
        F(z: i++, x: i++);
    }
}
```
この例では、次のように出力されます。
```
x = 0, y = 1, z = 2
x = 4, y = -1, z = 3
```

配列の共変性規則 ([配列の共変性](arrays.md#array-covariance)) 配列型の値を許可`A[]`配列型のインスタンスへの参照である`B[]`から暗黙の参照変換が存在する限り、`B`に`A`. 配列の要素のときに、これらの規則のため、 *reference_type*が渡される参照または出力パラメーターとして、実行時チェックが配列の実際の要素の型が、パラメーターの場合と同じであることを確認するために必要です。 例
```csharp
class Test
{
    static void F(ref object x) {...}

    static void Main() {
        object[] a = new object[10];
        object[] b = new string[10];
        F(ref a[0]);        // Ok
        F(ref b[1]);        // ArrayTypeMismatchException
    }
}
```
2 番目の呼び出しの`F`により、`System.ArrayTypeMismatchException`が、実際の要素の入力のためにスローされる`b`は`string`および not `object`。

場合と同様、配列初期化子で配列作成式拡張形式でパラメーター配列を持つ関数メンバーが呼び出されると、呼び出しは処理されます ([配列作成式](expressions.md#array-creation-expressions)) 周囲に挿入されて、拡張パラメーター。 たとえば、宣言について考えます。
```csharp
void F(int x, int y, params object[] args);
```
メソッドの拡張形式の次の呼び出し
```csharp
F(10, 20);
F(10, 20, 30, 40);
F(10, 20, 1, "hello", 3.0);
```
正確に対応しています
```csharp
F(10, 20, new object[] {});
F(10, 20, new object[] {30, 40});
F(10, 20, new object[] {1, "hello", 3.0});
```

具体的には、パラメーター配列の指定された 0 個の引数がある場合、空の配列が作成されたことに注意してください。

対応する省略可能なパラメーターを持つ関数メンバーからは、引数が省略された場合、関数メンバー宣言の既定の引数は暗黙的に渡されます。 これらの定数は常に、ための評価は、残りの引数の評価順序は影響しません。

### <a name="type-inference"></a>型の推論

型引数を指定せずにジェネリック メソッドが呼び出されたときに、***型推論***プロセスは呼び出しの引数の型を推論しようとしています。 型の推定の存在は、ジェネリック メソッドの呼び出しに使用する便利な構文を使用でき、プログラマの冗長の種類の情報を指定することを回避するためにです。 たとえば、メソッドの宣言を考えてみます。
```csharp
class Chooser
{
    static Random rand = new Random();

    public static T Choose<T>(T first, T second) {
        return (rand.Next(2) == 0)? first: second;
    }
}
```
呼び出すことは、`Choose`型引数を明示的に指定しないでメソッド。
```csharp
int i = Chooser.Choose(5, 213);                 // Calls Choose<int>

string s = Chooser.Choose("foo", "bar");        // Calls Choose<string>
```

型推論、型引数を通じて`int`と`string`メソッドに引数から決定されます。

メソッドの呼び出しのバインド時の処理の一部として型の推定が発生します ([メソッドの呼び出し](expressions.md#method-invocations)) と前の呼び出しのオーバー ロードの解決手順に、を実施します。 特定のメソッドのグループがメソッドの呼び出しで指定して、型引数がメソッドの呼び出しの一部として指定されていない、ときに、型の推論はメソッド グループの各ジェネリック メソッドに適用されます。 型の推論に成功した場合、推論された型引数は、後続のオーバー ロードの解決用引数の種類を決定に使用されます。 オーバー ロードの解決選択した場合、ジェネリック メソッドを呼び出すと、推論された型引数は、特定の呼び出しの実際の型引数として使用されます。 特定のメソッドの型の推定が失敗した場合、そのメソッドはオーバー ロードの解決には参加しません。 型の推定、自体の障害では、バインド時のエラーは発生しません。 ただし、多くの場合、リード、バインド時のエラーを適切なメソッドを検索するオーバー ロードの解決が、失敗したときにします。

指定された引数の数が、メソッドのパラメーターの数よりも異なる場合、推論すぐに失敗します。 それ以外の場合、ジェネリック メソッドは、次のシグネチャであると仮定します。
```csharp
Tr M<X1,...,Xn>(T1 x1, ..., Tm xm)
```

フォームのメソッドの呼び出しで`M(E1...Em)`型の推定のタスクは、一意の型引数を検索する`S1...Sn`型パラメーターの各`X1...Xn`ように呼び出し`M<S1...Sn>(E1...Em)`が有効になります。

推論の処理中に、各型パラメーター`Xi`か*固定*特定の種類に`Si`または*fixed でない*関連付けられている一連の*境界*. 何らかの種類は、各範囲`T`します。 最初に、各型変数`Xi`境界の空のセットを固定することはありません。

型の推定は、フェーズで行われます。 各フェーズは前のフェーズの結果に基づいて複数の型の変数の型引数を推測しようとします。 最初のフェーズでは、2 番目のフェーズは、型の変数を特定の種類を修正し、境界をさらに推論は、境界の初期推論。 2 番目のフェーズがありますが何度も繰り返されます。

*注:* 型の推論は行われますがジェネリック メソッドが呼び出されたときにだけでなく。 メソッド グループの変換の型の推定については、「[メソッド グループの変換の推論を入力](expressions.md#type-inference-for-conversion-of-method-groups)に記載されて、一連の式の最適な一般的な種類を検索および[一連の最適一般的な種類を検索します。式の](expressions.md#finding-the-best-common-type-of-a-set-of-expressions)します。

#### <a name="the-first-phase"></a>最初のフェーズ

各メソッドの引数の`Ei`:

*   場合`Ei`、匿名関数、*明示的なパラメーター型の推論*([明示的なパラメーター型の推論](expressions.md#explicit-parameter-type-inferences)) から行われる`Ei`に `Ti`
*   の場合`Ei`型を持つ`U`と`xi`値を持つパラメーターには、*下限の推論*される*から* `U` *に*`Ti`.
*   の場合`Ei`型を持つ`U`と`xi`は、`ref`または`out`パラメーター、*の推定が正確な*される*から* `U`*に*`Ti`します。
*   それ以外の場合、この引数の推論は行われません。


#### <a name="the-second-phase"></a>2 番目のフェーズ

2 番目のフェーズは、次のように処理されます。

*   すべて*fixed でない*変数を入力`Xi`かどうか*依存*([依存](expressions.md#dependence))、`Xj`は固定 ([修正](expressions.md#fixing)).
*   このような型の変数が存在しない場合、すべて*fixed でない*入力変数`Xi`は*固定*は次のすべてを保持します。
    *   少なくとも 1 つの型の変数がある`Xj`に依存します。 `Xi`
    *   `Xi` 以外の空のセットを持つ境界
*   このような型の変数が存在しない場合にまだあります*fixed でない*変数の型、型推論は失敗します。
*   それ以外の場合、これ以上ない場合*fixed でない*型の変数の存在は、型の推定が成功するとします。
*   それ以外のすべての引数の`Ei`対応するパラメーターの型と`Ti`場所、*種類の出力*([出力タイプ](expressions.md#output-types)) が含まれて*fixed でない*変数を入力`Xj`が、*入力の種類*([入力の種類](expressions.md#input-types)) はない、*出力の型推論*([出力型の推論](expressions.md#output-type-inferences)) が行われた*から* `Ei` *に*`Ti`します。 2 番目のフェーズが繰り返されます。

#### <a name="input-types"></a>入力の種類

場合`E`メソッド グループ、または匿名関数を暗黙的に型指定と`T`がデリゲート型または式ツリー型のパラメーターの型をすべて`T`は*入力型*の`E` *型*`T`します。

####  <a name="output-types"></a>出力の種類

場合`E`はメソッド グループ、または匿名関数と`T`がデリゲート型または式ツリー型の戻り値の型`T`は、*出力の種類の* `E` *型* `T`.

#### <a name="dependence"></a>依存関係

*Fixed でない*型の変数`Xi`*に直接依存*、fixed でない型の変数`Xj`いくつかの引数の場合`Ek`型`Tk` `Xj`発生する、*入力型*の`Ek`型で`Tk`と`Xi`で発生する、*出力の種類*の`Ek`型`Tk`。

`Xj` *依存*`Xi`場合`Xj`*に直接依存*`Xi`場合`Xi`*に直接依存*`Xk`と`Xk`*異なります*`Xj`します。 したがって、「依存」に直接「依存」の推移的、再帰しないクロージャ。

#### <a name="output-type-inferences"></a>出力型の推論

*出力の型推論*される*から*式`E`*に*型`T`次のように。

*  場合`E`推論された戻り値の型を持つ匿名関数は、 `U` ([推定型を返す](expressions.md#inferred-return-type)) と`T`がデリゲート型または戻り値の型の式ツリー型`Tb`し*下限の推論*([下限の推論](expressions.md#lower-bound-inferences)) が行われた*から* `U` *に*`Tb`します。
*  の場合`E`メソッド グループと`T`がデリゲート型またはパラメーターの型の式ツリー型`T1...Tk`型を返すと`Tb`、オーバー ロードの解決と`E`型`T1...Tk`が得られます、1 つの戻り値の型を持つメソッド`U`、*下限の推論*される*から* `U` *に*`Tb`します。
*  の場合`E`型の式は、 `U`、、*下限の推論*される*から* `U` *に* `T`.
*  それ以外の場合、推論は行われません。

#### <a name="explicit-parameter-type-inferences"></a>明示的なパラメーター型の推論

*明示的なパラメーター型の推論*される*から*式`E`*に*型`T`次のように。

*  場合`E`パラメーターの型を明示的に型指定された匿名関数`U1...Uk`と`T`がデリゲート型またはパラメーターの型の式ツリー型`V1...Vk`各し`Ui`、*正確な推論*([推測の正確な](expressions.md#exact-inferences)) が行われた*から* `Ui` *に*、対応する`Vi`します。

#### <a name="exact-inferences"></a>正確な推論

*の推定が正確な**から*型`U`*に*型`V`次のようになります。

*  場合`V`の 1 つ、 *fixed でない*`Xi`し`U`の正確な境界のセットに追加されます`Xi`します。

*  それ以外の場合、設定`V1...Vk`と`U1...Uk`は、次の場合のいずれかが当てはまる場合にチェックによって決まります。

   *  `V` 配列型は、`V1[...]`と`U`配列型は、`U1[...]`同じランクの
   *  `V` 種類は、`V1?`と`U`型です `U1?`
   *  `V` 構築された型は、`C<V1...Vk>`と`U`は構築された型です。 `C<U1...Uk>`

   このような場合のいずれかが当てはまる場合、*の推定が正確な*される*から*各`Ui`*に*、対応する`Vi`します。

*  それ以外の場合の推論は行われません。

#### <a name="lower-bound-inferences"></a>下限の推論

A*下限の推論**から*型`U`*に*型`V`次のようになります。

*  場合`V`の 1 つ、 *fixed でない*`Xi`し`U`の下限のセットに追加されます`Xi`します。
*  の場合`V`型は、`V1?`と`U`型は、`U1?`から下限の境界の推論が行われる`U1`に`V1`します。
*  それ以外の場合、設定`U1...Uk`と`V1...Vk`は、次の場合のいずれかが当てはまる場合にチェックによって決まります。
   *  `V` 配列型は、`V1[...]`と`U`配列型は、 `U1[...]` (または有効な基本型が型パラメーター `U1[...]`) に同じランク
   *  `V` 1 つ`IEnumerable<V1>`、`ICollection<V1>`または`IList<V1>`と`U`1 次元配列の型は、 `U1[]`(または有効な基本型が型パラメーター `U1[]`)
   *  `V` 構築されたクラス、構造体、インターフェイスまたはデリゲートの型は、`C<V1...Vk>`一意の型があると`C<U1...Uk>`ように`U`(または、`U`が型パラメーター、その効果的な基底クラスまたはその有効なインターフェイス セットのすべてのメンバー) は、同じで (直接または間接的に) を継承または実装 (直接または間接的に)`C<U1...Uk>`します。

      (「一意性」制限が大文字と小文字のインターフェイスのことを意味`C<T> {} class U: C<X>, C<Y> {}`、推論がから推論するときに行われることはない`U`に`C<T>`ため`U1`可能性があります`X`または`Y`)。

   このような場合のいずれかが当てはまる推論が行われる場合*から*各`Ui`*に*、対応する`Vi`次のように。

   *  場合`Ui`は認識されない参照型であるため、*の推定が正確な*されます
   *  の場合`U`が配列型、*下限の推論*されます
   *  の場合`V`は`C<V1...Vk>`推論が、i 番目の型パラメーターに依存し、 `C`:
      *  共変である場合、*下限の推論*されます。
      *  反変である場合、*上限推論*されます。
      *  バリアント型でない場合、*の推定が正確な*されます。
*  それ以外の場合、推論は行われません。

#### <a name="upper-bound-inferences"></a>上限の推論

*上限の推論**から*型`U`*に*型`V`次のようになります。

*  場合`V`の 1 つ、 *fixed でない*`Xi`し`U`の上限のセットに追加されます`Xi`します。
*  それ以外の場合、設定`V1...Vk`と`U1...Uk`は、次の場合のいずれかが当てはまる場合にチェックによって決まります。
   *  `U` 配列型は、`U1[...]`と`V`配列型は、`V1[...]`同じランクの
   *  `U` 1 つ`IEnumerable<Ue>`、`ICollection<Ue>`または`IList<Ue>`と`V`は 1 次元配列の型です。 `Ve[]`
   *  `U` 種類は、`U1?`と`V`型です `V1?`
   *  `U` 構築されたクラス、構造体、インターフェイスまたはデリゲートの型は、`C<U1...Uk>`と`V`(直接または間接的に)、クラス、構造体、インターフェイスまたはデリゲートの型と一致する、(直接または間接的に) を継承または実装は、一意の型 `C<V1...Vk>`

      (「一意性」制限ことを意味がある場合`interface C<T>{} class V<Z>: C<X<Z>>, C<Y<Z>>{}`、推論がから推論するときに行われることはない`C<U1>`に`V<Q>`します。 推論が行われていない`U1`いずれかに`X<Q>`または`Y<Q>`)。

   このような場合のいずれかが当てはまる推論が行われる場合*から*各`Ui`*に*、対応する`Vi`次のように。
   *  場合`Ui`は認識されない参照型であるため、*の推定が正確な*されます
   *  の場合`V`が配列型、*上限推論*されます
   *  の場合`U`は`C<U1...Uk>`推論が、i 番目の型パラメーターに依存し、 `C`:
      *  共変である場合、*上限推論*されます。
      *  反変である場合、*下限の推論*されます。
      *  バリアント型でない場合、*の推定が正確な*されます。
*  それ以外の場合、推論は行われません。   

#### <a name="fixing"></a>修正

*Fixed でない*型の変数`Xi`境界のセットでは*固定*次のようにします。

*  一連の*候補型*`Uj`の境界のセット内のすべての型のセットとしては、まず`Xi`します。
*  各バインドを考察し`Xi`順番。各正確なバインドの`U`の`Xi`すべての種類`Uj`と同じされない`U`候補セットから削除されます。 各下限の境界の`U`の`Xi`すべての種類`Uj`があるが*いない*からの暗黙的な変換`U`候補セットから削除されます。 各上限の`U`の`Xi`すべての種類`Uj`からどの*いない*への暗黙的な変換`U`候補セットから削除されます。
*  残りの候補の種類の間での if`Uj`一意の型がある`V`が暗黙的な変換をすべて、その他の候補の種類にしから`Xi`に固定されて`V`。
*  それ以外の場合、型の推論は失敗します。

#### <a name="inferred-return-type"></a>推論された戻り値の型

推論される匿名関数の型を返す`F`型推論とオーバー ロードの解決中に使用されます。 すべてのパラメーター型がわかっていますが、いずれかが明示的に指定するための匿名関数の変換によって提供される、または推論型の推定をそれを囲むジェネリック中に、匿名関数に対する推論された戻り値の型を決定のみメソッドの呼び出し。

***結果型を推論***は次のように決定されます。

*  場合、本文の`F`は、*式*型の場合の推定の結果の型を持つ`F`その式の種類です。
*  場合、本文の`F`は、*ブロック*とブロックの内の式のセット`return`ステートメントが最適な一般的な型`T`([式のセットの最適な一般的な種類を検索する](expressions.md#finding-the-best-common-type-of-a-set-of-expressions)) の推定の結果の型、`F`は`T`します。
*  場合は、結果型を推論できません`F`します。

***戻り値の型を推論***は次のように決定されます。

*  場合`F`async およびの本文は`F`nothing として分類される式は、([式の分類](expressions.md#expression-classifications))、または return ステートメントに式が、されていないステートメント ブロック、推論された戻り値の型が `System.Threading.Tasks.Task`
*  場合`F`非同期であり、推論された結果型を持つ`T`、推論される戻り値の型が`System.Threading.Tasks.Task<T>`します。
*  場合`F`では、非同期であり、推論された結果型を持つ`T`、推論される戻り値の型が`T`します。
*  それ以外の場合の戻り値の型を推論できません`F`します。

匿名関数に関連する型の推定の例に、`Select`で宣言されている拡張メソッド、`System.Linq.Enumerable`クラス。
```csharp
namespace System.Linq
{
    public static class Enumerable
    {
        public static IEnumerable<TResult> Select<TSource,TResult>(
            this IEnumerable<TSource> source,
            Func<TSource,TResult> selector)
        {
            foreach (TSource element in source) yield return selector(element);
        }
    }
}
```

仮定すると、`System.Linq`名前空間がインポートされた、`using`句では、クラスと`Customer`で、`Name`型のプロパティ`string`、`Select`メソッドを使用して、顧客の一覧の名前を選択します。
```csharp
List<Customer> customers = GetCustomerList();
IEnumerable<string> names = customers.Select(c => c.Name);
```

拡張メソッドの呼び出し ([拡張メソッド呼び出し](expressions.md#extension-method-invocations)) の`Select`静的メソッドの呼び出しに呼び出しを書き直すことによって処理されます。
```csharp
IEnumerable<string> names = Enumerable.Select(customers, c => c.Name);
```

型引数が明示的に指定されていないために、型の推定は、型引数の推論に使用されます。 最初に、`customers`引数に関連する、`source`パラメーターへの推論`T`する`Customer`します。 推論プロセスが、上記で説明したが、匿名関数を使用して入力`c`型が指定`Customer`と式`c.Name`の戻り値の型に関連する、`selector`パラメーターへの推論`S`にする`string`. したがって、呼び出しと同じです。
```csharp
Sequence.Select<Customer,string>(customers, (Customer c) => c.Name)
```
され、結果は型の`IEnumerable<string>`します。

次の例では、匿名関数の型の推定により、ジェネリック メソッドの呼び出しで引数の間を"flow"に型情報。 メソッドを指定します。
```csharp
static Z F<X,Y,Z>(X value, Func<X,Y> f1, Func<Y,Z> f2) {
    return f2(f1(value));
}
```

呼び出しの推論を入力します。
```csharp
double seconds = F("1:15:30", s => TimeSpan.Parse(s), t => t.TotalSeconds);
```
次のように処理されます。最初に、引数`"1:15:30"`に関連する、`value`パラメーターへの推論`X`する`string`します。 Then の場合は、最初の匿名関数のパラメーター `s`、推論された型が指定`string`と式`TimeSpan.Parse(s)`の戻り値の型に関連する`f1`推論するとき、`Y`する`System.TimeSpan`します。 2 番目の匿名関数のパラメーターでは最後に、 `t`、推論された型が指定`System.TimeSpan`、および式`t.TotalSeconds`の戻り値の型に関連する`f2`推論するとき、`Z`する`double`。 したがって、呼び出しの結果は型`double`します。

#### <a name="type-inference-for-conversion-of-method-groups"></a>メソッド グループの変換の型の推論

ジェネリック メソッドの呼び出しと同様に、型の推論する必要がありますも時に適用される、メソッド グループ`M`を特定のデリゲート型に変換がジェネリック メソッドを含む`D`([メソッド グループ変換](conversions.md#method-group-conversions))。 メソッドの指定
```csharp
Tr M<X1...Xn>(T1 x1 ... Tm xm)
```
メソッド グループ`M`デリゲート型に割り当てられている`D`型の推定のタスクは、型引数を検索する`S1...Sn`ように式。
```csharp
M<S1...Sn>
```
互換性のあるになります ([デリゲートの宣言](delegates.md#delegate-declarations)) と`D`します。

ジェネリック メソッドの呼び出しの型推論アルゴリズムとは異なりこの場合がある引数だけ*型*、引数なし*式*します。 具体的には、匿名関数がないため、推論の複数のフェーズの必要はありません。

代わりに、すべて`Xi`と見なされます*fixed でない*、および*下限の推論*される*から*各引数の型`Uj`の`D`*に*対応するパラメーター型`Tj`の`M`します。 いずれかの場合、`Xi`境界が見つからなかったため、型推論が失敗します。 それ以外の場合、すべて`Xi`は*固定*を対応する`Si`型の推定の結果であります。

#### <a name="finding-the-best-common-type-of-a-set-of-expressions"></a>一連の式の最適な一般的な種類を検索します。

場合によっては、共通の型を式のセットを推論する必要があります。 特定の暗黙的に型指定された配列の要素の型と匿名関数の戻り値の型で*ブロック*本文にこの方法であります。

直感的に、与えられた一連の式の`E1...Em`この推定は、メソッドの呼び出しに相当する必要があります
```csharp
Tr M<X>(X x1 ... X xm)
```
`Ei`引数として。

正確には、推論から始まって、 *fixed でない*型の変数`X`します。 *出力型の推論*、割り当てられている*から*各`Ei`*に*`X`します。 最後に、`X`は*固定*し、成功した場合、その結果、入力`S`は、式の結果として得られる最適な一般的な型です。 そのような場合`S`存在する場合、式は、最高の一般的な型であるありません。

### <a name="overload-resolution"></a>オーバー ロードの解決

オーバー ロードの解決は、指定された引数リストおよび候補関数メンバーのセットを起動する最適な関数メンバーを選択するためのバインド時メカニズムです。 オーバー ロードの解決は、C# の次の異なるコンテキストで呼び出す関数メンバーを選択します。

*  という名前のメソッドの呼び出し、 *invocation_expression* ([メソッドの呼び出し](expressions.md#method-invocations))。
*  名前付きインスタンス コンストラクターの呼び出し、 *object_creation_expression* ([オブジェクト作成式](expressions.md#object-creation-expressions))。
*  インデクサーのアクセサーでの呼び出し、 *element_access* ([要素へのアクセス](expressions.md#element-access))。
*  式で参照されている定義済みまたはユーザー定義演算子の呼び出し ([単項演算子のオーバー ロードの解決](expressions.md#unary-operator-overload-resolution)と[二項演算子のオーバー ロードの解決](expressions.md#binary-operator-overload-resolution))。

前のセクションで詳しく説明されているように固有の方法で候補関数メンバーのセットと引数のリストを定義これらのコンテキストの各とします。 メソッドの呼び出しの候補のセットでマークされているメソッドが含まれませんなど`override`([メンバー ルックアップ](expressions.md#member-lookup)) との基本クラスのメソッドの候補場合は派生クラスで任意のメソッドは、適用可能な ([メソッドの呼び出し](expressions.md#method-invocations))。

関数メンバーの候補と引数リストを特定すると、最適な関数メンバーの選択は常に同じです。

*  該当する候補の関数メンバーのセットを指定するには、最善の関数メンバーであるセットが配置されています。 セットの 1 つだけの関数メンバーの場合は、その関数のメンバーは最適な関数メンバーです。 最適な関数メンバーは 1 つの関数メンバーを関数の各メンバーは、の規則を使用して他のすべての関数メンバーと比較されるときに、指定した引数リストに対して他のすべての関数メンバーよりも優れていますが、それ以外の場合、 [最適な関数メンバー](expressions.md#better-function-member)します。 他のすべての関数メンバーより 1 つの関数メンバーが一致しない場合は、関数メンバーの呼び出しがあいまいですし、およびバインド エラーが発生します。

次のセクションでは、用語の正確な意味を定義する***適用可能な関数メンバー***と***最適な関数メンバー***します。

#### <a name="applicable-function-member"></a>適用可能な関数メンバー

関数メンバーはモード、***適用可能な関数メンバー***引数リストに対して`A`が true で、次のすべての場合。

*  各引数`A`関数メンバーの宣言でのパラメーターに対応しています」の説明に従って[対応するパラメーター](expressions.md#corresponding-parameters)引数に対応するない任意のパラメーターは省略可能なパラメーター。
*  各引数に`A`、渡す引数のパラメーター (つまり、値は、 `ref`、または`out`) は、対応するパラメーターのパラメーター渡しモードと同じですし、
   *  値を持つパラメーターまたはパラメーターの配列では、暗黙的な変換 ([暗黙的な変換](conversions.md#implicit-conversions)) 引数から、対応するパラメーターの型に存在するか
   *  `ref`または`out`パラメーターの引数の型は、対応するパラメーターの型と同じです。 結局、`ref`または`out`パラメーターが渡される引数の別名です。

パラメーター配列を含む関数メンバーの関数メンバーは、上記の規則が適切である場合に適用されると言われますその***正規形***します。 パラメーター配列を含む関数のメンバーが、標準形式で適用されない場合は、関数メンバーがで該当する代わりに可能性、***フォーム展開***:

*  関数メンバーの宣言でパラメーターの配列を 0 に置き換えることにより拡張されたフォームを構築またはパラメーターの要素型の複数値パラメーターの配列など、引数リストの引数の数`A`合計と一致します。パラメーターの数。 場合`A`関数メンバーの宣言で固定のパラメーター数よりも少ない引数を持つ場合、関数メンバーの拡張の形式は構築できませんのでは適用されません。
*  それ以外の場合、拡張の形式は、の各引数の場合適用`A`引数のパラメーター渡しモードは、対応するパラメーターのパラメーター渡しモードと同じですし、
   *  固定値を持つパラメーターまたは拡張、暗黙的な変換によって作成された値を持つパラメーター ([暗黙的な変換](conversions.md#implicit-conversions)) 引数の型から、対応するパラメーターの型に存在するか、
   *  `ref`または`out`パラメーターの引数の型は、対応するパラメーターの型と同じです。

#### <a name="better-function-member"></a>最適な関数メンバー

最適な関数メンバーを決定するためには、式を含むだけ、引数自体、元の引数リストに表示される順序で取り除いた引数リスト A が構築されます。

パラメーターは、各メンバーは、次のように構築されている候補関数の一覧です。

*  関数メンバーが展開された形式でのみ使用できる場合は、拡張の形式が使用されます。
*  対応する引数なしで省略可能なパラメーターがパラメーター リストから削除されます。
*  パラメーターの順序は変更を対応する引数として、引数リスト内の同じ位置にあります。

引数リストを指定された`A`一連の引数の式の`{E1, E2, ..., En}`と 2 つの適用可能な関数メンバー`Mp`と`Mq`パラメーターの型で`{P1, P2, ..., Pn}`と`{Q1, Q2, ..., Qn}`、`Mp`として定義されている、***最適な関数メンバー***より`Mq`場合

*  各引数の暗黙の変換から`Ex`に`Qx`から暗黙の変換よりも適切でない`Ex`に`Px`と
*  少なくとも 1 つの引数からの変換の`Ex`に`Px`からの変換よりもをお勧め`Ex`に`Qx`します。

場合、この評価を実行するときに`Mp`または`Mq`が展開されたフォームでは、該当する`Px`または`Qx`パラメーター リストの拡張の形式でパラメーターを参照します。

場合は、パラメーター型シーケンス `{P1, P2, ..., Pn}`と`{Q1, Q2, ..., Qn}`は同等です (つまり各`Pi`が、対応する id 変換`Qi`)、良いを判断する順序で、次のリンク付け規則が適用されます関数のメンバー。

*  場合`Mp`は非ジェネリック メソッドと`Mq`はジェネリック メソッドでは、`Mp`よりは`Mq`。
*  の場合`Mp`オプションは、標準形式に該当し、`Mq`が、`params`配列し、は、拡張形式でのみ使用できる`Mp`よりも優れていますが`Mq`。
*  の場合`Mp`よりもパラメーターを宣言の詳細が`Mq`、し`Mp`よりは`Mq`します。 これは、両方の方法がある場合に発生することが`params`配列と、拡張形式でのみ適用されます。
*  それ以外の場合のすべてのパラメーター`Mp`で少なくとも 1 つの省略可能なパラメーターの代わりに使用する既定の引数が必要がありますが、対応する引数を持つ`Mq`し`Mp`よりは`Mq`します。
*  の場合`Mp`よりも具体的なパラメーターの型を持つ`Mq`、し`Mp`よりは`Mq`します。 ように`{R1, R2, ..., Rn}`と`{S1, S2, ..., Sn}`のインスタンス化されていないと、展開されていないパラメーターの型を表す`Mp`と`Mq`します。 `Mp`パラメーターの型がよりも具体的`Mq`の場合、各パラメーターの`Rx`よりも小さい固有ではない`Sx`と少なくとも 1 つのパラメーターの`Rx`よりも特定`Sx`:
   *  型パラメーターは、非型パラメーターよりも小さい固有です。
   *  再帰的に構築された型が別の構築された型 (型引数の同じ番号) を持つ場合、少なくとも 1 つの入力引数の指定がより具体的と型引数が、それ以外の対応する型の引数よりも限定しないよりも限定します。
   *  配列型は、最初の要素の型は、2 番目の要素の型よりも具体的である場合 (同じ次元数) で別の配列型より固有です。
*  それ以外の場合 1 つのメンバーは非リフトされた演算子と、リフトされた演算子、もう一方は、非リフトされた 1 つが向上します。
*  それ以外の場合、どちらの関数メンバーお勧めします。

#### <a name="better-conversion-from-expression"></a>式からより適切な変換

暗黙的な変換を指定`C1`式から変換`E`型に`T1`、および暗黙的な変換を`C2`式から変換`E`型に`T2`、 `C1`***変換の改善***より`C2`場合`E`は完全に一致しない`T2`し、次の少なくとも 1 つを保持します。

* `E` 完全に一致する`T1`([式に正確に一致する](expressions.md#exactly-matching-expression))
* `T1` 優れた変換ターゲット`T2`([優れた変換ターゲット](expressions.md#better-conversion-target))

#### <a name="exactly-matching-expression"></a>完全に一致する式

式が指定`E`と型`T`、`E`完全に一致する`T`次のいずれかが保持している場合。

*  `E` 型を持つ`S`からの id 変換が存在して`S`に `T`
*  `E` 匿名関数、`T`デリゲート型は、`D`または式ツリー型`Expression<D>`し、次のいずれかを保持します。
   *  推論された戻り値の型`X`が存在する`E`のパラメーター リストのコンテキストで`D`([推定型を返す](expressions.md#inferred-return-type)) からの id 変換が存在して`X`の戻り値の型に `D`
   *  いずれか`E`は非同期ではないと`D`戻り値の型を持つ`Y`または`E`は async と`D`戻り値の型を持つ`Task<Y>`、し、次のいずれかを保持します。
      * 本文`E`を完全に一致する式は、 `Y`
      * 本文`E`を完全に一致するすべての return ステートメント返しますが、式、ステートメント ブロックには `Y`

#### <a name="better-conversion-target"></a>変換対象の向上

2 つの種類を指定`T1`と`T2`、`T1`よりも優れた、変換対象`T2`場合からの暗黙的な変換なし`T2`に`T1`が存在して、次の少なくとも 1 つを保持します。

*  暗黙的な変換`T1`に`T2`が存在します。
*  `T1` デリゲート型は、`D1`または式ツリー型`Expression<D1>`、`T2`デリゲート型は、`D2`または式ツリー型`Expression<D2>`、`D1`戻り値の型を持つ`S1`のいずれかと、次の保留:
   * `D2` void を返す
   * `D2` 戻り値の型を持つ`S2`、および`S1`よりも優れた変換対象は、 `S2`
*  `T1` `Task<S1>`、`T2`は`Task<S2>`、および`S1`よりも優れた変換対象は、 `S2`
*  `T1` `S1`または`S1?`場所`S1`は符号付き整数型と`T2`は`S2`または`S2?`場所`S2`は符号なし整数型。 具体的には、次のように使用します。
   * `S1` `sbyte`と`S2`は`byte`、 `ushort`、 `uint`、または `ulong`
   * `S1` `short`と`S2`は`ushort`、 `uint`、または `ulong`
   * `S1` `int`と`S2`は`uint`、または `ulong`
   * `S1` `long`と`S2`は `ulong`

#### <a name="overloading-in-generic-classes"></a>ジェネリック クラスのオーバー ロード

宣言された署名は、一意である必要があります、シグネチャが同じ結果を型引数の置換することができます。 このような場合は、上記のオーバー ロードの解決の対フスェケェルェニェヒ規則は、特定のメンバーが選択されます。

次の例では、有効であり、このルールに従って無効であるオーバー ロードを示します。

```csharp
interface I1<T> {...}

interface I2<T> {...}

class G1<U>
{
    int F1(U u);                  // Overload resolution for G<int>.F1
    int F1(int i);                // will pick non-generic

    void F2(I1<U> a);             // Valid overload
    void F2(I2<U> a);
}

class G2<U,V>
{
    void F3(U u, V v);            // Valid, but overload resolution for
    void F3(V v, U u);            // G2<int,int>.F3 will fail

    void F4(U u, I1<V> v);        // Valid, but overload resolution for    
    void F4(I1<V> v, U u);        // G2<I1<int>,int>.F4 will fail

    void F5(U u1, I1<V> v2);      // Valid overload
    void F5(V v1, U u2);

    void F6(ref U u);             // valid overload
    void F6(out V v);
}
```

### <a name="compile-time-checking-of-dynamic-overload-resolution"></a>コンパイル時の動的なオーバー ロードの解決の確認

最も動的にバインドされた操作の解決候補のセットはコンパイル時に既知ではありません。 ただし、場合によっては候補の集合がコンパイル時に呼ばれるは。

*  動的引数を持つ静的メソッドの呼び出し
*  受信側が動的な式ではないインスタンス メソッドの呼び出し
*  インデクサー呼び出しの受信側が動的な式ではありません。
*  動的引数を持つコンストラクターの呼び出し

このような場合は、制限付きのコンパイル時チェックが実行時にいずれかが適用可能性があるかどうかに表示するには、各候補に対して実行されます。このチェックは、次の手順で構成されます。

*  部分型の推定:任意の型引数を型の引数に直接または間接的には依存しません`dynamic`推論のルールを使用して[型推論](expressions.md#type-inference)します。 残りの型引数は既知ではありません。
*  部分的な適用性チェック:適用性のチェックによる[適用可能な関数メンバー](expressions.md#applicable-function-member)、既知の型がないパラメーターは無視されますが、します。
*  このテストに合格する候補がない、コンパイル時エラーが発生します。

### <a name="function-member-invocation"></a>関数メンバーの呼び出し

このセクションでは、特定の関数メンバーを呼び出すための実行時に発生するプロセスについて説明します。 バインディング時の処理の呼び出しは、場合によって適用することでオーバー ロードの解決、一連の関数メンバーの候補にするには、特定のメンバーが既に判断したと見なされます。

呼び出しプロセスを記述するために、関数メンバーは、2 つのカテゴリに分類されます。

*  静的な関数メンバー。 これらは、インスタンス コンストラクター、静的メソッド、静的なプロパティ アクセサー、およびユーザー定義の演算子。 静的な関数メンバーは、非仮想では常にします。
*  関数のインスタンス メンバーです。 これらは、インスタンス メソッド、インスタンス プロパティ アクセサー、およびインデクサーのアクセサー。 インスタンス関数メンバーは、仮想でないか、仮想、およびは、特定のインスタンスに常に呼び出されます。 インスタンスがインスタンス式によって計算され、関数はメンバー内でアクセス可能になります`this`([このアクセス](expressions.md#this-access))。

関数メンバーの呼び出しの実行時の処理は、次の手順で構成されていますここ`M`関数メンバーは、し、場合は、`M`インスタンス メンバー`E`インスタンス式です。

*  場合`M`は静的な関数メンバーです。
   * 」の説明に従って、引数リストが評価される[引数リスト](expressions.md#argument-lists)します。
   * `M` 呼び出されます。

*  場合`M`インスタンス関数のメンバーで宣言、 *value_type*:
   * `E` 評価されます。 この評価は、例外を発生させ場合、その後の手順は実行されません。
   * 場合`E`変数、その後の一時ローカル変数として分類されない`E`の型が作成されると値の`E`その変数に代入されます。 `E` 一時ローカル変数への参照として再分類します。 一時変数のアクセシビリティが`this`内`M`が、その他の方法ではありません。 したがって、場合にのみ`E`が true の変数は、呼び出し元が、変更を確認できますを`M`を`this`します。
   * 」の説明に従って、引数リストが評価される[引数リスト](expressions.md#argument-lists)します。
   * `M` 呼び出されます。 によって参照される変数`E`によって参照される変数になります`this`します。

*  場合`M`インスタンス関数のメンバーで宣言、 *reference_type*:
   * `E` 評価されます。 この評価は、例外を発生させ場合、その後の手順は実行されません。
   * 」の説明に従って、引数リストが評価される[引数リスト](expressions.md#argument-lists)します。
   * 場合の種類`E`は、 *value_type*、ボックス化変換 ([ボックス化変換](types.md#boxing-conversions)) に変換する実行`E`を入力する`object`と`E`と見なされます型にする`object`で、次の手順。 この場合、`M`のメンバーである可能性がありますのみ`System.Object`します。
   * 値`E`がチェックを有効にします。 場合の値`E`は`null`、`System.NullReferenceException`がスローされます、以降の手順は実行されません。
   * 呼び出す関数メンバーの実装が決定されます。
     * バインディング時の型の場合`E`インターフェイスで呼び出す関数メンバーの実装は、`M`によって参照されるインスタンスの実行時の型によって提供される`E`します。 この関数のメンバーがインターフェイスのマッピング規則を適用して決定されます ([インターフェイス マップ](interfaces.md#interface-mapping)) の実装を決定する`M`によって参照されるインスタンスの実行時の型によって提供される`E`します。
     * の場合`M`仮想関数のメンバーでは、呼び出す関数メンバーの実装は、`M`によって参照されるインスタンスの実行時の型によって提供される`E`します。 この関数のメンバーが、最派生実装を決定するルールを適用して決定されます ([仮想メソッド](classes.md#virtual-methods)) の`M`によって参照されるインスタンスの実行時の型に関して`E`します。
     * それ以外の場合、`M`非仮想関数メンバー、および関数メンバーを呼び出すが、`M`自体。
   * 上記の手順で決定関数メンバーの実装が呼び出されます。 によって参照されるオブジェクト`E`によって参照されるオブジェクトになります`this`します。

#### <a name="invocations-on-boxed-instances"></a>ボックス化されたインスタンス上の呼び出し

関数メンバーの実装で、 *value_type*のボックス化されたインスタンスを呼び出すことができます*value_type*次の状況で。

*  関数メンバーの場合、`override`型から継承されたメソッドの`object`が型のインスタンス式から呼び出されると`object`します。
*  関数メンバーがインターフェイスの関数メンバーの実装がのインスタンス式から呼び出される、 *interface_type*します。
*  ときに関数メンバーはデリゲートを介して呼び出されます。

変数を含むこのような状況でボックス化されたインスタンスと見なされます、 *value_type*、この変数で参照される変数になり`this`関数メンバーの呼び出し内で。 具体的には、関数メンバーがボックス化されたインスタンスで呼び出されると、ボックス化されたインスタンスに含まれる値を変更する関数メンバーの可能なは、これは意味します。

## <a name="primary-expressions"></a>基本式

一次式には、式の最も簡単なフォームが含まれます。

```antlr
primary_expression
    : primary_no_array_creation_expression
    | array_creation_expression
    ;

primary_no_array_creation_expression
    : literal
    | interpolated_string_expression
    | simple_name
    | parenthesized_expression
    | member_access
    | invocation_expression
    | element_access
    | this_access
    | base_access
    | post_increment_expression
    | post_decrement_expression
    | object_creation_expression
    | delegate_creation_expression
    | anonymous_object_creation_expression
    | typeof_expression
    | checked_expression
    | unchecked_expression
    | default_value_expression
    | nameof_expression
    | anonymous_method_expression
    | primary_no_array_creation_expression_unsafe
    ;
```

一次式に分かれています*array_creation_expression*s と*primary_no_array_creation_expression*秒。 この方法では、配列作成式を扱う、と共に、他の式の単純なフォームを指定することではなくによりなどの混乱を招く可能性のあるコードを許可しないようにする文法
```csharp
object o = new int[3][1];
```
それ以外の場合として解釈されるします。
```csharp
object o = (new int[3])[1];
```

### <a name="literals"></a>リテラル

A *primary_expression*で構成される、*リテラル*([リテラル](lexical-structure.md#literals)) 値として分類されます。


### <a name="interpolated-strings"></a>挿入文字列

*Interpolated_string_expression*から成る、`$`記号の後に正規表現または逐語的文字列リテラル、穴の区切られ`{`と`}`式を囲みますおよび書式設定仕様。 補間文字列式の結果とは、 *interpolated_string_literal*が分割されている個々 のトークンに」の説明に従って[リテラル文字列の補間](lexical-structure.md#interpolated-string-literals)します。

```antlr
interpolated_string_expression
    : '$' interpolated_regular_string
    | '$' interpolated_verbatim_string
    ;

interpolated_regular_string
    : interpolated_regular_string_whole
    | interpolated_regular_string_start interpolated_regular_string_body interpolated_regular_string_end
    ;

interpolated_regular_string_body
    : interpolation (interpolated_regular_string_mid interpolation)*
    ;

interpolation
    : expression
    | expression ',' constant_expression
    ;

interpolated_verbatim_string
    : interpolated_verbatim_string_whole
    | interpolated_verbatim_string_start interpolated_verbatim_string_body interpolated_verbatim_string_end
    ;

interpolated_verbatim_string_body
    : interpolation (interpolated_verbatim_string_mid interpolation)+
    ;
```

*Constant_expression* 、補間で暗黙的に変換をいる必要があります`int`します。

*Interpolated_string_expression*値として分類されます。 場合にすぐに変換されます`System.IFormattable`または`System.FormattableString`補間文字列の暗黙的な変換を使用 ([補間文字列の変換を暗黙的な](conversions.md#implicit-interpolated-string-conversions))、補間文字列式がその型。 それ以外の場合、型を持つ`string`します。

補間文字列の型が場合`System.IFormattable`または`System.FormattableString`、意味の呼び出しは、 `System.Runtime.CompilerServices.FormattableStringFactory.Create`。 型の場合`string`、式の意味はへの呼び出し`string.Format`します。 どちらの場合も、呼び出しの引数リストは、各補間のプレース ホルダーと引数のプレース ホルダーに対応する各式のリテラル書式指定文字列で構成されます。

形式の文字列リテラルは、次のように構築された、`N`で補間の数が、 *interpolated_string_expression*:

*  場合、 *interpolated_regular_string_whole*または*interpolated_verbatim_string_whole*に依存して、`$`形式の文字列リテラルはそのトークンに署名します。
*  それ以外の場合、リテラルの書式指定文字列で構成されます。 
   *  最初、 *interpolated_regular_string_start*または*interpolated_verbatim_string_start*
   *  各数値し`I`から`0`に`N-1`: 
      * 10 進表記 `I`
      * 場合、対応する*補間*が、 *constant_expression*、`,`の値の 10 進表記 (コンマ) 後に、 *constant_expression*
      * 次に、 *interpolated_regular_string_mid*、 *interpolated_regular_string_end*、 *interpolated_verbatim_string_mid*または*interpolated_verbatim_string_end*直後に対応する補間します。

後続の引数は単に、*式*から、*補間*(ある場合) の順序で。

TODO: 例。


### <a name="simple-names"></a>単純な名前

A *simple_name*型引数リストが続く必要に応じて、識別子で構成されます。

```antlr
simple_name
    : identifier type_argument_list?
    ;
```

A *simple_name*形式のいずれかです`I`またはフォームの`I<A1,...,Ak>`ここで、`I`は、単一の識別子と`<A1,...,Ak>`は省略可能な*type_argument_list*します。 ない場合*type_argument_list*が指定するを検討してください`K`を 0 にします。 *Simple_name*が評価され、次のように分類されます。

*  場合`K`は 0 です、 *simple_name*内に表示する、*ブロック*場合に、*ブロック*の (または、それを囲む*ブロック*の) ローカル変数の宣言領域 ([宣言](basic-concepts.md#declarations)) ローカル変数、パラメーターまたは名前の定数を含む `I`、 *simple_name* 、そのローカル変数を参照パラメーターまたは定数、変数または値として分類されます。
*  場合`K`ゼロ、 *simple_name*ジェネリック メソッドの宣言の本文内に表示し、その宣言には、名前の型パラメーターが含まれている場合 `I`、 *simple_name*その型パラメーターを参照します。
*  それ以外の場合、各インスタンス タイプ `T`([インスタンス型](classes.md#the-instance-type))、すぐ外側の型宣言のインスタンスの型を起動し、各外側のクラスまたは構造体のインスタンスの型を続行宣言 (ある場合):
   *  場合`K`は 0 との宣言`T`名前の型パラメーターを含む `I`、 *simple_name*その型パラメーターを参照します。
   *  それ以外の場合、メンバーの検索 ([メンバー ルックアップ](expressions.md#member-lookup)) の`I`で`T`で`K` 型引数が一致するものが生成されます。
      * 場合`T`すぐ外側のクラスまたは構造体の型のインスタンスの型は、検索でいずれかが識別や以上のメソッドは、結果は、メソッドのグループの関連付けられたインスタンス式がある`this`します。 ジェネリック メソッドの呼び出しで使用される型引数リストが指定されている場合 ([メソッドの呼び出し](expressions.md#method-invocations))。
      * の場合`T`すぐ外側のクラスまたは構造体の型のインスタンスの型は、検索は、インスタンス メンバーを識別し、インスタンス コンストラクター、インスタンス メソッドまたはインスタンス アクセサーの本文内の参照が発生した場合、メンバー アクセスと同じになります ([メンバー アクセス](expressions.md#member-access)) フォームの`this.I`します。 これはのみに発生時に`K`は 0 です。
      * それ以外の場合、結果は、メンバー アクセスと同じ ([メンバー アクセス](expressions.md#member-access)) フォームの`T.I`または`T.I<A1,...,Ak>`します。 ここでは、バインド エラーには、 *simple_name*インスタンス メンバーを参照します。

*  それ以外の名前空間ごとに `N`を名前空間を以降の*simple_name*発生すると、次の手順は、各名前空間 (存在する場合)、および末尾に、グローバル名前空間を続行します。エンティティが見つかるまで評価されます。
   *  場合`K`ゼロと`I`で名前空間の名前を指定 `N`、し。
      * 場合、場所を*simple_name*が発生した名前空間の宣言で囲まれた`N`名前空間宣言が含まれています、 *extern_alias_directive*または*using_alias_directive*名前に関連付ける `I`型、または名前空間、 *simple_name*があいまいですし、コンパイル時エラーが発生します。
      * それ以外の場合、 *simple_name*という名前の名前空間を指す`I`で`N`します。
   *  の場合`N`名前を持つアクセス可能な型が含まれています `I`と`K` し、パラメーターを入力します。
      * 場合`K`は 0 と場所を*simple_name*が発生した名前空間の宣言で囲まれた`N`名前空間宣言が含まれています、 *extern_alias_directive*または*using_alias_directive*名前に関連付ける `I`型、または名前空間、 *simple_name*があいまいですし、コンパイル時エラーが発生します。
      * それ以外の場合、 *namespace_or_type_name*は特定の型引数を使用して構築型を表します。
   *  の場合、場所を、 *simple_name*が発生した名前空間の宣言で囲まれた `N`:
      * 場合`K`がゼロで、名前空間宣言が含まれています、 *extern_alias_directive*または*using_alias_directive*名前に関連付ける `I`でインポートされた名前空間または型、 *simple_name*その名前空間または型を参照します。
      * それ以外の場合、名前空間と型の宣言をインポートした場合、 *using_namespace_directive*s と*using_static_directive*名前空間宣言の s がアクセス可能な型の 1 つだけを含めるか、拡張機能の非静的メンバーの名前を持つ `I`と`K` パラメーター、入力、 *simple_name*参照すると、その型またはメンバーの型引数を使用して構築します。
      * それ以外の場合、名前空間と型をインポートした場合、 *using_namespace_directive*名前空間の宣言の 1 つ以上のアクセス可能な型または名前を持つ拡張メソッドでは非静的メンバーを含む `I`と`K` パラメーター、入力、 *simple_name*があいまい、エラーが発生します。

   この全体の手順では、対応する手順の処理中に完全に並列に注意してください、 *namespace_or_type_name* ([Namespace と型の名前](basic-concepts.md#namespace-and-type-names))。

*  それ以外の場合、 *simple_name*は未定義となり、コンパイル時エラーが発生します。


### <a name="parenthesized-expressions"></a>かっこで囲まれた式

A *parenthesized_expression*から成る、*式*かっこで囲まれています。

```antlr
parenthesized_expression
    : '(' expression ')'
    ;
```

A *parenthesized_expression*は評価することによって評価されます、*式*かっこで囲まれています。 場合、*式*かっこで囲ま表します名前空間または型、コンパイル時エラーが発生します。 それ以外の場合の結果、 *parenthesized_expression*の格納されている評価の結果は、*式*します。

### <a name="member-access"></a>メンバー アクセス。

A *member_access*から成る、 *primary_expression*、 *predefined_type*、または*qualified_alias_member*"と、その後`.`"トークン、その後に、*識別子*、必要に応じてその後に、 *type_argument_list*します。

```antlr
member_access
    : primary_expression '.' identifier type_argument_list?
    | predefined_type '.' identifier type_argument_list?
    | qualified_alias_member '.' identifier
    ;

predefined_type
    : 'bool'   | 'byte'  | 'char'  | 'decimal' | 'double' | 'float' | 'int' | 'long'
    | 'object' | 'sbyte' | 'short' | 'string'  | 'uint'   | 'ulong' | 'ushort'
    ;
```

*Qualified_alias_member*で定義されている運用[Namespace エイリアス修飾子](namespaces.md#namespace-alias-qualifiers)します。

A *member_access*形式のいずれかです`E.I`またはフォームの`E.I<A1, ..., Ak>`ここで、`E`プライマリ式は、`I`は、単一の識別子と`<A1, ..., Ak>`は省略可能な*type_argument_list*します。 ない場合*type_argument_list*が指定するを検討してください`K`を 0 にします。

A *member_access*で、 *primary_expression*型の`dynamic`が動的にバインドされている ([動的バインド](expressions.md#dynamic-binding))。 ここで、コンパイラが型のプロパティ アクセスにメンバー アクセスを分類`dynamic`します。 意味を調べるには、次の規則、 *member_access*ランタイムのコンパイル時の型ではなく、実行時の型を使用するのには、適用、 *primary_expression*します。 このランタイムの分類は、メソッド グループにつながるかどうかは、メンバー アクセスである必要があります、 *primary_expression*の*invocation_expression*します。

*Member_access*が評価され、次のように分類されます。

*  場合`K`ゼロと`E`名前空間と`E`入れ子になった名前空間が含まれています `I`、結果はその名前空間。
*  の場合`E`名前空間と`E`名前を持つアクセス可能な型が含まれています `I`と`K`  、結果は指定された型引数で構築された型のパラメーターを入力します。
*  場合`E`は、 *predefined_type*または*primary_expression*場合は、型に分類`E`が型パラメーターでない場合、メンバーの検索 ([メンバー ルックアップ](expressions.md#member-lookup))`I`で`E`で`K` し、型パラメーターに一致するが生成されます`E.I`が評価され、次のように分類されます。
   *  場合`I`結果はその型指定された型引数を使用して構築型を識別します。
   *  場合`I`結果は関連付けられたインスタンス式を指定せずに、メソッド グループに 1 つまたは複数のメソッドを識別します。 ジェネリック メソッドの呼び出しで使用される型引数リストが指定されている場合 ([メソッドの呼び出し](expressions.md#method-invocations))。
   *  場合`I`識別、`static`プロパティ、結果は、プロパティへのアクセスに関連付けられたインスタンス式がありません。
   *  場合`I`識別、`static`フィールド。
      * フィールドの場合`readonly`クラスまたは構造体のフィールドが宣言されているの静的コンストラクターの外部参照が発生し、結果は、値、つまり静的フィールドの値と `I`で `E`します。
      * それ以外の場合、結果は、変数、静的フィールド namely `I`で `E`します。
   *  場合`I`識別、`static`イベント。
      * クラスまたは構造体をイベントを宣言し、イベントなしで宣言された参照が発生したかどうか*event_accessor_declarations* ([イベント](classes.md#events))、し`E.I`が正確に処理されます。まるで`I`スタティック フィールドします。
      * それ以外の場合、関連付けられたインスタンス式を指定イベント アクセスになりません。
   *  場合`I`結果は、値、つまりその定数の値に定数を識別します。
    * 場合`I`結果は、値、つまりその列挙体メンバーの値を列挙メンバーを識別します。
    * それ以外の場合、`E.I`無効なメンバー参照であり、コンパイル時エラーが発生します。
*  場合`E`プロパティへのアクセス、インデクサーのアクセス、変数、または、型が値 `T`、およびメンバーの検索 ([メンバー ルックアップ](expressions.md#member-lookup)) の`I`で`T`で`K`  型引数をし、一致する生成`E.I`が評価され、次のように分類されます。
   *  最初に、場合`E`プロパティまたはインデクサーのアクセスは、プロパティの値またはインデクサー アクセスが取得される ([式の値](expressions.md#values-of-expressions)) と`E`値として再分類します。
   *  場合`I`、結果は、メソッドのグループの関連付けられたインスタンス式が 1 つまたは複数のメソッドを識別する`E`します。 ジェネリック メソッドの呼び出しで使用される型引数リストが指定されている場合 ([メソッドの呼び出し](expressions.md#method-invocations))。
   *  場合`I`インスタンス プロパティを識別します。
      * 場合`E`は`this`、 `I` 、自動的に実装されたプロパティを識別します ([自動実装プロパティ](classes.md#automatically-implemented-properties)) のインスタンス コンストラクター内で set アクセス操作子、および参照が発生せず、クラスまたは構造体型`T`、結果は、変数によって指定される自動プロパティの非表示のバッキング フィールド namely`I`のインスタンスで`T`によって指定された`this`します。
      * 結果の式が関連付けられているインスタンスのプロパティ アクセスは、それ以外の場合、 `E`します。
   *  場合`T`は、 *class_type*と`I`のインスタンス フィールドを識別する*class_type*:
      * 場合の値`E`は`null`、`System.NullReferenceException`がスローされます。
      * それ以外の場合、フィールドの場合`readonly`フィールドが宣言されているクラスのインスタンス コンストラクターの外部参照が発生し、結果は、値、つまり、フィールドの値と `I`によって参照されるオブジェクトで `E`します。
      * それ以外の場合、結果は、変数、つまりフィールド `I`によって参照されるオブジェクトで `E`します。
   *  場合`T`は、 *struct_type*と`I`のインスタンス フィールドを識別する*struct_type*:
      * 場合`E`、値は、フィールドの場合、または`readonly`フィールドが宣言されている構造体のインスタンス コンストラクターの外部参照が発生し、結果は、値、つまり、フィールドの値と `I`で指定された構造体のインスタンスで `E`.
      * それ以外の場合、結果は、変数、つまりフィールド `I`で指定された構造体のインスタンスで `E`します。
   *  場合`I`インスタンス イベントを識別します。
      * クラスまたは構造体をイベントを宣言し、イベントなしで宣言された参照が発生したかどうか*event_accessor_declarations* ([イベント](classes.md#events)) に、参照が発生しないと、左側にある、`+=`または`-=`演算子、`E.I`が正確に処理される場合と`I`されたインスタンス フィールド。
      * それ以外の場合、結果は、イベントの関連付けられたインスタンス式があるアクセス `E`します。
*  それ以外の場合、しようとしましたが処理`E.I`拡張メソッド呼び出しとして ([拡張メソッド呼び出し](expressions.md#extension-method-invocations))。 これが失敗すると、`E.I`無効なメンバー参照であり、バインド時のエラーが発生します。

#### <a name="identical-simple-names-and-type-names"></a>同一の簡易名と型名

形式のメンバー アクセスで`E.I`場合は、 `E` 、単一の識別子は、場合の意味`E`として、 *simple_name* ([簡易名](expressions.md#simple-names)) 定数、フィールド、プロパティ、ローカル変数またはパラメーターの意味と同じ型と`E`として、 *type_name* ([Namespace と型の名前](basic-concepts.md#namespace-and-type-names))、しの両方の可能性のある意味`E`は許可されています。 2 つの可能性のある意味`E.I`されないため、あいまいな`I`型のメンバーであるとは限りません`E`どちらの場合もします。 つまり、ルールだけアクセスを許可する静的メンバーと入れ子にされた型の`E`コンパイル時エラーが発生した、それ以外の場合。 例:
```csharp
struct Color
{
    public static readonly Color White = new Color(...);
    public static readonly Color Black = new Color(...);

    public Color Complement() {...}
}

class A
{
    public Color Color;                // Field Color of type Color

    void F() {
        Color = Color.Black;           // References Color.Black static member
        Color = Color.Complement();    // Invokes Complement() on Color field
    }

    static void G() {
        Color c = Color.White;         // References Color.White static member
    }
}
```

#### <a name="grammar-ambiguities"></a>文法のあいまいさ

生産*simple_name* ([簡易名](expressions.md#simple-names)) と*member_access* ([メンバー アクセス](expressions.md#member-access)) のあいまいさを得ることができます、式の文法。 たとえば、次のようなステートメントがあるとします。
```
F(G<A,B>(7));
```
呼び出しとして解釈される可能性`F`、2 つの引数で`G < A`と`B > (7)`します。 呼び出しとしても解釈される可能性`F`1 つの引数はジェネリック メソッドの呼び出し `G`2 つの型引数と 1 つの通常の引数。

トークンのシーケンスを (コンテキストで) として解析できるかどうか、 *simple_name* ([簡易名](expressions.md#simple-names))、 *member_access* ([メンバー アクセス](expressions.md#member-access))、または*pointer_member_access* ([ポインターのメンバー アクセス](unsafe-code.md#pointer-member-access)) で終わる、 *type_argument_list* ([引数を入力](types.md#type-arguments))、トークンの終了の直後に続く`>`トークンが調べられます。 いずれかである場合
```csharp
(  )  ]  }  :  ;  ,  .  ?  ==  !=  |  ^
```
次に、 *type_argument_list*はの一部として保持され、 *simple_name*、 *member_access*または*pointer_member_access*と、トークンのシーケンスの考えられるその他の解析は破棄されます。 それ以外の場合、 *type_argument_list*の一部であるとは見なされません、 *simple_name*、 *member_access*または*pointer_member_access*トークンのシーケンスの考えられるその他の解析がない場合でも、します。 解析するときに、これらの規則がないので注意が適用される、 *type_argument_list*で、 *namespace_or_type_name* ([Namespace と型の名前](basic-concepts.md#namespace-and-type-names))。 次のステートメント、
```csharp
F(G<A,B>(7));
```
このルールに従って解釈されますへの呼び出しとして`F`1 つの引数はジェネリック メソッドの呼び出し`G`2 つの型引数と 1 つの通常の引数。 ステートメント
```csharp
F(G < A, B > 7);
F(G < A, B >> 7);
```
呼び出しとして解釈されます各`F`2 つの引数を使用します。 次のステートメント、
```csharp
x = F < A > +y;
```
ステートメントを記述した場合と、小なり演算子、演算子と単項プラス演算子よりも大きいと解釈されます`x = (F < A) > (+y)`の代わりとして、 *simple_name*で、 *type_argument_list*二項プラス演算子を続けています。 ステートメントで
```csharp
x = y is C<T> + z;
```
トークン`C<T>`として解釈されます、 *namespace_or_type_name*で、 *type_argument_list*します。

### <a name="invocation-expressions"></a>Invocation 式

*Invocation_expression*メソッドを呼び出すために使用します。

```antlr
invocation_expression
    : primary_expression '(' argument_list? ')'
    ;
```

*Invocation_expression*が動的にバインドされている ([動的バインド](expressions.md#dynamic-binding))、次の少なくとも 1 つ保持している場合。

* *Primary_expression*コンパイル時の型を持つ`dynamic`します。
* オプションの少なくとも 1 つの引数*argument_list*コンパイル時の型を持つ`dynamic`と*primary_expression*デリゲート型がありません。

この場合、コンパイラは、分類、 *invocation_expression*型の値として`dynamic`します。 意味を調べるには、次の規則、 *invocation_expression*実行時、のコンパイル時の型ではなく、実行時の型を使用するのには、適用、 *primary_expression*とコンパイル時の型引数`dynamic`します。 場合、 *primary_expression*コンパイル時の型が`dynamic`、メソッドの呼び出しで」の説明に従って、制限付きのコンパイル時のチェックが行われ、[コンパイル時の動的なオーバー ロードの解決の確認](expressions.md#compile-time-checking-of-dynamic-overload-resolution).

*Primary_expression*の*invocation_expression*メソッド グループ、またはの値にする必要があります、 *delegate_type*します。 場合、 *primary_expression* 、メソッド グループには、 *invocation_expression*メソッドの呼び出しは、([メソッドの呼び出し](expressions.md#method-invocations))。 場合、 *primary_expression*の値であり、 *delegate_type*、 *invocation_expression*デリゲートの呼び出しは、([デリゲートの呼び出し](expressions.md#delegate-invocations)). 場合、 *primary_expression*はメソッド グループでの値も、 *delegate_type*、バインド エラーが発生します。

省略可能な*argument_list* ([引数リスト](expressions.md#argument-lists)) メソッドのパラメーター値または変数参照を提供します。

評価した結果、 *invocation_expression*次のように分類されます。

*  場合、 *invocation_expression*メソッドまたはを返すデリゲートが呼び出される`void`結果はありません。 コンテキストでのみ許可されているが何に分類される式を*statement_expression* ([式ステートメント](statements.md#expression-statements)) またはの本文として、 *lambda_expression*([匿名関数式](expressions.md#anonymous-function-expressions))。 それ以外の場合、バインド時のエラーが発生します。
*  それ以外の場合、メソッドまたはデリゲートによって返される型の値になります。

#### <a name="method-invocations"></a>メソッドの呼び出し

メソッドの呼び出し、 *primary_expression*の*invocation_expression*メソッド グループである必要があります。 メソッド グループでは、1 つのメソッドを呼び出すまたは特定のメソッドを呼び出すを選択できるオーバー ロードされたメソッドのセットを識別します。 後者の場合、呼び出す特定のメソッドの決定は、引数の型によって提供されるコンテキストに基づきます、 *argument_list*します。

フォームのメソッドの呼び出しのバインド時の処理`M(A)`ここで、`M`メソッド グループ (を含めることも、 *type_argument_list*)、および`A`は省略可能な*argument_リスト*、次の手順で構成されます。

*  メソッドの呼び出しの候補のメソッドのセットが構築されます。 各メソッドの`F`メソッド グループに関連付けられた`M`:
   *  場合`F`非ジェネリック型`F`候補とき。
      * `M` 型引数リストがないと
      * `F` 適用できる`A`([適用可能な関数メンバー](expressions.md#applicable-function-member))。
   *  場合`F`がジェネリックと`M`型引数のリストを持たない`F`候補とき。
      * 型の推論 ([型推論](expressions.md#type-inference)) 成功すると、呼び出し、型引数の一覧への推論と
      * F のパラメーター リストですべて構築された型が、その制約を満たす、推論された型引数は、対応するメソッドの型パラメーターに置き換え、([制約条件を満たす](types.md#satisfying-constraints))、およびのパラメーターのリスト`F`を適用できる`A`([適用可能な関数メンバー](expressions.md#applicable-function-member))。
   *  場合`F`ジェネリックと`M`型引数リストが含まれています`F`候補とき。
      * `F` 型引数リストで指定されたメソッド型パラメーターの同じ番号を持つと
      * F のパラメーター リストですべて構築された型が、その制約を満たす型引数は、対応するメソッドの型パラメーターに置き換え、([制約条件を満たす](types.md#satisfying-constraints))、およびパラメーター リストの`F`適用できる`A`([適用可能な関数メンバー](expressions.md#applicable-function-member))。
*  候補メソッドのセットは、最派生型からのみを含むに縮小されます。各メソッドの`C.F`、セット内で`C`の種類は、メソッド`F`の基本型で宣言されているすべてのメソッド宣言`C`セットから削除されます。 さらに場合、`C`クラス型は他にも、`object`インターフェイス型で宣言されているすべてのメソッドは、セットから削除されます。 (この後者の規則のみが影響メソッド グループがオブジェクト以外の有効な基本クラスと、空でない有効なインターフェイス セットを持つ型パラメーターでメンバーの検索の結果です。)
*  候補メソッドの結果セットが空の場合は、さらに、次の手順に沿った処理は中止され、代わりに試行されると、呼び出しを拡張メソッド呼び出しとして処理する ([拡張メソッド呼び出し](expressions.md#extension-method-invocations)). これが失敗した場合、適用可能なメソッドが存在していないため、し、バインド エラーが発生します。
*  オーバー ロード解決規則を使用して候補メソッドのセットの最適な方法が識別される[オーバー ロードの解決](expressions.md#overload-resolution)します。 、1 つの最適な方法を識別できない場合、メソッドの呼び出しはあいまいであり、バインド エラーが発生します。 オーバー ロードの解決を実行するには、対応するメソッドの型パラメーターのジェネリック メソッドのパラメーターが型引数 (指定または推論) を代入した後と見なされます。
*  選択した最適な方法の最終的な検証が実行されます。
   * メソッドは、メソッド グループのコンテキストで検証されます。最適な方法が静的メソッドの場合、メソッド グループが得、 *simple_name*または*member_access*型を通じてします。 最適な方法が、インスタンス メソッドの場合、メソッド グループが得、 *simple_name*、 *member_access*変数または値、または*base_access*します。 これらの要件のどちらが true の場合、バインド時のエラーが発生します。
   * (指定または推論) の型引数が制約に照らしてチェックが最適なメソッドがジェネリック メソッドの場合 ([制約条件を満たす](types.md#satisfying-constraints)) ジェネリック メソッドで宣言します。 すべての型引数が、型パラメーターに対応する制約を満たしていない場合、バインド時のエラーが発生します。

説明されている関数メンバーの呼び出しの規則に従って実行時の実際の呼び出しを処理するメソッドを選択し、上記の手順によって、バインド時に検証されましたが、[コンパイル時の動的なオーバー ロードの解決の確認](expressions.md#compile-time-checking-of-dynamic-overload-resolution).

上記で説明した解決ルールの直感的な影響は次のとおりです。メソッドの呼び出しによって起動される特定のメソッドを検索するにはメソッドの呼び出しで示される型で始めて、少なくとも 1 つの適用可能なアクセス可能なオーバーライドではないメソッドの宣言が見つかるまで、継承チェーンを続行できます。 型の推定を実行しオーバー ロードの解決では、その型で宣言されている適用可能なアクセス可能なオーバーライドではないメソッドのセットと、選択されているため、メソッドを呼び出します。 メソッドが見つからなかった場合は、呼び出しを拡張メソッド呼び出しとして処理する代わりにしてください。

#### <a name="extension-method-invocations"></a>拡張メソッドの呼び出し

メソッドの呼び出しで ([ボックス化されたインスタンス上の呼び出し](expressions.md#invocations-on-boxed-instances))、フォームの 1 つの
```csharp
expr . identifier ( )

expr . identifier ( args )

expr . identifier < typeargs > ( )

expr . identifier < typeargs > ( args )
```
呼び出しの通常の処理に適用可能なメソッドが検出されない場合、拡張メソッドの呼び出しとして構造の処理を試行します。 場合*expr*またはのいずれか、 *args*コンパイル時の型を持つ`dynamic`、拡張メソッドは適用されません。

目的は、一番*type_name* `C`、対応する静的メソッド呼び出しを実行できるようにします。
```csharp
C . identifier ( expr )

C . identifier ( expr , args )

C . identifier < typeargs > ( expr )

C . identifier < typeargs > ( expr , args )
```

拡張メソッド`Ci.Mj`は***対象となる***場合。

*  `Ci` 非ジェネリックの入れ子になっていないクラス
*  名前`Mj`は*識別子*
*  `Mj` アクセス可能で、上記のように、引数に静的メソッドとして適用されるときに適用できます。
*  暗黙的な id、参照変換またはボックス化変換が存在する*expr*の最初のパラメーターの型に`Mj`します。

検索`C`次のように進みます。

*  以降、それを囲む各名前空間宣言を続行し、コンパイル単位で終わるの最も近いの外側の名前空間宣言での拡張メソッドの候補セットを連続する試行が行われます。
   * 指定された名前空間またはコンパイル ユニットに直接汎用でない型宣言が含まれるかどうか`Ci`資格のある拡張メソッドで`Mj`、それらの拡張メソッドのセットは、候補の集合です。
   * 場合型`Ci`によってインポートされた*using_static_declarations*によってインポートされた名前空間で直接宣言と*using_namespace_directive*で指定された名前空間またはコンパイル ユニットを直接 s対象となる拡張メソッドを含む`Mj`、それらの拡張メソッドのセットは、候補の集合。
*  それを囲む名前空間の宣言またはコンパイル単位の候補のセットが見つからない場合は、コンパイル時エラーが発生します。
*  示すように設定する候補にオーバー ロードの解決を適用する場合は、([オーバー ロードの解決](expressions.md#overload-resolution))。 1 つの最適な方法が見つからない場合は、コンパイル時エラーが発生します。
*  `C` 拡張メソッドとして最適な方法を宣言する型です。

使用して`C`静的メソッドの呼び出しとして処理し、メソッドの呼び出しのターゲットとして ([コンパイル時の動的なオーバー ロードの解決チェック](expressions.md#compile-time-checking-of-dynamic-overload-resolution))。

インスタンス メソッドが拡張メソッドより優先順位を取得、拡張メソッドの内部名前空間の宣言で使用可能な優先される拡張メソッドの外部名前空間の宣言、およびその拡張機能で使用できるという意味で、上記の規則名前空間で直接宣言されたメソッドを使用して、その同じ空間にインポートされた拡張メソッドよりも優先名前空間ディレクティブ。 例:
```csharp
public static class E
{
    public static void F(this object obj, int i) { }

    public static void F(this object obj, string s) { }
}

class A { }

class B
{
    public void F(int i) { }
}

class C
{
    public void F(object obj) { }
}

class X
{
    static void Test(A a, B b, C c) {
        a.F(1);              // E.F(object, int)
        a.F("hello");        // E.F(object, string)

        b.F(1);              // B.F(int)
        b.F("hello");        // E.F(object, string)

        c.F(1);              // C.F(object)
        c.F("hello");        // C.F(object)
    }
}
```

例では、`B`の最初の拡張メソッドより優先されるメソッドと`C`のメソッドが両方の拡張メソッドより優先されます。

```csharp
public static class C
{
    public static void F(this int i) { Console.WriteLine("C.F({0})", i); }
    public static void G(this int i) { Console.WriteLine("C.G({0})", i); }
    public static void H(this int i) { Console.WriteLine("C.H({0})", i); }
}

namespace N1
{
    public static class D
    {
        public static void F(this int i) { Console.WriteLine("D.F({0})", i); }
        public static void G(this int i) { Console.WriteLine("D.G({0})", i); }
    }
}

namespace N2
{
    using N1;

    public static class E
    {
        public static void F(this int i) { Console.WriteLine("E.F({0})", i); }
    }

    class Test
    {
        static void Main(string[] args)
        {
            1.F();
            2.G();
            3.H();
        }
    }
}
```

この例の出力は次のとおりです。
```
E.F(1)
D.G(2)
C.H(3)
```
`D.G` も優先`C.G`、および`E.F`両方よりも優先`D.F`と`C.F`します。

#### <a name="delegate-invocations"></a>デリゲートの呼び出し

デリゲートの呼び出しの*primary_expression*の*invocation_expression*の値を指定する必要があります、 *delegate_type*します。 さらに、検討、 *delegate_type*と同じパラメーター リストを持つ関数メンバーである、 *delegate_type*、 *delegate_type* (該当する必要があります[適用可能な関数メンバー](expressions.md#applicable-function-member)) を*argument_list*の*invocation_expression*します。

フォームのデリゲートの呼び出しの実行時の処理`D(A)`ここで、`D`は、 *primary_expression*の*delegate_type*と`A`は省略可能な*argument_list*、次の手順で構成されます。

*  `D` 評価されます。 この評価は、例外を発生させ、その後の手順は実行されません。
*  値`D`がチェックを有効にします。 場合の値`D`は`null`、`System.NullReferenceException`がスローされます、以降の手順は実行されません。
*  それ以外の場合、`D`デリゲート インスタンスへの参照です。 関数メンバーの呼び出し ([コンパイル時の動的なオーバー ロードの解決チェック](expressions.md#compile-time-checking-of-dynamic-overload-resolution)) の各デリゲートの呼び出しリストで呼び出し可能なエンティティで実行されます。 呼び出し可能なエンティティのインスタンスとインスタンス メソッドで構成される場合は、特定の呼び出しのインスタンスは、呼び出し可能なエンティティに含まれているインスタンスです。

### <a name="element-access"></a>要素へのアクセス

*Element_access*から成る、 *primary_no_array_creation_expression*、その後に、"`[`"トークン、その後に、 *argument_list*、その後に、"`]`"トークンです。 *Argument_list* 1 つまたは複数から成る*引数*s、コンマで区切られました。

```antlr
element_access
    : primary_no_array_creation_expression '[' expression_list ']'
    ;
```

*Argument_list*の*element_access*を格納することはできません`ref`または`out`引数。

*Element_access*が動的にバインドされている ([動的バインド](expressions.md#dynamic-binding))、次の少なくとも 1 つ保持している場合。

* *Primary_no_array_creation_expression*コンパイル時の型を持つ`dynamic`します。
* 少なくとも 1 つの式、 *argument_list*コンパイル時の型を持つ`dynamic`と*primary_no_array_creation_expression*配列型はありません。

この場合、コンパイラは、分類、 *element_access*型の値として`dynamic`します。 意味を調べるには、次の規則、 *element_access*実行時、のコンパイル時の型ではなく、実行時の型を使用するのには、適用、 *primary_no_array_creation_expression*と*argument_list*コンパイル時の型を持つことが式`dynamic`します。 場合、 *primary_no_array_creation_expression*コンパイル時の型が`dynamic`、」の説明に従って、要素へのアクセスが制限付きのコンパイル時のチェックを受けて、[コンパイル時の動的なチェックオーバー ロードの解決](expressions.md#compile-time-checking-of-dynamic-overload-resolution)します。

場合、 *primary_no_array_creation_expression*の*element_access*の値であり、 *array_type*、 *element_access*が、配列のアクセス ([配列アクセス](expressions.md#array-access))。 それ以外の場合、 *primary_no_array_creation_expression*変数またはクラス、構造体、またはインターフェイスの種類を 1 つまたは複数のインデクサーのメンバーを持つ場合の値を指定する必要があります、 *element_access*が、インデクサー アクセス ([インデクサー アクセス](expressions.md#indexer-access))。

#### <a name="array-access"></a>配列へのアクセス

配列アクセスの場合、 *primary_no_array_creation_expression*の*element_access*の値を指定する必要があります、 *array_type*します。 さらに、 *argument_list*配列のアクセスは名前付き引数を格納する許可されません。式の数、 *argument_list*のランクと同じである必要があります、 *array_type*、各式は、型にする必要がありますと`int`、 `uint`、 `long`、 `ulong`、または 1 つ以上のこれらの型に暗黙的に変換する必要があります。

配列のアクセスの評価結果は、namely で式の値で選択されている配列要素配列の要素型の変数、 *argument_list*します。

フォームの配列のアクセスの実行時の処理`P[A]`ここで、`P`は、 *primary_no_array_creation_expression*の*array_type*と`A`には*argument_list*、次の手順で構成されます。

*  `P` 評価されます。 この評価は、例外を発生させ、その後の手順は実行されません。
*  インデックスの式、 *argument_list*左から右への順序で評価されます。 次の各インデックスの式の暗黙の変換の評価 ([暗黙的な変換](conversions.md#implicit-conversions))、次の種類のいずれかに実行されます: `int`、 `uint`、 `long`、`ulong`します。 暗黙的な変換が存在するこのリストの最初の型が選択されます。 たとえば、型の場合は、インデックスの式`short`への暗黙的な変換し`int`以降からの暗黙的な変換を実行`short`に`int`との間`short`に`long`が考えられます。 インデックス式またはそれ以降の暗黙的な変換の評価は、例外を発生させ場合、は、さらにインデックスの式は評価されませんしそれ以上の手順が実行されます。
*  値`P`がチェックを有効にします。 場合の値`P`は`null`、`System.NullReferenceException`がスローされます、以降の手順は実行されません。
*  内の各式の値、 *argument_list*によって参照される配列インスタンスの各次元の実際の境界と照合されます`P`します。 1 つまたは複数の値が範囲外にある場合、`System.IndexOutOfRangeException`がスローされます、以降の手順は実行されません。
*  インデックス式で指定された配列要素の位置を計算し、この場所の配列へのアクセスの結果になります。

#### <a name="indexer-access"></a>インデクサーへのアクセス

インデクサー アクセス用、 *primary_no_array_creation_expression*の*element_access*変数またはクラス、構造体、またはインターフェイスの型の値を指定する必要があり、この型は、1 つまたは複数を実装する必要があります適用できるインデクサー、 *argument_list*の*element_access*します。

フォームのインデクサー アクセスのバインド時の処理`P[A]`ここで、`P`は、 *primary_no_array_creation_expression*クラス、構造体、またはインターフェイス型の`T`、および`A`が、*argument_list*、次の手順で構成されます。

*  一連のインデクサーによって提供される`T`を構築します。 宣言されているすべてのインデクサーはセット`T`の基本型または`T`れていない`override`宣言とは、現在のコンテキストでアクセスできるように ([メンバー アクセス](basic-concepts.md#member-access))。
*  セットは、その他のインデクサーによって隠ぺいされていない適用可能なインデクサーだけに縮小されます。 次の規則は、各インデクサーに適用されます`S.I`、セット内で`S`の種類は、インデクサー`I`は宣言されています。
   * 場合`I`を適用可能でない`A`([適用可能な関数メンバー](expressions.md#applicable-function-member))、し`I`セットから削除されます。
   * 場合`I`を適用できる`A`([適用可能な関数メンバー](expressions.md#applicable-function-member)) の基本型ですべてのインデクサーを宣言し、`S`セットから削除されます。
   * 場合`I`を適用できる`A`([適用可能な関数メンバー](expressions.md#applicable-function-member)) と`S`クラス型は他にも、`object`インターフェイスで宣言されているすべてのインデクサーは、セットから削除されます。
*  インデクサーの候補の結果セットが空の場合、該当するインデクサーが存在していないため、し、バインド エラーが発生します。
*  オーバー ロード解決規則を使用して、一連の候補のインデクサーの最適なインデクサーが識別される[オーバー ロードの解決](expressions.md#overload-resolution)します。 1 つの最適なインデクサーを識別できない場合、インデクサー アクセスはあいまいであり、バインド エラーが発生します。
*  インデックスの式、 *argument_list*左から右への順序で評価されます。 インデクサーのアクセスの処理の結果は、インデクサー アクセスとして分類される式です。 インデクサー アクセス式は、上記の手順で決定されたインデクサーが参照し、の関連付けられたインスタンス式があります`P`と関連付けられている引数リストの`A`します。

インデクサー アクセスのいずれかの呼び出しの原因が使用されるコンテキストに応じて、 *get アクセサー*または*set アクセサー*のインデクサー。 インデクサーへのアクセスが、割り当ての対象である場合、 *set アクセサー*新しい値を割り当てるために呼び出される ([単純な代入](expressions.md#simple-assignment))。 その他のすべてのケースで、 *get アクセサー* 、現在の値を取得するために呼び出す ([式の値](expressions.md#values-of-expressions))。

### <a name="this-access"></a>このアクセス

A *this_access*予約語から成る`this`します。

```antlr
this_access
    : 'this'
    ;
```

A *this_access*でのみ許可されている、*ブロック*のインスタンス コンストラクター、インスタンス メソッドまたはインスタンス アクセサー。 意味は次のいずれかがあります。

*  ときに`this`で使用されて、 *primary_expression*クラスのインスタンス コンストラクター、内の値として分類されます。 値の型は、インスタンスの型 ([インスタンス型](classes.md#the-instance-type)) で、使用状況が発生した、値が構築されるオブジェクトへの参照をクラスの。
*  ときに`this`で使用されて、 *primary_expression*値として、インスタンス メソッドまたはクラスのインスタンスのアクセサー内で分類されます。 値の型は、インスタンスの型 ([インスタンス型](classes.md#the-instance-type)) で、使用状況が発生した、値がメソッドまたはアクセサーが呼び出されたオブジェクトへの参照をクラスの。
*  ときに`this`で使用されて、 *primary_expression*構造体のインスタンス コンストラクター内で変数として分類されます。 変数の型は、インスタンスの型 ([インスタンス型](classes.md#the-instance-type)) の構造体で、使用状況が発生した、変数が作成される構造体を表します。 `this`構造体のインスタンス コンストラクターの変数はまったく同じように動作する`out`構造体の型のパラメーター-具体的には、つまり、変数を間違いなく、インスタンスのすべての実行パスで割り当てる必要がありますコンストラクターです。
*  ときに`this`で使用されて、 *primary_expression*内で、インスタンス メソッドまたはインスタンス アクセサー構造体の変数として分類されます。 変数の型は、インスタンスの型 ([インスタンス型](classes.md#the-instance-type)) 使用する構造体の。
   * メソッドまたはアクセサーは、反復子ではない場合 ([反復子](classes.md#iterators))、`this`変数は、対象の構造体、メソッドまたはアクセサーが呼び出されたとまったく同じ動作を表します、`ref`構造体の型のパラメーター。
   * メソッドまたはアクセサーが、反復子の場合、`this`変数は、対象のメソッドまたはアクセサーが呼び出され、構造体の型の値を持つパラメーターとまったく同じ動作には、構造体のコピーを表します。

使用`this`で、 *primary_expression*上に挙げた以外のコンテキストでは、コンパイル時エラー。 具体的を参照することはできません`this`または静的プロパティのアクセサーでは、静的メソッドで、 *variable_initializer*フィールド宣言のです。

### <a name="base-access"></a>基本アクセス

A *base_access*の予約語で構成されます`base`か後に、"`.`"トークン識別子や、 *argument_list*角かっこで囲まれています。

```antlr
base_access
    : 'base' '.' identifier
    | 'base' '[' expression_list ']'
    ;
```

A *base_access*現在のクラスまたは構造体で同じ名前のメンバーでは非表示の基本クラス メンバーにアクセスするために使用します。 A *base_access*でのみ許可されている、*ブロック*のインスタンス コンストラクター、インスタンス メソッドまたはインスタンス アクセサー。 ときに`base.I`クラスまたは構造体で発生した`I`そのクラスまたは構造体の基本クラスのメンバーを表す必要があります。 同様に、`base[E]`を適用できるインデクサーは、基底クラスに存在する必要があります、クラス内に発生します。

バインディング時に、 *base_access*形式の式`base.I`と`base[E]`書き込まれている場合と同じように評価されます`((B)this).I`と`((B)this)[E]`ここで、`B`クラスの基本クラスですまたは、構造体、構造に発生します。 したがって、`base.I`と`base[E]`に対応`this.I`と`this[E]`、除く`this`基底クラスのインスタンスとして表示されています。

ときに、 *base_access*うち決定関数の実行時に呼び出すメンバー仮想関数メンバー (メソッド、プロパティ、またはインデクサー) を参照して ([コンパイル時の動的なオーバー ロードの解決の確認](expressions.md#compile-time-checking-of-dynamic-overload-resolution)) が変更されました。 呼び出される関数メンバーは、最派生実装を見つけることによって決まります ([仮想メソッド](classes.md#virtual-methods)) を関数メンバーの`B`(の代わりの実行時の型に関して`this`、としてなりますベース以外のアクセスに通常)。 内でそのため、`override`の`virtual`関数のメンバー、 *base_access*関数メンバーの継承された実装を呼び出すために使用できます。 によって参照される関数のメンバーである場合、 *base_access*は抽象でバインド エラーが発生します。

### <a name="postfix-increment-and-decrement-operators"></a>置インクリメント演算子と前置デクリメント演算子

```antlr
post_increment_expression
    : primary_expression '++'
    ;

post_decrement_expression
    : primary_expression '--'
    ;
```

オペランドの後置インクリメントまたはデクリメント操作は、変数、プロパティ アクセス、またはインデクサー アクセスとして分類される式をする必要があります。 操作の結果は、オペランドと同じ型の値です。

場合、 *primary_expression*コンパイル時の型を持つ`dynamic`演算子が動的にバインドし、([動的バインド](expressions.md#dynamic-binding))、 *post_increment_expression*または*post_decrement_expression*コンパイル時の型を持つ`dynamic`の実行時の型を使用して実行時に次の規則を適用し、 *primary_expression*します。

場合は、オペランドを後置のインクリメントまたはデクリメント演算は、プロパティまたはインデクサー アクセス、プロパティまたはインデクサーが両方必要、`get`と`set`アクセサー。 サポートしていない場合は、バインド時エラーが発生します。

単項演算子のオーバー ロードの解決 ([単項演算子のオーバー ロードの解決](expressions.md#unary-operator-overload-resolution)) を適用して特定の演算子の実装を選択します。 定義済みの`++`と`--`演算子は、次の種類の存在: `sbyte`、 `byte`、 `short`、 `ushort`、 `int`、 `uint`、 `long`、 `ulong`、 `char`、 `float`、 `double`、 `decimal`、および任意の列挙型。 定義済み`++`演算子がオペランドを定義済みに 1 を追加することによって生成された値を返す`--`演算子オペランドから 1 を引いた値を返します。 `checked`場合この加算または減算の結果が結果の型の範囲外と結果型が整数型または列挙型では、コンテキスト、`System.OverflowException`がスローされます。

実行時の処理の後置インクリメントまたはデクリメント演算子は、フォームの`x++`または`x--`次の手順で構成されています。

*   場合`x`変数として分類されます。
    * `x` 変数を生成するために評価されます。
    * 値`x`保存されます。
    * 選択した演算子が呼び出されるの保存された値と`x`引数として。
    * 評価によって指定した位置に、演算子によって返される値が格納されている`x`します。
    * 保存された値`x`操作の結果になります。
*   場合`x`プロパティまたはインデクサーのアクセスに分類されます。
    * インスタンス式 (場合`x`ない`static`) および引数リスト (場合`x`インデクサー アクセス) に関連付けられている`x`が評価されると、その後で、結果の使用`get`と`set`アクセサーの呼び出し。
    * `get`のアクセサー`x`が呼び出される、返される値を保存します。
    * 選択した演算子が呼び出されるの保存された値と`x`引数として。
    * `set`のアクセサー`x`が呼び出されると演算子によって返される値とその`value`引数。
    * 保存された値`x`操作の結果になります。

`++`と`--`演算子もサポートしてプレフィックス表記 ([前置インクリメントとデクリメント演算子](expressions.md#prefix-increment-and-decrement-operators))。 結果では通常、`x++`または`x--`の値は、`x`操作の前に一方の結果`++x`または`--x`の値は、`x`操作の完了後します。 いずれの場合も、`x`自体、操作の後に同じ値に含まれています。

`operator ++`または`operator --`実装は、いずれかの後置または前置表記を使用して呼び出すことができます。 2 つの表記の個別の演算子の実装を持つことはできません。

### <a name="the-new-operator"></a>新しい演算子

`new`演算子を使用して、型の新しいインスタンスを作成します。

3 つの形式がある`new`式。

*  オブジェクト作成式は、クラス型と値の型の新しいインスタンスを作成に使用されます。
*  配列作成式は、配列型の新しいインスタンスを作成に使用されます。
*  型のデリゲートの新しいインスタンスを作成するデリゲート作成式が使用されます。

`new`演算子は、型のインスタンスの作成を意味しますが、メモリの動的な割り当てを必ずしも意味しません。 具体的には、値型のインスタンスには存在して、動的な割り当ては発生しませんが、変数を超える追加のメモリ必要ないとき`new`値型のインスタンスを作成するために使用します。

#### <a name="object-creation-expressions"></a>オブジェクト作成式

*Object_creation_expression*の新しいインスタンスを作成するために使用する*class_type*または*value_type*します。

```antlr
object_creation_expression
    : 'new' type '(' argument_list? ')' object_or_collection_initializer?
    | 'new' type object_or_collection_initializer
    ;

object_or_collection_initializer
    : object_initializer
    | collection_initializer
    ;
```

*型*の*object_creation_expression*必要があります、 *class_type*、 *value_type*または*type_parameter*. *型*することはできません、 `abstract` *class_type*します。

省略可能な*argument_list* ([引数リスト](expressions.md#argument-lists)) 場合にのみが許可されている、*型*は、 *class_type*または*struct_型*します。

オブジェクト作成式でコンストラクターの引数リストを省略でき、外側のかっこ、オブジェクト初期化子またはコレクション初期化子が含まれています。 コンストラクターの引数リストを省略して、外側のかっこは、空の引数リストを指定することと同じです。

オブジェクト初期化子またはコレクション初期化子を含むオブジェクト作成式の処理は、最初にインスタンス コンストラクターを処理し、オブジェクト初期化子 (で指定されたメンバーまたは要素の初期化を処理し、[オブジェクト初期化子](expressions.md#object-initializers)) またはコレクション初期化子 ([コレクション初期化子](expressions.md#collection-initializers))。

場合、省略可能な引数のいずれか*argument_list*コンパイル時の型を持つ`dynamic`、 *object_creation_expression*が動的にバインドされている ([の動的バインド](expressions.md#dynamic-binding))これらの引数の実行時の型を使用して実行時に次の規則を適用し、 *argument_list*コンパイル時の型がある`dynamic`します。 オブジェクトの作成に限定のコンパイル時のチェックが行われます」の説明に従って、[コンパイル時の動的なオーバー ロードの解決チェック](expressions.md#compile-time-checking-of-dynamic-overload-resolution)します。

バインド時の処理、 *object_creation_expression*フォームの`new T(A)`ここで、`T`は、 *class_type*または*value_type*と`A`は省略可能な*argument_list*、次の手順で構成されます。

*   場合`T`は、 *value_type*と`A`が存在しません。
    * *Object_creation_expression*は既定のコンストラクターの呼び出し。 結果、 *object_creation_expression*型の値は、`T`の既定値 namely`T`で定義されている[、System.ValueType 型](types.md#the-systemvaluetype-type)します。
*   の場合`T`は、 *type_parameter*と`A`が存在しません。
    * 値型の制約またはコンストラクター制約のない場合 ([入力パラメーターの制約](classes.md#type-parameter-constraints)) が指定されている`T`、バインド エラーが発生します。
    * 結果、 *object_creation_expression*型パラメーターのバインドが、実行時型の値は、その型の既定のコンストラクターの呼び出しの namely の結果。 実行時の型には、参照型または値型があります。
*   の場合`T`は、 *class_type*または*struct_type*:
    * 場合`T`は、 `abstract` *class_type*コンパイル時エラーが発生します。
    * インスタンス コンストラクターを呼び出すには、オーバー ロード解決規則を使用して決定されます[オーバー ロードの解決](expressions.md#overload-resolution)します。 インスタンス コンストラクターの候補のセットの構成で宣言されているすべてのアクセス可能なインスタンス コンストラクターが`T`に関して適用される`A`([適用可能な関数メンバー](expressions.md#applicable-function-member))。 インスタンス コンストラクターの候補のセットが空の場合、または 1 つの最適なインスタンス コンストラクターを識別できない場合は、バインド時のエラーが発生します。
    * 結果、 *object_creation_expression*型の値は、 `T`、つまり前の手順で決定されたインスタンス コンストラクターを呼び出すことによって生成される値。
*  それ以外の場合、 *object_creation_expression*が有効でないバインド時のエラーが発生したとします。

場合でも、 *object_creation_expression*は動的にバインドすると、コンパイル時の型がまだ`T`します。

実行時の処理、 *object_creation_expression*フォームの`new T(A)`ここで、`T`は*class_type*または*struct_type*と`A`は省略可能な*argument_list*、次の手順で構成されます。

*   場合`T`は、 *class_type*:
    * クラスの新しいインスタンス`T`が割り当てられます。 新しいインスタンスを割り当てることができる十分なメモリがない場合、`System.OutOfMemoryException`がスローされます、以降の手順は実行されません。
    * 新しいインスタンスのすべてのフィールドが既定値に初期化されます ([既定値](variables.md#default-values))。
    * 関数メンバーの呼び出しの規則に従って、インスタンス コンストラクターが呼び出されます ([コンパイル時の動的なオーバー ロードの解決チェック](expressions.md#compile-time-checking-of-dynamic-overload-resolution))。 新しく割り当てられたインスタンスへの参照が自動的にインスタンス コンストラクターに渡されます、としてコンストラクターの中から、インスタンスにアクセスできる`this`します。
*   場合`T`は、 *struct_type*:
    * 型のインスタンス`T`は一時ローカル変数を割り当てることによって作成されます。 以降のインスタンス コンストラクター、 *struct_type*一時変数の初期化する必要はありませんが、作成中のインスタンスの各フィールドに値を確実に代入するが必要です。
    * 関数メンバーの呼び出しの規則に従って、インスタンス コンストラクターが呼び出されます ([コンパイル時の動的なオーバー ロードの解決チェック](expressions.md#compile-time-checking-of-dynamic-overload-resolution))。 新しく割り当てられたインスタンスへの参照が自動的にインスタンス コンストラクターに渡されます、としてコンストラクターの中から、インスタンスにアクセスできる`this`します。

#### <a name="object-initializers"></a>オブジェクト初期化子

***オブジェクト初期化子***フィールド、プロパティまたはオブジェクトのインデックス付きの要素の 0 個以上の値を指定します。

```antlr
object_initializer
    : '{' member_initializer_list? '}'
    | '{' member_initializer_list ',' '}'
    ;

member_initializer_list
    : member_initializer (',' member_initializer)*
    ;

member_initializer
    : initializer_target '=' initializer_value
    ;

initializer_target
    : identifier
    | '[' argument_list ']'
    ;

initializer_value
    : expression
    | object_or_collection_initializer
    ;
```

オブジェクト初期化子で囲まれた、メンバー初期化子のシーケンスから成る`{`と`}`トークンし、コンマで区切られました。 各*member_initializer*初期化するためのターゲットを指定します。 *識別子*一方、アクセス可能なフィールドまたはプロパティが初期化されているオブジェクトの名前、 *argument_list*で囲む角かっこでアクセス可能なインデクサーの引数を指定する必要があります、初期化されるオブジェクト。 オブジェクト初期化子を同じフィールドまたはプロパティの 1 つ以上のメンバー初期化子を含めるとエラーになります。

各*initializer_target*等号と式、オブジェクト初期化子またはコレクション初期化子を続けています。 新しく作成されたオブジェクトが初期化を参照するオブジェクト初期化子内の式のことはできません。

割り当てと同じ方法で、等号が処理された後に式を指定するメンバーの初期化子 ([単純な代入](expressions.md#simple-assignment)) をターゲットにします。

等号の後に、オブジェクト初期化子を指定するメンバーの初期化子、***入れ子になったオブジェクトの初期化子***、つまり、埋め込みオブジェクトの初期化。 フィールドまたはプロパティに新しい値を割り当てる代わりに、入れ子になったオブジェクト初期化子の割り当ては、フィールドまたはプロパティのメンバーへの割り当てとして扱われます。 入れ子になったオブジェクト初期化子は、値の型を持つプロパティ、または値型を持つ読み取り専用のフィールドに適用できません。

等号の後に、コレクション初期化子を指定するメンバーの初期化子は、コレクションが埋め込まれたの初期化です。 新しいコレクションを対象のフィールド、プロパティまたはインデクサーに割り当てる代わりに、初期化子で指定された要素は、ターゲットによって参照されるコレクションに追加されます。 コレクション型で指定された要件を満たす必要がありますの対象に[コレクション初期化子](expressions.md#collection-initializers)します。

インデックス初期化子の引数は、1 回だけ常に評価されます。 したがって、引数は、(例: 空の入れ子になった初期化子) により使用される作業終了、場合でもは、副作用が評価されます。

次のクラスは、2 つの座標の点を表します。
```csharp
public class Point
{
    int x, y;

    public int X { get { return x; } set { x = value; } }
    public int Y { get { return y; } set { y = value; } }
}
```

インスタンス`Point`作成および初期化を次のようにできます。
```csharp
Point a = new Point { X = 0, Y = 1 };
```
同じ効果があります。
```csharp
Point __a = new Point();
__a.X = 0;
__a.Y = 1; 
Point a = __a;
```
場所`__a`一時変数で、それ以外の場合に非表示とアクセスできません。 次のクラスは、2 つの点から作成された四角形を表します。
```csharp
public class Rectangle
{
    Point p1, p2;

    public Point P1 { get { return p1; } set { p1 = value; } }
    public Point P2 { get { return p2; } set { p2 = value; } }
}
```

インスタンス`Rectangle`作成および初期化を次のようにできます。
```csharp
Rectangle r = new Rectangle {
    P1 = new Point { X = 0, Y = 1 },
    P2 = new Point { X = 2, Y = 3 }
};
```
同じ効果があります。
```csharp
Rectangle __r = new Rectangle();
Point __p1 = new Point();
__p1.X = 0;
__p1.Y = 1;
__r.P1 = __p1;
Point __p2 = new Point();
__p2.X = 2;
__p2.Y = 3;
__r.P2 = __p2; 
Rectangle r = __r;
```
場所`__r`、`__p1`と`__p2`一時変数アクセス、それ以外の場合です。

場合`Rectangle`のコンストラクターでは、2 つが埋め込まれた`Point`インスタンス
```csharp
public class Rectangle
{
    Point p1 = new Point();
    Point p2 = new Point();

    public Point P1 { get { return p1; } }
    public Point P2 { get { return p2; } }
}
```
次の構成体は、埋め込みの初期化に使用できる`Point`の新しいインスタンスを割り当てる代わりにインスタンス。
```csharp
Rectangle r = new Rectangle {
    P1 = { X = 0, Y = 1 },
    P2 = { X = 2, Y = 3 }
};
```
同じ効果があります。
```csharp
Rectangle __r = new Rectangle();
__r.P1.X = 0;
__r.P1.Y = 1;
__r.P2.X = 2;
__r.P2.Y = 3;
Rectangle r = __r;
```

C では、次の例では、の適切な定義を指定します。
```csharp
var c = new C {
    x = true,
    y = { a = "Hello" },
    z = { 1, 2, 3 },
    ["x"] = 5,
    [0,0] = { "a", "b" },
    [1,2] = {}
};
```
この一連の割り当てと同等です。
```csharp
C __c = new C();
__c.x = true;
__c.y.a = "Hello";
__c.z.Add(1); 
__c.z.Add(2);
__c.z.Add(3);
string __i1 = "x";
__c[__i1] = 5;
int __i2 = 0, __i3 = 0;
__c[__i2,__i3].Add("a");
__c[__i2,__i3].Add("b");
int __i4 = 1, __i5 = 2;
var c = __c;
```
場所`__c`など、生成された変数は非表示と、ソース コードにアクセスできないです。 なお、引数の`[0,0]`は 1 回だけ評価、および引数を`[1,2]`使用されない場合でも、1 回評価されます。

#### <a name="collection-initializers"></a>コレクション初期化子

コレクション初期化子では、コレクションの要素を指定します。

```antlr
collection_initializer
    : '{' element_initializer_list '}'
    | '{' element_initializer_list ',' '}'
    ;

element_initializer_list
    : element_initializer (',' element_initializer)*
    ;

element_initializer
    : non_assignment_expression
    | '{' expression_list '}'
    ;

expression_list
    : expression (',' expression)*
    ;
```

コレクション初期化子で囲まれた、要素の初期化子のシーケンスから成る`{`と`}`トークンし、コンマで区切られました。 各要素の初期化子の初期化中にコレクション オブジェクトに追加する要素を指定およびで囲まれた式の一覧から成る`{`と`}`トークンし、コンマで区切られました。  1 つの式の要素の初期化子は、中かっこなしで記述できますが、メンバー初期化子とあいまいさを避けるために、代入式にすることはできませんし。 *Non_assignment_expression*で定義されている運用[式](expressions.md#expression)します。

コレクション初期化子を含むオブジェクト作成式の例を次に示します。
```csharp
List<int> digits = new List<int> { 0, 1, 2, 3, 4, 5, 6, 7, 8, 9 };
```

実装する型のコレクション オブジェクトをコレクション初期化子を適用する必要があります`System.Collections.IEnumerable`コンパイル時エラーが発生します。 コレクション初期化子を呼び出す順序で要素を指定された各、`Add`ターゲット上のメソッドは、引数のリストを使用して、通常のメンバーの参照を適用する要素初期化子の式のリストを持つオブジェクトし、オーバー ロードの呼び出しごとの解決。 そのため、コレクション オブジェクトが、名前の該当するインスタンスまたは拡張メソッドをいる必要があります`Add`の各要素の初期化子。

次のクラスは、名前と電話番号のリストで連絡先を表します。
```csharp
public class Contact
{
    string name;
    List<string> phoneNumbers = new List<string>();

    public string Name { get { return name; } set { name = value; } }

    public List<string> PhoneNumbers { get { return phoneNumbers; } }
}
```

A`List<Contact>`作成および初期化を次のようにできます。
```csharp
var contacts = new List<Contact> {
    new Contact {
        Name = "Chris Smith",
        PhoneNumbers = { "206-555-0101", "425-882-8080" }
    },
    new Contact {
        Name = "Bob Harris",
        PhoneNumbers = { "650-555-0199" }
    }
};
```
同じ効果があります。
```csharp
var __clist = new List<Contact>();
Contact __c1 = new Contact();
__c1.Name = "Chris Smith";
__c1.PhoneNumbers.Add("206-555-0101");
__c1.PhoneNumbers.Add("425-882-8080");
__clist.Add(__c1);
Contact __c2 = new Contact();
__c2.Name = "Bob Harris";
__c2.PhoneNumbers.Add("650-555-0199");
__clist.Add(__c2);
var contacts = __clist;
```
場所`__clist`、`__c1`と`__c2`一時変数アクセス、それ以外の場合です。

#### <a name="array-creation-expressions"></a>配列作成式

*Array_creation_expression*の新しいインスタンスを作成するために使用する*array_type*します。

```antlr
array_creation_expression
    : 'new' non_array_type '[' expression_list ']' rank_specifier* array_initializer?
    | 'new' array_type array_initializer
    | 'new' rank_specifier array_initializer
    ;
```

最初の形式の配列作成式では、それぞれの個別の式を式の一覧から削除した結果の型の配列インスタンスを割り当てます。 配列作成式ではたとえば、`new int[10,20]`型の配列インスタンスの生成`int[,]`と、配列作成式`new int[10][,]`型の配列が生成される`int[][,]`。 式のリスト内の各式は型でなければなりません`int`、 `uint`、 `long`、または`ulong`、または 1 つ以上のこれらの型に暗黙的に変換します。 各式の値は、新しく割り当てられた配列のインスタンスに対応する次元の長さを決定します。 コンパイル時エラーには、配列の次元の長さは 0 以上である必要があります、ため、 *constant_expression*負の値式の一覧。

Unsafe コンテキストでは可 ([Unsafe コンテキスト](unsafe-code.md#unsafe-contexts))、配列のレイアウトは指定されていません。

配列作成式最初のフォームにはには、配列初期化子が含まれている場合は、式のリスト内の各式は定数である必要があり、配列初期化子の式のリストで指定されたランクと次元の長さが一致する必要があります。

2 番目または 3 番目のフォームの配列作成式で配列初期化子を指定した配列の型、ランク付けの指定子のランクが一致する必要があります。 各次元の長さは、配列初期化子の対応する入れ子のレベルの各要素の数から推論されます。 したがって、式
```csharp
new int[,] {{0, 1}, {2, 3}, {4, 5}}
```
正確に対応しています
```csharp
new int[3, 2] {{0, 1}, {2, 3}, {4, 5}}
```

3 番目の形式の配列作成式として参照されます、***配列作成式を暗黙的に型指定された***します。 配列の要素の型が明示的に指定されていないが、最も一般的な種類として決定する点を除いて、2 番目の形式に似ています ([一連の式の最適な一般的な種類を検索する](expressions.md#finding-the-best-common-type-of-a-set-of-expressions)) の配列内の式のセット初期化子。 、多次元配列の 1 つの場所など、 *rank_specifier*に少なくとも 1 つのコンマを含んでいますこのセットはすべてで構成されます*式*s がで検出された入れ子になった*array_initializer*秒。

配列初期化子の詳細については[配列初期化子](arrays.md#array-initializers)します。

配列作成式の評価結果は、新しく割り当てられた配列インスタンスへの参照を namely の値として分類されます。 配列作成式の実行時の処理は、次の手順で構成されます。

*  ディメンションの長さの式、 *expression_list*左から右への順序で評価されます。 暗黙的な変換をそれぞれの式の評価に従って ([暗黙的な変換](conversions.md#implicit-conversions))、次の種類のいずれかに実行されます: `int`、 `uint`、 `long`、`ulong`します。 暗黙的な変換が存在するこのリストの最初の型が選択されます。 式またはそれ以降の暗黙的な変換の評価は、例外を発生させ場合、は、それ以上の式は評価されませんしさらに手順は実行されません。
*  次元の長さの計算値は、次のように検証されます。 1 つ以上の値は 0 より小さい場合、`System.OverflowException`がスローされます、以降の手順は実行されません。
*  指定した次元の長さを持つ配列インスタンスが割り当てられます。 新しいインスタンスを割り当てることができる十分なメモリがない場合、`System.OutOfMemoryException`がスローされます、以降の手順は実行されません。
*  新しい配列インスタンスのすべての要素は、既定値に初期化されます ([既定値](variables.md#default-values))。
*  配列作成式に配列初期化子が含まれている場合、配列初期化子内の各式が評価され、配列の対応する要素に割り当てられています。 評価と割り当てが、式が配列初期化子で記述された順序で実行、つまり、要素が昇順に最初に増やすと、右端の次元でインデックス順に初期化されます。 指定された式または対応する配列要素への割り当てを後続の評価は、例外を発生させ場合、残りの要素が初期化されていません (し、残りの要素が既定値がそのため)。

配列作成式が配列型の要素の配列をインスタンス化を許可しますが、このような配列の要素を手動で初期化する必要があります。 たとえば、ステートメント
```csharp
int[][] a = new int[100][];
```
型の 100 個の要素を持つ 1 次元配列を作成`int[]`です。 各要素の初期値は`null`します。 サブ配列、およびステートメントのインスタンス化も同じ配列作成式のことはできません。
```csharp
int[][] a = new int[100][5];        // Error
```
コンパイル時エラーが発生します。 サブ配列のインスタンス化は、手動で代わりに実行する必要があります。
```csharp
int[][] a = new int[100][];
for (int i = 0; i < 100; i++) a[i] = new int[5];
```

配列の配列に、サブ配列は、すべて同じ長さの場合は、「四角形」図形がある場合は、多次元配列を使用する方が効率的です。 上記の例では、配列の配列のインスタンス化が 101 個のオブジェクトを作成します。-外側の配列が 1 つと 100 のサブ配列。 それに対して
```csharp
int[,] = new int[100, 5];
```
のみ、1 つのオブジェクト、2 次元の配列を作成し、単一のステートメントで割り当てを行うこと。

暗黙的に型指定された配列作成式の例を次に示します。
```csharp
var a = new[] { 1, 10, 100, 1000 };                       // int[]

var b = new[] { 1, 1.5, 2, 2.5 };                         // double[]

var c = new[,] { { "hello", null }, { "world", "!" } };   // string[,]

var d = new[] { 1, "one", 2, "two" };                     // Error
```

最後の式がコンパイル時エラーを発生も`int`も`string`、他の暗黙的に変換できるし、入力はない最も一般的な存在です。 明示的に型指定された配列作成式に必要ここでは、たとえば、型を指定する`object[]`します。 または、要素のいずれかに共通の基本型が推論される要素の型になりますし、キャストできます。

暗黙的に型指定された配列作成式は、匿名オブジェクト初期化子と組み合わせることができます ([匿名オブジェクト作成式](expressions.md#anonymous-object-creation-expressions)) 匿名で作成するデータ構造を入力します。 例:
```csharp
var contacts = new[] {
    new {
        Name = "Chris Smith",
        PhoneNumbers = new[] { "206-555-0101", "425-882-8080" }
    },
    new {
        Name = "Bob Harris",
        PhoneNumbers = new[] { "650-555-0199" }
    }
};
```

#### <a name="delegate-creation-expressions"></a>デリゲート作成式

A *delegate_creation_expression*の新しいインスタンスを作成するために使用する*delegate_type*します。

```antlr
delegate_creation_expression
    : 'new' delegate_type '(' expression ')'
    ;
```

デリゲート作成式の引数が、メソッド グループ、匿名関数またはコンパイル時の型の値にする必要があります`dynamic`または*delegate_type*します。 引数が、メソッド グループである場合は、識別し、インスタンス メソッド、デリゲートを作成する対象のオブジェクト。 引数が匿名関数の場合、パラメーターと、デリゲート ターゲットのメソッド本体が直接定義します。 引数が値の場合、コピーを作成するためのデリゲート インスタンスを識別します。

場合、*式*コンパイル時の型を持つ`dynamic`、 *delegate_creation_expression*が動的にバインドされている ([動的バインド](expressions.md#dynamic-binding))、および次の規則実行時の型を使用して実行時に適用されます、*式*します。 それ以外の場合、ルールは、コンパイル時に適用されます。

バインド時の処理、 *delegate_creation_expression*フォームの`new D(E)`ここで、`D`は、 *delegate_type*と`E`は、*式*、次の手順で構成されます。

*  場合`E`はメソッド グループでは、デリゲート作成式はメソッド グループ変換と同じ方法で処理 ([メソッド グループ変換](conversions.md#method-group-conversions)) から`E`に`D`します。
*  場合`E`、匿名関数は、匿名関数の変換と同じ方法でデリゲート作成式が処理される ([匿名関数の変換](conversions.md#anonymous-function-conversions)) から`E`に`D`します。
*  場合`E`、値は、`E`互換である必要があります ([デリゲートの宣言](delegates.md#delegate-declarations)) と`D`、され、結果は新しく作成された型のデリゲートへの参照を`D`同じ呼び出しを参照ボックスの一覧として`E`します。 場合`E`と互換性がない`D`コンパイル時エラーが発生します。

実行時の処理、 *delegate_creation_expression*フォームの`new D(E)`ここで、`D`は、 *delegate_type*と`E`は、*式*、次の手順で構成されます。

*   場合`E`はメソッド グループでは、メソッド グループ変換としてデリゲート作成式が評価されます ([メソッド グループ変換](conversions.md#method-group-conversions)) から`E`に`D`します。
*   場合`E`、匿名関数は、デリゲートの作成は、匿名関数の変換からとして評価されます。`E`に`D`([匿名関数の変換](conversions.md#anonymous-function-conversions))。
*   場合`E`の値であり、 *delegate_type*:
    * `E` 評価されます。 この評価は、例外を発生させ、その後の手順は実行されません。
    * 場合の値`E`は`null`、`System.NullReferenceException`がスローされます、以降の手順は実行されません。
    * デリゲート型の新しいインスタンス`D`が割り当てられます。 新しいインスタンスを割り当てることができる十分なメモリがない場合、`System.OutOfMemoryException`がスローされます、以降の手順は実行されません。
    * 指定されたデリゲート インスタンスと同じ呼び出しリストを持つ新しいデリゲート インスタンスが初期化されて`E`します。

デリゲートがインスタンス化され、デリゲートの有効期間にわたって一定時に、デリゲートの呼び出しリストが決まります。 つまりが作成されたら、デリゲートの呼び出し可能なターゲット エンティティを変更することはできません。 ときに 2 つのデリゲートを組み合わせるか、別の 1 つが削除された ([デリゲートの宣言](delegates.md#delegate-declarations))、新しいデリゲートの結果は、既存のデリゲートには、その内容が変更はありません。

場合によっては、プロパティ、インデクサー、ユーザー定義演算子、インスタンス コンストラクター、デストラクター、または静的コンストラクターを参照するデリゲートを作成することはできません。

前述のように、デリゲートがから作成するとき、メソッド グループ、仮パラメーター リストと、デリゲートの戻り値の型を特定のオーバー ロードされたメソッドを選択します。 例
```csharp
delegate double DoubleFunc(double x);

class A
{
    DoubleFunc f = new DoubleFunc(Square);

    static float Square(float x) {
        return x * x;
    }

    static double Square(double x) {
        return x * x;
    }
}
```
`A.f`フィールドは、2 つ目を参照するデリゲートを使用して初期化`Square`メソッド メソッドは、仮パラメーター リストおよび戻り値の型に正確に一致するため、`DoubleFunc`します。 2 つ目が`Square`メソッドが存在していない、コンパイル時エラーが発生します。

#### <a name="anonymous-object-creation-expressions"></a>匿名のオブジェクト作成式

*Anonymous_object_creation_expression*匿名型のオブジェクトを作成するために使用します。

```antlr
anonymous_object_creation_expression
    : 'new' anonymous_object_initializer
    ;

anonymous_object_initializer
    : '{' member_declarator_list? '}'
    | '{' member_declarator_list ',' '}'
    ;

member_declarator_list
    : member_declarator (',' member_declarator)*
    ;

member_declarator
    : simple_name
    | member_access
    | base_access
    | null_conditional_member_access
    | identifier '=' expression
    ;
```

匿名オブジェクト初期化子は、匿名型を宣言し、その型のインスタンスを返します。 匿名型は、名前のないクラス型から直接継承される`object`します。 匿名型のメンバーは、一連の型のインスタンスを作成するために使用する匿名オブジェクト初期化子から推論される読み取り専用プロパティです。 フォームの匿名オブジェクト初期化子具体的には、
```csharp
new { p1 = e1, p2 = e2, ..., pn = en }
```
フォームの匿名型を宣言します。
```csharp
class __Anonymous1
{
    private readonly T1 f1;
    private readonly T2 f2;
    ...
    private readonly Tn fn;

    public __Anonymous1(T1 a1, T2 a2, ..., Tn an) {
        f1 = a1;
        f2 = a2;
        ...
        fn = an;
    }

    public T1 p1 { get { return f1; } }
    public T2 p2 { get { return f2; } }
    ...
    public Tn pn { get { return fn; } }

    public override bool Equals(object __o) { ... }
    public override int GetHashCode() { ... }
}
```
各`Tx`対応する式の型は、`ex`します。 使用される式を*member_declarator*型である必要があります。 したがって、式のコンパイル時エラーが、 *member_declarator*を null または匿名関数です。 安全でない型を持つ式のコンパイル時エラーです。

匿名型のパラメーターの名前、`Equals`メソッドは、コンパイラによって自動的に生成され、プログラム テキストでは参照できません。

同じ順序で一連のコンパイル時の型と同じ名前のプロパティを指定する 2 つの匿名オブジェクト初期化子では、同じプログラム内で、同じ匿名型のインスタンスが生成されます。

例
```csharp
var p1 = new { Name = "Lawnmower", Price = 495.00 };
var p2 = new { Name = "Shovel", Price = 26.95 };
p1 = p2;
```
ため、最後の行で割り当てが許可`p1`と`p2`が同じ匿名型。

`Equals`と`GetHashcode`匿名型のメソッドから継承されたメソッドをオーバーライド`object`の観点で定義されていると、`Equals`と`GetHashcode`プロパティの同じ匿名型の 2 つのインスタンスが等しくないように場合そのすべてのプロパティが等しい場合のみです。

メンバー宣言子は、簡易名を省略できます ([型推論](expressions.md#type-inference))、メンバー アクセス ([コンパイル時の動的なオーバー ロードの解決の確認](expressions.md#compile-time-checking-of-dynamic-overload-resolution))、ベース アクセス ([へのアクセスの基本](expressions.md#base-access))または、null 条件メンバー アクセス ([プロジェクション初期化子として Null 条件式](expressions.md#null-conditional-expressions-as-projection-initializers))。 これと呼ばれますが、***プロジェクション初期化子***の宣言と同じ名前のプロパティへの代入を短縮したものとします。 具体的には、フォームのメンバー宣言の子
```csharp
identifier
expr.identifier
```
それぞれ、次に、まったく同じです。
```csharp
identifier = identifier
identifier = expr.identifier
```

そのため、プロジェクション初期化子で、*識別子*値とフィールドまたは値が割り当てられているプロパティを選択します。 直感的には、プロジェクション初期化子は、値だけでなく、値の名前を射影します。

### <a name="the-typeof-operator"></a>Typeof 演算子

`typeof`演算子を使用して、取得、`System.Type`型のオブジェクト。

```antlr
typeof_expression
    : 'typeof' '(' type ')'
    | 'typeof' '(' unbound_type_name ')'
    | 'typeof' '(' 'void' ')'
    ;

unbound_type_name
    : identifier generic_dimension_specifier?
    | identifier '::' identifier generic_dimension_specifier?
    | unbound_type_name '.' identifier generic_dimension_specifier?
    ;

generic_dimension_specifier
    : '<' comma* '>'
    ;

comma
    : ','
    ;
```

最初のフォーム*typeof_expression*から成る、`typeof`キーワードの後に、かっこで囲まれた*型*します。 この形式の式の結果は、`System.Type`示された型のオブジェクト。 1 つしかない`System.Type`指定された型のオブジェクト。 これにより、型の `T`、`typeof(T) == typeof(T)`は常に true です。 *型*することはできません`dynamic`します。

2 番目の形式の*typeof_expression*から成る、`typeof`キーワードの後に、かっこで囲まれた*unbound_type_name*します。 *Unbound_type_name*とよく似ていますが、 *type_name* ([Namespace と型の名前](basic-concepts.md#namespace-and-type-names)) ことを除いて、 *unbound_type_name*が含まれています*generic_dimension_specifier*s を*type_name*が含まれています*type_argument_list*秒。 ときのオペランドを*typeof_expression*を両方の文法を満たす一連のトークンは、 *unbound_type_name*と*type_name*、つまりそれが含まれる場合どちらも、 *generic_dimension_specifier*も*type_argument_list*、トークンのシーケンスがあると見なされます、 *type_name*します。 意味、 *unbound_type_name*は次のように決定されます。

*  トークンのシーケンスに変換を*type_name*それぞれを置き換えることで、 *generic_dimension_specifier*で、 *type_argument_list*ことと同じ数のコンマとキーワード`object`として各*type_argument*します。
*  結果を評価*type_name*、中に、すべての型パラメーターの制約は無視されます。
*  *Unbound_type_name*構築された型に関連付けられているバインドされていないジェネリック型に解決される ([バインドされ、型がバインドされていない](types.md#bound-and-unbound-types))。

結果、 *typeof_expression*は、`System.Type`オブジェクトのジェネリック型がバインドされていない結果します。

3 番目の形式*typeof_expression*から成る、`typeof`キーワードの後に、かっこで囲まれた`void`キーワード。 この形式の式の結果は、`System.Type`がない場合、型を表すオブジェクト。 によって返される型オブジェクト`typeof(void)`任意の型に対して返される型のオブジェクトとは異なります。 この特別な種類のオブジェクトは、言語では、メソッドにリフレクションを使用できるようにするのインスタンスとの void メソッドを含む、任意のメソッドの戻り値の型を表す方法があるクラス ライブラリで役立ちます`System.Type`します。

`typeof`演算子は、型パラメーターで使用できます。 結果は、`System.Type`型パラメーターにバインドされていた、実行時の型のオブジェクト。 `typeof`演算子は、構築された型またはバインドされていないジェネリック型でも使用できます ([バインドされ、型がバインドされていない](types.md#bound-and-unbound-types))。 `System.Type` 、バインドされていないジェネリック型が同じオブジェクト、`System.Type`インスタンス型のオブジェクト。 インスタンスの型は常に実行時に構築されたクローズ型ためその`System.Type`オブジェクトは、バインドされていないジェネリック型に型引数があるないときに使用して、実行時の型引数に依存します。

例では、
```csharp
using System;

class X<T>
{
    public static void PrintTypes() {
        Type[] t = {
            typeof(int),
            typeof(System.Int32),
            typeof(string),
            typeof(double[]),
            typeof(void),
            typeof(T),
            typeof(X<T>),
            typeof(X<X<T>>),
            typeof(X<>)
        };
        for (int i = 0; i < t.Length; i++) {
            Console.WriteLine(t[i]);
        }
    }
}

class Test
{
    static void Main() {
        X<int>.PrintTypes();
    }
}
```
次の出力が生成されます。
```
System.Int32
System.Int32
System.String
System.Double[]
System.Void
System.Int32
X`1[System.Int32]
X`1[X`1[System.Int32]]
X`1[T]
```

なお`int`と`System.Int32`は同じ型。

また、結果の`typeof(X<>)`型引数がの結果に依存しません`typeof(X<T>)`は。

### <a name="the-checked-and-unchecked-operators"></a>Checked と unchecked 演算子

`checked`と`unchecked`演算子を使用してコントロールを***オーバーフロー チェック コンテキスト***整数型の算術演算と変換します。

```antlr
checked_expression
    : 'checked' '(' expression ')'
    ;

unchecked_expression
    : 'unchecked' '(' expression ')'
    ;
```

`checked`演算子が checked コンテキストで含まれている式を評価し、`unchecked`演算子が unchecked コンテキストで含まれている式を評価します。 A *checked_expression*または*unchecked_expression*に対応して、 *parenthesized_expression* ([のかっこで囲まれた式](expressions.md#parenthesized-expressions)) が含まれている式は、特定のオーバーフロー チェック コンテキストで評価されます。

オーバーフロー チェック コンテキストを制御することも、`checked`と`unchecked`ステートメント ([checked と unchecked ステートメント](statements.md#the-checked-and-unchecked-statements))。

オーバーフロー チェック コンテキストを確立して、次の操作が影響を受ける、`checked`と`unchecked`演算子およびステートメント。

*  定義済み`++`と`--`単項演算子 ([置インクリメント演算子と前置デクリメント演算子](expressions.md#postfix-increment-and-decrement-operators)と[前置インクリメントとデクリメント演算子](expressions.md#prefix-increment-and-decrement-operators)) オペランドが整数の場合、入力します。
*  定義済み`-`単項演算子 ([単項マイナス演算子](expressions.md#unary-minus-operator))、整数型のオペランドがある場合。
*  定義済み`+`、 `-`、 `*`、および`/`二項演算子 ([算術演算子](expressions.md#arithmetic-operators))、両方のオペランドが整数型の場合。
*  明示的な数値変換 ([明示的な数値変換](conversions.md#explicit-numeric-conversions)) もう 1 つの整数型との間に 1 つの整数型から`float`または`double`を整数型。

大きすぎて、変換先の型、操作が実行されるコントロールでありコンテキストの結果の動作を表すである結果を生成、上述の操作のいずれかの場合。

*  `checked`コンテキスト、操作が定数式である場合 ([定数式](expressions.md#constant-expressions))、コンパイル時エラーが発生します。 それ以外の場合、実行時に、操作が実行されると、`System.OverflowException`がスローされます。
*  `unchecked`コンテキスト、結果は変換先の型に収まらない上位ビットが破棄されてによって切り捨てられます。

非定数式 (実行時に評価される式) のいずれかで囲まれていない`checked`または`unchecked`演算子またはステートメントでは、既定のオーバーフロー チェック コンテキストは、 `unchecked` (コンパイラなどの外部要因しない限り、スイッチと実行環境の構成) の呼び出しの`checked`評価します。

定数式 (コンパイル時に完全に評価される式)、既定のオーバーフロー チェック コンテキストは常に`checked`します。 定数式を明示的に配置しない限り、`unchecked`コンテキストでは、常に式のコンパイル時の評価中に発生するオーバーフローにコンパイル時エラーが発生します。

匿名関数の本体は受けません`checked`または`unchecked`匿名関数が発生するコンテキスト。

例
```csharp
class Test
{
    static readonly int x = 1000000;
    static readonly int y = 1000000;

    static int F() {
        return checked(x * y);      // Throws OverflowException
    }

    static int G() {
        return unchecked(x * y);    // Returns -727379968
    }

    static int H() {
        return x * y;               // Depends on default
    }
}
```
コンパイル時に評価される式のどちらでもないために、コンパイル時エラーは報告されません。 実行時、`F`メソッドがスローされます、 `System.OverflowException`、および`G`-727379968 (範囲外の結果の下位 32 ビット) を返します。 動作、`H`メソッドは、既定のオーバーフロー チェック コンテキストをコンパイル時にによって異なりますが、これと同じであるか`F`または同じ`G`します。

例
```csharp
class Test
{
    const int x = 1000000;
    const int y = 1000000;

    static int F() {
        return checked(x * y);      // Compile error, overflow
    }

    static int G() {
        return unchecked(x * y);    // Returns -727379968
    }

    static int H() {
        return x * y;               // Compile error, overflow
    }
}
```
内の定数式を評価するときに発生するオーバーフロー`F`と`H`で式を評価するために報告されることをコンパイル時エラーが発生する、`checked`コンテキスト。 定数式を評価するときにも、オーバーフローが発生`G`評価が行われるので、`unchecked`コンテキスト、オーバーフローが報告されません。

`checked`と`unchecked`演算子、オーバーフロー チェック コンテキスト内でテキストに含まれるこれらの操作の影響を受けるのみ、"`(`「と」`)`"トークンです。 演算子は、式を評価した結果として呼び出される関数メンバーに影響を与えるありません。 例
```csharp
class Test
{
    static int Multiply(int x, int y) {
        return x * y;
    }

    static int F() {
        return checked(Multiply(1000000, 1000000));
    }
}
```
使用`checked`で`F`の評価には影響しません`x * y`で`Multiply`ため、`x * y`は既定のオーバーフロー チェック コンテキストで評価されます。

`unchecked`演算子は、16 進数表記で符号付き整数型の定数を記述するときに便利です。 例:
```csharp
class Test
{
    public const int AllBits = unchecked((int)0xFFFFFFFF);

    public const int HighBit = unchecked((int)0x80000000);
}
```

上記の 16 進定数の両方が型の`uint`します。 定数に含まれないため、`int`せず、範囲、`unchecked`演算子、キャストを`int`コンパイル時エラーが生成されます。

`checked`と`unchecked`演算子とステートメントは、数値計算をいくつかの特定の側面を制御するプログラマを許可します。 ただし、一部の数値演算子の動作は、そのオペランドのデータ型によって異なります。 たとえば、小数点以下 2 桁を常に乗算することで例外が発生オーバーフロー内でも、明示的に`unchecked`を構築します。 同様に、2 つの乗算フローティング状態になったことはありません結果オーバーフロー例外は発生内でも、明示的に`checked`を構築します。 さらに、その他の演算子はチェックのモードで影響しない、既定のかどうか、または明示的な。

### <a name="default-value-expressions"></a>既定値の式

既定値の式は、既定値を取得するために使用 ([既定値](variables.md#default-values)) の型。 通常、可能性がありますが認識されていない場合は、型パラメーターが値型または参照型であるため、型パラメーターの既定値の式が使用されます。 (から変換が存在しない、`null`型パラメーターが参照型とわかっている場合を除き、型パラメーターにリテラルです)。

```antlr
default_value_expression
    : 'default' '(' type ')'
    ;
```

場合、*型*で、 *default_value_expression*評価参照型には、実行時に、結果が`null`その型に変換します。 場合、*型*で、 *default_value_expression*評価値の型には、実行時に、結果が、 *value_type*の既定値 ([既定コンストラクター](types.md#default-constructors))。

A *default_value_expression*定数式です ([定数式](expressions.md#constant-expressions)) 場合は、型が参照型または参照型があることがわかっている型パラメーター ([型パラメーター制約](classes.md#type-parameter-constraints))。 さらに、 *default_value_expression*定数式は、型は、次の値の型のいずれかの場合: `sbyte`、 `byte`、 `short`、 `ushort`、 `int`、 `uint`、`long`、 `ulong`、 `char`、 `float`、 `double`、 `decimal`、 `bool`、または列挙型。


### <a name="nameof-expressions"></a>Nameof 式

A *nameof_expression*文字列定数としてプログラム エンティティの名前を取得するために使用します。

```antlr
nameof_expression
    : 'nameof' '(' named_entity ')'
    ;

named_entity
    : simple_name
    | named_entity_target '.' identifier type_argument_list?
    ;

named_entity_target
    : 'this'
    | 'base'
    | named_entity 
    | predefined_type 
    | qualified_alias_member
    ;
```

文法的に言うと、 *named_entity*オペランドが式では常にします。 `nameof`は予約済みキーワードの場合は、nameof 式は、簡易名の呼び出しで構文的にあいまいな常に`nameof`します。 互換性の理由から、名の参照の場合 ([簡易名](expressions.md#simple-names)) 名の`nameof`成功すると、式として扱われます、 *invocation_expression*呼び出しは、かどうかに関係なく--法律です。 それ以外の場合は、 *nameof_expression*します。

意味、 *named_entity*の*nameof_expression*ことの意味を式としては、いずれかとして、 *simple_name*、 *base_access*または*member_access*します。 ただし、場所、ルックアップで説明されている[簡易名](expressions.md#simple-names)と[メンバー アクセス](expressions.md#member-access)静的においては、インスタンス メンバーが見つかったため、エラーが発生、 *nameof_expression*このようなエラーを生成しません。

コンパイル時エラーには、 *named_entity*が、メソッド グループを指定する、 *type_argument_list*します。 コンパイル時間のエラーには、 *named_entity_target*に、型を持つ`dynamic`します。

A *nameof_expression*型の定数式は、 `string`、実行時に影響しません。 具体的には、その*named_entity*は評価されず、および限定代入分析の目的では無視されます ([単純式での一般的な規則](variables.md#general-rules-for-simple-expressions))。 その値の最後の識別子では、 *named_entity* 、省略可能な最後の前に*type_argument_list*、次のように変換されました。

* プレフィックス"`@`"を使用する場合は、削除されます。
* 各*unicode_escape_sequence*対応する Unicode 文字に変換されます。
* すべて*formatting_characters*が削除されます。

これらは、同じ変換の適用[識別子](lexical-structure.md#identifiers)識別子の間に等しいかどうかをテストするときにします。

TODO: 例

### <a name="anonymous-method-expressions"></a>匿名メソッド式

*Anonymous_method_expression*匿名関数を定義する 2 つの方法の 1 つです。 さらに詳細は[匿名関数式](expressions.md#anonymous-function-expressions)します。

## <a name="unary-operators"></a>単項演算子

`?`、 `+`、 `-`、 `!`、 `~`、 `++`、`--`キャスト、および`await`演算子は、単項演算子と呼ばれます。

```antlr
unary_expression
    : primary_expression
    | null_conditional_expression
    | '+' unary_expression
    | '-' unary_expression
    | '!' unary_expression
    | '~' unary_expression
    | pre_increment_expression
    | pre_decrement_expression
    | cast_expression
    | await_expression
    | unary_expression_unsafe
    ;
```

場合のオペランドを*unary_expression*コンパイル時の型を持つ`dynamic`、動的にバインドされている ([動的バインド](expressions.md#dynamic-binding))。 この場合、コンパイル時はの入力、 *unary_expression*は`dynamic`、オペランドの実行時の型を使用して実行時に以下に示す解決が行わします。

### <a name="null-conditional-operator"></a>Null 条件演算子

Null 条件演算子では、そのオペランドが null でない場合にのみに、操作の一覧が、オペランドに適用されます。 それ以外の場合は、演算子を適用した結果、`null`します。

```antlr
null_conditional_expression
    : primary_expression null_conditional_operations
    ;

null_conditional_operations
    : null_conditional_operations? '?' '.' identifier type_argument_list?
    | null_conditional_operations? '?' '[' argument_list ']'
    | null_conditional_operations '.' identifier type_argument_list?
    | null_conditional_operations '[' argument_list ']'
    | null_conditional_operations '(' argument_list? ')'
    ;
```

操作の一覧には、メンバー アクセスと要素アクセス操作 (これは、null 条件自体である可能性があります)、だけでなく、呼び出しを含めることができます。

たとえば、式`a.b?[0]?.c()`は、 *null_conditional_expression*で、 *primary_expression* `a.b`と*null_conditional_operations* `?[0]` (要素の null 条件付きアクセス)、 `?.c` (null 条件メンバー アクセス) および`()`(呼び出し)。

*Null_conditional_expression* `E`で、 *primary_expression* `P`、`E0`ヘッダーファイル リード削除することで取得した式を指定する`?`のそれぞれから、 *null_conditional_operations*の`E`がある 1 つ。 概念的には、`E0`によって表される null チェックの場合に評価される式です、 `?`s は検索、`null`します。

を描く遷移`E1`ヘッダーファイル先頭削除することで取得した式を指定する`?`のみからの最初、 *null_conditional_operations*で`E`します。 これが生じる、*プライマリ式*(1 つだけを使用する必要がある場合`?`) または別*null_conditional_expression*します。

たとえば場合、`E`式です`a.b?[0]?.c()`、し`E0`式です`a.b[0].c()`と`E1`式は、`a.b[0]?.c()`します。

場合`E0`し、何もとして分類されます`E`nothing として分類されます。 それ以外の場合、E は値として分類されます。

`E0` `E1`の意味を判断するために使用`E`:

*  場合`E`として発生する*statement_expression*の意味`E`ステートメントと同じです

   ```csharp
   if ((object)P != null) E1;
   ```

   P は 1 回だけ評価されることを除きます。

*  の場合`E0`コンパイル時エラーが発生した nothing として分類されます。

*  それ以外の場合、ように`T0`の型である`E0`します。

   *  場合`T0`型パラメーターには、参照型または null 非許容値型では、コンパイル時エラーが発生したが不明です。

   *  場合`T0`null 非許容値型では、次の種類は`E`は`T0?`との意味`E`と同じです

      ```csharp
      ((object)P == null) ? (T0?)null : E1
      ```

      点を除いて`P`は 1 回だけ評価されます。

   *  それ以外の場合、電子メールの種類は、T0、および電子メールの意味は同じ

      ```csharp
      ((object)P == null) ? null : E1
      ```

      点を除いて`P`は 1 回だけ評価されます。

場合`E1`自体では、 *null_conditional_expression*、し、この規則が適用されます、もう一度のテストを入れ子`null`なくなるまで`?`の式が、一番下まで減少したとプライマリ式に`E0`します。

たとえば場合、式`a.b?[0]?.c()`ステートメントのようにステートメントの式、として発生します。
```csharp
a.b?[0]?.c();
```
その意味と同等です。
```csharp
if (a.b != null) a.b[0]?.c();
```
もう一度と同等です。
```csharp
if (a.b != null) if (a.b[0] != null) a.b[0].c();
```
点を除いて`a.b`と`a.b[0]`1 回だけ評価されます。

場合に、その値が使用されているでのコンテキストで行われます。
```csharp
var x = a.b?[0]?.c();
```
その意味と等価の最後の呼び出しの種類が null 非許容値型がない、.
```csharp
var x = (a.b == null) ? null : (a.b[0] == null) ? null : a.b[0].c();
```
点を除いて`a.b`と`a.b[0]`1 回だけ評価されます。

#### <a name="null-conditional-expressions-as-projection-initializers"></a>プロジェクション初期化子として null 条件式

Null 条件式としてのみ使用できます、 *member_declarator*で、 *anonymous_object_creation_expression* ([匿名オブジェクト作成式](expressions.md#anonymous-object-creation-expressions)) 場合(null 条件の必要に応じて) メンバー アクセスで終了します。 文法的に、この要件は、として表現できます。

```antlr
null_conditional_member_access
    : primary_expression null_conditional_operations? '?' '.' identifier type_argument_list?
    | primary_expression null_conditional_operations '.' identifier type_argument_list?
    ;
```

これは、特殊なケースの文法の*null_conditional_expression*上。 運用*member_declarator*で[匿名オブジェクト作成式](expressions.md#anonymous-object-creation-expressions)のみを含む、 *null_conditional_member_access*します。

#### <a name="null-conditional-expressions-as-statement-expressions"></a>ステートメントの式と null 条件式

Null 条件式としてのみ使用できます、 *statement_expression* ([式ステートメント](statements.md#expression-statements)) 場合は、呼び出しで終了します。 文法的に、この要件は、として表現できます。

```antlr
null_conditional_invocation_expression
    : primary_expression null_conditional_operations '(' argument_list? ')'
    ;
```

これは、特殊なケースの文法の*null_conditional_expression*上。 運用*statement_expression*で[式ステートメント](statements.md#expression-statements)のみを含む、 *null_conditional_invocation_expression*します。


### <a name="unary-plus-operator"></a>単項プラス演算子

フォームの操作の`+x`、単項演算子のオーバー ロードの解決 ([単項演算子のオーバー ロードの解決](expressions.md#unary-operator-overload-resolution)) を適用して特定の演算子の実装を選択します。 オペランドは、選択した演算子のパラメーターの型に変換され、結果の型が演算子の戻り値の型。 定義済みの単項プラス演算子は。

```csharp
int operator +(int x);
uint operator +(uint x);
long operator +(long x);
ulong operator +(ulong x);
float operator +(float x);
double operator +(double x);
decimal operator +(decimal x);
```

これらの演算子のそれぞれについて、単に、オペランドの値になります。

### <a name="unary-minus-operator"></a>単項マイナス演算子

フォームの操作の`-x`、単項演算子のオーバー ロードの解決 ([単項演算子のオーバー ロードの解決](expressions.md#unary-operator-overload-resolution)) を適用して特定の演算子の実装を選択します。 オペランドは、選択した演算子のパラメーターの型に変換され、結果の型が演算子の戻り値の型。 定義済みの否定演算子は次のとおりです。

*  整数の否定:

   ```csharp
   int operator -(int x);
   long operator -(long x);
   ```

   結果を差し引いて計算`x`ゼロから。 場合の値の`x`オペランドの型の表現可能な最小の値は、(-2 ^31`int`または-2 ^63 `long`) の算術否定し`x`オペランドの型で表すことはできません。 内でこのような場合、`checked`コンテキスト、`System.OverflowException`スロー; 内に発生する場合は、`unchecked`コンテキスト、結果はオペランドの値と、オーバーフローが報告されません。

   あるかどうか、否定演算子のオペランドも型`uint`、型に変換されます`long`、および結果の型は`long`します。 例外は、許可するルール、 `int` -2147483648 の値 (-2 ^31)、10 進数の整数リテラルとして記述すること ([整数リテラル](lexical-structure.md#integer-literals))。

   あるかどうか、否定演算子のオペランドも型`ulong`コンパイル時エラーが発生します。 例外は、許可するルール、`long`値-9223372036854775808 (-2 ^63)、10 進数の整数リテラルとして記述すること ([整数リテラル](lexical-structure.md#integer-literals))。

*  浮動小数点の否定:

   ```csharp
   float operator -(float x);
   double operator -(double x);
   ```

   結果の値は、`x`符号を反転させたとします。 場合`x`が NaN の場合、結果が NaN でも。

*  10 進数の否定:

   ```csharp
   decimal operator -(decimal x);
   ```

   結果を差し引いて計算`x`ゼロから。 10 進数の否定は、単項マイナス型の演算子を使用すると、`System.Decimal`します。

### <a name="logical-negation-operator"></a>論理否定演算子

フォームの操作の`!x`、単項演算子のオーバー ロードの解決 ([単項演算子のオーバー ロードの解決](expressions.md#unary-operator-overload-resolution)) を適用して特定の演算子の実装を選択します。 オペランドは、選択した演算子のパラメーターの型に変換され、結果の型が演算子の戻り値の型。 1 つだけの定義済みの論理否定演算子が存在します。
```csharp
bool operator !(bool x);
```

この演算子はオペランドの論理否定演算を計算します。オペランドが場合`true`、結果は`false`します。 オペランドが場合`false`、結果は`true`します。

### <a name="bitwise-complement-operator"></a>ビットごとの補数演算子

フォームの操作の`~x`、単項演算子のオーバー ロードの解決 ([単項演算子のオーバー ロードの解決](expressions.md#unary-operator-overload-resolution)) を適用して特定の演算子の実装を選択します。 オペランドは、選択した演算子のパラメーターの型に変換され、結果の型が演算子の戻り値の型。 定義済みのビットごとの補数演算子は次のとおりです。
```csharp
int operator ~(int x);
uint operator ~(uint x);
long operator ~(long x);
ulong operator ~(ulong x);
```

操作の結果のビットごとの補数はこれらの演算子のそれぞれについて、`x`します。

すべての列挙型`E`暗黙的に次のビットごとの補数演算子を提供します。

```csharp
E operator ~(E x);
```

評価結果`~x`ここで、`x`列挙型の式を指定`E`基になる型`U`、評価と同じでは正確に`(E)(~(U)x)`ことを除いてへの変換`E`はとして常に実行される場合は、`unchecked`コンテキスト ([checked と unchecked 演算子](expressions.md#the-checked-and-unchecked-operators))。

### <a name="prefix-increment-and-decrement-operators"></a>前置インクリメントとデクリメント演算子

```antlr
pre_increment_expression
    : '++' unary_expression
    ;

pre_decrement_expression
    : '--' unary_expression
    ;
```

オペランドを前置インクリメントまたはデクリメントの操作が、変数、プロパティ アクセス、またはインデクサー アクセスとして分類される式をする必要があります。 操作の結果は、オペランドと同じ型の値です。

場合は、プレフィックスのオペランドがインクリメントまたはデクリメント演算は、プロパティまたはインデクサー アクセス、プロパティまたはインデクサーが両方必要、`get`と`set`アクセサー。 サポートしていない場合は、バインド時エラーが発生します。

単項演算子のオーバー ロードの解決 ([単項演算子のオーバー ロードの解決](expressions.md#unary-operator-overload-resolution)) を適用して特定の演算子の実装を選択します。 定義済みの`++`と`--`演算子は、次の種類の存在: `sbyte`、 `byte`、 `short`、 `ushort`、 `int`、 `uint`、 `long`、 `ulong`、 `char`、 `float`、 `double`、 `decimal`、および任意の列挙型。 定義済み`++`演算子がオペランドを定義済みに 1 を追加することによって生成された値を返す`--`演算子オペランドから 1 を引いた値を返します。 `checked`場合この加算または減算の結果が結果の型の範囲外と結果型が整数型または列挙型では、コンテキスト、`System.OverflowException`がスローされます。

前置インクリメントの実行時の処理またはフォームの操作をデクリメント`++x`または`--x`次の手順で構成されています。

*   場合`x`変数として分類されます。
    * `x` 変数を生成するために評価されます。
    * 値は、選択した演算子が呼び出される`x`引数として。
    * 評価によって指定した位置に、演算子によって返される値が格納されている`x`します。
    * 演算子によって返される値は、操作の結果になります。
*   場合`x`プロパティまたはインデクサーのアクセスに分類されます。
    * インスタンス式 (場合`x`ない`static`) および引数リスト (場合`x`インデクサー アクセス) に関連付けられている`x`が評価されると、その後で、結果の使用`get`と`set`アクセサーの呼び出し。
    * `get`のアクセサー`x`が呼び出されます。
    * 選択した演算子が呼び出されるによって返される値と、`get`引数にアクセサー。
    * `set`のアクセサー`x`が呼び出されると演算子によって返される値とその`value`引数。
    * 演算子によって返される値は、操作の結果になります。

`++`と`--`演算子もサポートして後置表記法 ([置インクリメント演算子と前置デクリメント演算子](expressions.md#postfix-increment-and-decrement-operators))。 結果では通常、`x++`または`x--`の値は、`x`操作の前に一方の結果`++x`または`--x`の値は、`x`操作の完了後します。 いずれの場合も、`x`自体、操作の後に同じ値に含まれています。

`operator++`または`operator--`実装は、いずれかの後置または前置表記を使用して呼び出すことができます。 2 つの表記の個別の演算子の実装を持つことはできません。

### <a name="cast-expressions"></a>キャスト式

A *cast_expression*式を指定した型に明示的に変換するために使用します。

```antlr
cast_expression
    : '(' type ')' unary_expression
    ;
```

A *cast_expression*フォームの`(T)E`ここで、`T`は、*型*と`E`は、 *unary_expression*、明示的なを実行します変換 ([明示的な変換](conversions.md#explicit-conversions)) の値の`E`入力`T`します。 明示的な変換が存在しない場合`E`に`T`、バインド エラーが発生します。 それ以外の場合、結果は、明示的な変換によって生成された値になります。 結果は常に、値として分類場合でも`E`変数を表します。

文法、 *cast_expression*特定構文のあいまいさにつながります。 たとえば、式`(x)-y`いずれかとして解釈される可能性を*cast_expression* (のキャスト`-y`を入力する`x`) か、または、 *additive_expression*と組み合わせて、*parenthesized_expression* (値を計算する`x - y)`します。

解決するのには*cast_expression*あいまいさは、次のルールが存在します。1 つまたは複数のシーケンス*トークン*s ([空白](lexical-structure.md#white-space)) 囲まれていると見なされますの開始をかっこで囲まれた、 *cast_expression*次の少なくとも 1 つが true の場合にのみ。

*  トークンのシーケンスの文法が正しいは、*型*ではなく、*式*します。
*  トークンのシーケンスの文法が正しいは、*型*、閉じかっこの直後に続くトークンは、トークンと"`~`"、トークン"`!`"、トークン"`(`"、 *識別子*([Unicode 文字のエスケープ シーケンス](lexical-structure.md#unicode-character-escape-sequences))、*リテラル*([リテラル](lexical-structure.md#literals))、または any*キーワード*([キーワード](lexical-structure.md#keywords)) を除く`as`と`is`します。

トークンのシーケンスは、特定の文法的な運用環境に従う必要があるだけのことを意味上の「正しい文法」ターム。 構成要素である識別子の実際の意味具体的には考慮されません。 たとえば場合、`x`と`y`は、識別子、`x.y`正しい文法型の場合は、場合でも`x.y`型を表すは実際にします。

場合、次の曖昧性除去ルールから`x`と`y`識別子、 `(x)y`、`(x)(y)`と`(x)(-y)`は*cast_expression*、s が`(x)-y`でない場合でも`x`型を識別します。 ただし場合、`x`は定義済みの型を識別するキーワードです (など`int`)、4 つの形式は*cast_expression*s (このようなキーワード可能性があるできなかったため、式を単独で)。

### <a name="await-expressions"></a>Await 式

Await 演算子は、オペランドで表される非同期操作が完了するまでに、外側の非同期関数の評価を中断に使用されます。

```antlr
await_expression
    : 'await' unary_expression
    ;
```

*Await_expression*は非同期関数の本体でのみ使用できます ([反復子](classes.md#iterators))。 最も外側の非同期関数では、 *await_expression*これらの場所で発生しません。

*  入れ子になった (非 async) 匿名関数の内部
*  ブロックの内側、 *lock_statement*
*  Unsafe コンテキストで

なお、 *await_expression*内のほとんどの場所で発生することはできません、 *query_expression*ものが構文的にでは、非同期ラムダ式を使用して変換されるため、します。

非同期関数の内部で`await`識別子として使用することはできません。 そのため、await 式と識別子を含むさまざまな式の構文のあいまいさはありません。 非同期関数では、外部`await`は通常の識別子として機能します。

オペランドを*await_expression*と呼ばれますが、***タスク***します。 時に完了できない可能性がありますまたは可能性のある非同期操作を表す、 *await_expression*が評価されます。 Await 演算子では、待機中のタスクが完了するまでに、外側の非同期関数の実行を中断し、その結果を取得します。

#### <a name="awaitable-expressions"></a>待機可能な式

Await 式のタスクである必要が***待機可能物***します。 式`t`は、次のいずれかが保持している場合は待機可能物。

*  `t` コンパイル時の型です。 `dynamic`
*  `t` アクセス可能なインスタンスまたは拡張メソッドが呼び出されますが`GetAwaiter`パラメーターと型パラメーターと戻り値の型を`A`は次のすべてを保持します。
   * `A` インターフェイスを実装する`System.Runtime.CompilerServices.INotifyCompletion`(と呼びます`INotifyCompletion`簡潔にするため)
   * `A` インスタンスがアクセスできる、読み取り可能なプロパティを持つ`IsCompleted`型の `bool`
   * `A` アクセス可能なインスタンス メソッドを持つ`GetResult`パラメーターと型パラメーターを

目的、`GetAwaiter`メソッドが取得するには、 ***awaiter***タスク。 型`A`が呼び出されます、 ***awaiter 型***の await 式。

目的、`IsCompleted`プロパティは、タスクが完了して既にかどうかを判断します。 そうである場合、評価を中断する必要はありません。

目的、`INotifyCompletion.OnCompleted`メソッドが「継続」タスクをサインアップするにはデリゲートつまり (型の`System.Action`) をタスクが完了すると呼び出されます。

目的、`GetResult`メソッドは、それが完了したら、タスクの結果を取得します。 この結果、場合によっては、結果の値で正常に完了場合がありますまたはによってスローされる例外がある可能性があります、`GetResult`メソッド。

#### <a name="classification-of-await-expressions"></a>分類の await 式

式`await t`式と同じように分類されます`(t).GetAwaiter().GetResult()`します。 したがって、戻り値の型の場合`GetResult`は`void`、 *await_expression* nothing として分類されます。 非 void の戻り値の型がある場合`T`、 *await_expression*型の値として分類されます`T`します。

#### <a name="runtime-evaluation-of-await-expressions"></a>Await 式の実行時の評価

式は、実行時に`await t`は次のように評価されます。

*  Awaiter`a`式を評価することによって取得`(t).GetAwaiter()`します。
*  A `bool` `b`式を評価することによって取得`(a).IsCompleted`します。
*  場合`b`は`false`評価がかどうかに依存し、`a`インターフェイスを実装する`System.Runtime.CompilerServices.ICriticalNotifyCompletion`(と呼びます`ICriticalNotifyCompletion`簡潔にするため)。 このチェックはバインドの時間で行われます実行時につまり場合`a`コンパイル時の型が`dynamic`、し、それ以外の場合コンパイル時にします。 ように`r`再開デリゲートを表します ([反復子](classes.md#iterators))。
    * 場合`a`実装しない`ICriticalNotifyCompletion`、式、`(a as (INotifyCompletion)).OnCompleted(r)`が評価されます。
    * 場合`a`を実装して`ICriticalNotifyCompletion`、式、`(a as (ICriticalNotifyCompletion)).UnsafeOnCompleted(r)`が評価されます。
    * 評価が中断し、および非同期関数の現在の呼び出し元に制御が返されます。
*  いずれかの直後に (場合`b`が`true`)、または再開デリゲートの起動の後に (場合`b`が`false`)、式`(a).GetResult()`が評価されます。 その値がの結果で値を返された場合、 *await_expression*します。 それ以外の場合、結果はありません。

インターフェイスのメソッドの実装を awaiter の`INotifyCompletion.OnCompleted`と`ICriticalNotifyCompletion.UnsafeOnCompleted`発生することは、デリゲート`r`多くても 1 回呼び出されます。 それ以外の場合、外側の非同期関数の動作は定義されません。

## <a name="arithmetic-operators"></a>算術演算子

`*`、 `/`、 `%`、 `+`、および`-`演算子は、算術演算子と呼ばれます。

```antlr
multiplicative_expression
    : unary_expression
    | multiplicative_expression '*' unary_expression
    | multiplicative_expression '/' unary_expression
    | multiplicative_expression '%' unary_expression
    ;

additive_expression
    : multiplicative_expression
    | additive_expression '+' multiplicative_expression
    | additive_expression '-' multiplicative_expression
    ;
```

算術演算子のオペランドがコンパイル時の型を持つかどうか`dynamic`、式を動的にバインドし、([動的バインド](expressions.md#dynamic-binding))。 この場合、式のコンパイル時の型は`dynamic`、コンパイル時の型を持つこれらのオペランドの実行時の型を使用して実行時に以下に示す解決が行わ`dynamic`します。

### <a name="multiplication-operator"></a>乗算演算子

フォームの操作の`x * y`、二項演算子のオーバー ロードの解決 ([二項演算子のオーバー ロードの解決](expressions.md#binary-operator-overload-resolution)) を適用して特定の演算子の実装を選択します。 オペランドは、選択した演算子のパラメーターの型に変換され、結果の型が演算子の戻り値の型。

定義済みの乗算演算子は、以下に示します。 すべての演算子の積が計算`x`と`y`します。

*  整数の乗算します。

   ```csharp
   int operator *(int x, int y);
   uint operator *(uint x, uint y);
   long operator *(long x, long y);
   ulong operator *(ulong x, ulong y);
   ```

   `checked`製品が結果の型の範囲外の場合は、コンテキスト、`System.OverflowException`がスローされます。 `unchecked`コンテキスト、オーバーフローが報告されず、結果型の範囲外有意の上位ビットは破棄されます。


*  浮動小数点の乗算します。

   ```csharp
   float operator *(float x, float y);
   double operator *(double x, double y);
   ```

   製品は、IEEE 754 の演算の規則に従って計算されます。 次の表では、有限値が 0 以外の場合の可能なすべての組み合わせ、ゼロ、無限大および NaN の結果を示します。 表に、`x`と`y`は正の有限値。 `z` 結果は、`x * y`します。 変換先の型に対して、結果が大きすぎる場合`z`無限大です。 変換先の型の結果が小さすぎる場合`z`は 0 です。

   |      |      |      |     |     |      |      |     |
   |:----:|-----:|:----:|:---:|:---:|:----:|:----:|:----|
   |      | + y   | -y   | +0  | -0  | +inf | -inf | NaN | 
   | +x   | + z   | ~ z   | +0  | -0  | +inf | -inf | NaN | 
   | -x   | ~ z   | + z   | -0  | +0  | -inf | +inf | NaN | 
   | +0   | +0   | -0   | +0  | -0  | NaN  | NaN  | NaN | 
   | -0   | -0   | +0   | -0  | +0  | NaN  | NaN  | NaN | 
   | +inf | +inf | -inf | NaN | NaN | +inf | -inf | NaN | 
   | -inf | -inf | +inf | NaN | NaN | -inf | +inf | NaN | 
   | NaN  | NaN  | NaN  | NaN | NaN | NaN  | NaN  | NaN | 

*  10 進数の乗算します。

   ```csharp
   decimal operator *(decimal x, decimal y);
   ```

   結果の値が大きすぎてで表すかどうか、`decimal`形式、`System.OverflowException`がスローされます。 結果値はで表現するには小さすぎるかどうか、`decimal`形式、結果は 0 です。 丸めを行う前に、結果の小数点以下桁数は、2 つのオペランドのスケールの合計です。

   10 進数の乗算は型の乗算演算子を使用すると、`System.Decimal`します。


### <a name="division-operator"></a>除算演算子

フォームの操作の`x / y`、二項演算子のオーバー ロードの解決 ([二項演算子のオーバー ロードの解決](expressions.md#binary-operator-overload-resolution)) を適用して特定の演算子の実装を選択します。 オペランドは、選択した演算子のパラメーターの型に変換され、結果の型が演算子の戻り値の型。

定義済みの除算演算子は、以下に示します。 すべての演算子の商を計算する`x`と`y`します。

*  整数除算します。

   ```csharp
   int operator /(int x, int y);
   uint operator /(uint x, uint y);
   long operator /(long x, long y);
   ulong operator /(ulong x, ulong y);
   ```

   右側のオペランドの値が 0 の場合、`System.DivideByZeroException`がスローされます。

   除算では、0 方向に結果を丸めます。 したがって、結果の絶対値が 2 つのオペランドの商の絶対値と等しいまたはそれより小さい最大整数です。 結果は、2 つのオペランドが同じ符号がある、または記号の反対側の 2 つのオペランドが負の場合は 0 または正の値。

   左側のオペランドが表現可能な最小の場合`int`または`long`値と右辺オペランドは`-1`オーバーフローが発生します。 `checked`コンテキスト、これにより、 `System.ArithmeticException` (またはそのサブクラス) がスローされます。 `unchecked`実装で定義されたかどうかは、そのコンテキストを`System.ArithmeticException`(またはそのサブクラス) がスローされますまたは結果の中、左側のオペランドの値に、オーバーフローが報告されません。

*  浮動小数点除算します。

   ```csharp
   float operator /(float x, float y);
   double operator /(double x, double y);
   ```

   商は、IEEE 754 の演算の規則に従って計算されます。 次の表では、有限値が 0 以外の場合の可能なすべての組み合わせ、ゼロ、無限大および NaN の結果を示します。 表に、`x`と`y`は正の有限値。 `z` 結果は、`x / y`します。 変換先の型に対して、結果が大きすぎる場合`z`無限大です。 変換先の型の結果が小さすぎる場合`z`は 0 です。

   |      |      |      |      |      |      |      |      |
   |:----:|:----:|:----:|:----:|:----:|:----:|:----:|:----:|
   |      | + y   | -y   | +0   | -0   | +inf | -inf | NaN  | 
   | +x   | + z   | ~ z   | +inf | -inf | +0   | -0   | NaN  | 
   | -x   | ~ z   | + z   | -inf | +inf | -0   | +0   | NaN  | 
   | +0   | +0   | -0   | NaN  | NaN  | +0   | -0   | NaN  | 
   | -0   | -0   | +0   | NaN  | NaN  | -0   | +0   | NaN  | 
   | +inf | +inf | -inf | +inf | -inf | NaN  | NaN  | NaN  | 
   | -inf | -inf | +inf | -inf | +inf | NaN  | NaN  | NaN  | 
   | NaN  | NaN  | NaN  | NaN  | NaN  | NaN  | NaN  | NaN  | 

*  小数除算します。

   ```csharp
   decimal operator /(decimal x, decimal y);
   ```

   右側のオペランドの値が 0 の場合、`System.DivideByZeroException`がスローされます。 結果の値が大きすぎてで表すかどうか、`decimal`形式、`System.OverflowException`がスローされます。 結果値はで表現するには小さすぎるかどうか、`decimal`形式、結果は 0 です。 結果の小数点以下桁数と等しい、結果を保持する最小のスケール、実際の計算結果を 10 進値を表現できる最も近い。

   10 進数の除算は型の除算演算子を使用すると、`System.Decimal`します。


### <a name="remainder-operator"></a>剰余演算子

フォームの操作の`x % y`、二項演算子のオーバー ロードの解決 ([二項演算子のオーバー ロードの解決](expressions.md#binary-operator-overload-resolution)) を適用して特定の演算子の実装を選択します。 オペランドは、選択した演算子のパラメーターの型に変換され、結果の型が演算子の戻り値の型。

定義済みの剰余演算子は、以下に示します。 すべての演算子の間での除算の剰余を計算`x`と`y`します。

*  整数の剰余。

   ```csharp
   int operator %(int x, int y);
   uint operator %(uint x, uint y);
   long operator %(long x, long y);
   ulong operator %(ulong x, ulong y);
   ```

   結果`x % y`によって値が生成される`x - (x / y) * y`します。 場合`y`0 の場合は、`System.DivideByZeroException`がスローされます。

   左側のオペランドが最も場合`int`または`long`値と右辺オペランドは`-1`、`System.OverflowException`がスローされます。 ない場合は`x % y`例外をスロー場所`x / y`は例外をスローできません。

*  浮動小数点の剰余。

   ```csharp
   float operator %(float x, float y);
   double operator %(double x, double y);
   ```

   次の表では、有限値が 0 以外の場合の可能なすべての組み合わせ、ゼロ、無限大および NaN の結果を示します。 表に、`x`と`y`は正の有限値。 `z` 結果は、`x % y`を計算して`x - n * y`ここで、`n`に等しいまたはそれより小さい最大整数を`x / y`します。 残りの部分をコンピューティングするのには、このメソッドは整数オペランドで使用される類似していますが、IEEE 754 の定義とは異なります (これで`n`に最も近い整数は、 `x / y`)。

   |      |      |      |      |      |      |      |      |
   |:----:|:----:|:----:|:----:|:----:|:----:|:----:|:----:|
   |      | + y   | -y   | +0   | -0   | +inf | -inf | NaN  | 
   | +x   | + z   | + z   | NaN  | NaN  | x    | x    | NaN  | 
   | -x   | ~ z   | ~ z   | NaN  | NaN  | -x   | -x   | NaN  | 
   | +0   | +0   | +0   | NaN  | NaN  | +0   | +0   | NaN  | 
   | -0   | -0   | -0   | NaN  | NaN  | -0   | -0   | NaN  | 
   | +inf | NaN  | NaN  | NaN  | NaN  | NaN  | NaN  | NaN  | 
   | -inf | NaN  | NaN  | NaN  | NaN  | NaN  | NaN  | NaN  | 
   | NaN  | NaN  | NaN  | NaN  | NaN  | NaN  | NaN  | NaN  | 

*  10 進数の剰余。

   ```csharp
   decimal operator %(decimal x, decimal y);
   ```

   右側のオペランドの値が 0 の場合、`System.DivideByZeroException`がスローされます。 丸めを行う前に、結果の小数点以下桁数は 2 つのオペランドの規模の大きいと、結果の符号は、0 以外の場合はいるのと同じ`x`します。

   10 進数の残りの部分は型の剰余演算子を使用すると`System.Decimal`します。


### <a name="addition-operator"></a>加算演算子

フォームの操作の`x + y`、二項演算子のオーバー ロードの解決 ([二項演算子のオーバー ロードの解決](expressions.md#binary-operator-overload-resolution)) を適用して特定の演算子の実装を選択します。 オペランドは、選択した演算子のパラメーターの型に変換され、結果の型が演算子の戻り値の型。

定義済みの加算演算子は、以下に示します。 数値型と列挙型の場合は、定義済みの加算演算子は、2 つのオペランドの合計を計算します。 1 つまたは両方のオペランドが文字列型、定義済みの加算演算子はオペランドの文字列表現を連結します。

*  整数の加算:

   ```csharp
   int operator +(int x, int y);
   uint operator +(uint x, uint y);
   long operator +(long x, long y);
   ulong operator +(ulong x, ulong y);
   ```

   `checked`コンテキスト、合計が、結果の型の範囲外の場合、`System.OverflowException`がスローされます。 `unchecked`コンテキスト、オーバーフローが報告されず、結果型の範囲外有意の上位ビットは破棄されます。

*  浮動小数点加算します。

   ```csharp
   float operator +(float x, float y);
   double operator +(double x, double y);
   ```

   合計は、IEEE 754 の演算の規則に従って計算されます。 次の表では、有限値が 0 以外の場合の可能なすべての組み合わせ、ゼロ、無限大および NaN の結果を示します。 表に、`x`と`y`は 0 以外の値の有限値と`z`の結果は、`x + y`します。 場合`x`と`y`絶対値が同じ記号、方向が逆`z`は正の 0 になります。 場合`x + y`が大きすぎて、変換先の型で表す`z`、無限大と同じ符号で`x + y`します。

   |      |      |      |      |      |      |      |
   |:----:|:----:|:----:|:----:|:----:|:----:|:----:|
   |      | Y    | +0   | -0   | +inf | -inf | NaN  | 
   | x    | z    | x    | x    | +inf | -inf | NaN  | 
   | +0   | Y    | +0   | +0   | +inf | -inf | NaN  | 
   | -0   | Y    | +0   | -0   | +inf | -inf | NaN  | 
   | +inf | +inf | +inf | +inf | +inf | NaN  | NaN  | 
   | -inf | -inf | -inf | -inf | NaN  | -inf | NaN  | 
   | NaN  | NaN  | NaN  | NaN  | NaN  | NaN  | NaN  | 

*  10 進数の追加:

   ```csharp
   decimal operator +(decimal x, decimal y);
   ```

   結果の値が大きすぎてで表すかどうか、`decimal`形式、`System.OverflowException`がスローされます。 丸めを行う前に、結果の小数点以下桁数は 2 つのオペランドのスケールのうち、大きい方です。

   10 進数の加算は型の加算演算子を使用すると、`System.Decimal`します。

*  列挙型の加算します。 すべての列挙型を暗黙的に、次の定義済みの演算子、提供、`E`列挙型と`U`の基になる型は、 `E`:

   ```csharp
   E operator +(E x, U y);
   E operator +(U x, E y);
   ```

   実行時にこれらの演算子が正確に評価されます`(E)((U)x + (U)y)`します。

*  文字列の連結。

   ```csharp
   string operator +(string x, string y);
   string operator +(string x, object y);
   string operator +(object x, string y);
   ```

   これらのオーバー ロードのバイナリの`+`演算子が文字列の連結を実行します。 文字列の連結のオペランドは場合`null`、空の文字列に置き換えられます。 仮想を呼び出すことによって、任意の文字列以外の引数を文字列形式に変換がそれ以外の場合、`ToString`型から継承されたメソッド`object`します。 場合`ToString`返します`null`、空の文字列に置き換えられます。

   ```csharp
   using System;
   
   class Test
   {
       static void Main() {
           string s = null;
           Console.WriteLine("s = >" + s + "<");        // displays s = ><
           int i = 1;
           Console.WriteLine("i = " + i);               // displays i = 1
           float f = 1.2300E+15F;
           Console.WriteLine("f = " + f);               // displays f = 1.23E+15
           decimal d = 2.900m;
           Console.WriteLine("d = " + d);               // displays d = 2.900
       }
   }
   ```

   文字列連結演算子の結果は、左オペランドと右辺オペランドの文字が続くの文字で構成される文字列です。 文字列連結演算子が返すことはありません、`null`値。 A`System.OutOfMemoryException`結果の文字列を割り当てることができる十分なメモリがない場合にスローされる可能性があります。

*  デリゲートの組み合わせ。 すべてのデリゲート型が暗黙的に次の定義済みの演算子を提供します、`D`はデリゲート型です。

   ```csharp
   D operator +(D x, D y);
   ```

   バイナリ`+`演算子は、両方のオペランドがいくつかのデリゲート型の場合、デリゲートの組み合わせを実行`D`します。 (この場合、オペランドに異なるデリゲート型では、バインド時のエラーが発生します。)最初のオペランドが場合`null`、操作の結果は、2 番目のオペランドの値 (である場合でも`null`)。 それ以外の場合、2 番目のオペランドが場合`null`操作の結果は最初のオペランドの値。 それ以外の場合、操作の結果は、新しいデリゲート インスタンスが、呼び出される、最初のオペランドを呼び出すし、2 番目のオペランドを呼び出します。 デリゲートの組み合わせの例については、[減算演算子](expressions.md#subtraction-operator)と[デリゲート呼び出し](delegates.md#delegate-invocation)を参照してください。 `System.Delegate` 、デリゲート型ではない`operator` `+`用に定義されていません。

### <a name="subtraction-operator"></a>減算演算子

フォームの操作の`x - y`、二項演算子のオーバー ロードの解決 ([二項演算子のオーバー ロードの解決](expressions.md#binary-operator-overload-resolution)) を適用して特定の演算子の実装を選択します。 オペランドは、選択した演算子のパラメーターの型に変換され、結果の型が演算子の戻り値の型。

定義済みの減算演算子は、以下に示します。 すべての減算演算子`y`から`x`します。

*  整数の減算:

   ```csharp
   int operator -(int x, int y);
   uint operator -(uint x, uint y);
   long operator -(long x, long y);
   ulong operator -(ulong x, ulong y);
   ```

   `checked`コンテキスト、違いが結果の型の範囲外の場合、`System.OverflowException`がスローされます。 `unchecked`コンテキスト、オーバーフローが報告されず、結果型の範囲外有意の上位ビットは破棄されます。

*  浮動小数点の減算:

   ```csharp
   float operator -(float x, float y);
   double operator -(double x, double y);
   ```

   違いは、IEEE 754 の演算の規則に従って計算されます。 次の表では、0 以外の値の有限値の可能なすべての組み合わせ、ゼロ、無限大および Nan の結果を示します。 表に、`x`と`y`は 0 以外の値の有限値と`z`の結果は、`x - y`します。 場合`x`と`y`が等しいか、`z`は正の 0 になります。 場合`x - y`が大きすぎて、変換先の型で表す`z`、無限大と同じ符号で`x - y`します。

   |      |      |      |      |      |      |     |
   |:----:|:----:|:----:|:----:|:----:|:----:|:---:|
   |      | Y    | +0   | -0   | +inf | -inf | NaN | 
   | x    | z    | x    | x    | -inf | +inf | NaN | 
   | +0   | -y   | +0   | +0   | -inf | +inf | NaN | 
   | -0   | -y   | -0   | +0   | -inf | +inf | NaN | 
   | +inf | +inf | +inf | +inf | NaN  | +inf | NaN | 
   | -inf | -inf | -inf | -inf | -inf | NaN  | NaN | 
   | NaN  | NaN  | NaN  | NaN  | NaN  | NaN  | NaN | 

*  10 進数の減算:

   ```csharp
   decimal operator -(decimal x, decimal y);
   ```

   結果の値が大きすぎてで表すかどうか、`decimal`形式、`System.OverflowException`がスローされます。 丸めを行う前に、結果の小数点以下桁数は 2 つのオペランドのスケールのうち、大きい方です。

   10 進数の減算は、型の減算演算子を使用すると`System.Decimal`します。

*  列挙型の減算します。 すべての列挙型が暗黙的に次の定義済みの演算子を提供、`E`列挙型と`U`の基になる型は、 `E`:

   ```csharp
   U operator -(E x, E y);
   ```

   この演算子の評価とまったく同じ`(U)((U)x - (U)y)`します。 つまりの序数値の差の計算演算子`x`と`y`、列挙体の基になる型であり、結果の型。

   ```csharp
   E operator -(E x, U y);
   ```

   この演算子の評価とまったく同じ`(E)((U)x - y)`します。 つまり、演算子は、減算、列挙体の基になる型の値列挙体の値として生成します。

*  デリゲートの削除。 すべてのデリゲート型が暗黙的に次の定義済みの演算子を提供します、`D`はデリゲート型です。

   ```csharp
   D operator -(D x, D y);
   ```

   バイナリ`-`演算子は、両方のオペランドがいくつかのデリゲート型の場合、デリゲートの削除を実行`D`します。 オペランドに異なるデリゲート型がある場合、バインド時のエラーが発生します。 最初のオペランドが場合`null`、操作の結果は`null`します。 それ以外の場合、2 番目のオペランドが場合`null`操作の結果は最初のオペランドの値。 それ以外の場合、両方のオペランドが呼び出しリストを表す ([デリゲートの宣言](delegates.md#delegate-declarations)) 1 つまたは複数のエントリと、結果はから削除された、2 番目のオペランドのエントリで、最初のオペランドの一覧から成る新しい呼び出しリスト最初の連続するサブリストは、2 番目のオペランドの一覧を提供です。     (デリゲートの等値演算子とサブリスト、対応するエントリが比較されます ([デリゲート等値演算子](expressions.md#delegate-equality-operators)).)それ以外の場合、結果は、左側のオペランドの値です。 プロセスのどちらのオペランドのリストが変更されます。 2 番目のオペランドの一覧には、最初のオペランドのリスト内の連続したエントリの複数のサブリストが一致すると、連続するエントリの右端の一致するサブリストは削除されます。 削除の結果、空のリストになる場合、結果は`null`します。 例:

   ```csharp
   delegate void D(int x);
   
   class C
   {
       public static void M1(int i) { /* ... */ }
       public static void M2(int i) { /* ... */ }
   }

   class Test
   {
       static void Main() { 
           D cd1 = new D(C.M1);
           D cd2 = new D(C.M2);
           D cd3 = cd1 + cd2 + cd2 + cd1;   // M1 + M2 + M2 + M1
           cd3 -= cd1;                      // => M1 + M2 + M2
   
           cd3 = cd1 + cd2 + cd2 + cd1;     // M1 + M2 + M2 + M1
           cd3 -= cd1 + cd2;                // => M2 + M1
   
           cd3 = cd1 + cd2 + cd2 + cd1;     // M1 + M2 + M2 + M1
           cd3 -= cd2 + cd2;                // => M1 + M1
   
           cd3 = cd1 + cd2 + cd2 + cd1;     // M1 + M2 + M2 + M1
           cd3 -= cd2 + cd1;                // => M1 + M2
   
           cd3 = cd1 + cd2 + cd2 + cd1;     // M1 + M2 + M2 + M1
           cd3 -= cd1 + cd1;                // => M1 + M2 + M2 + M1
       }
   }
   ```

## <a name="shift-operators"></a>シフト演算子

`<<`と`>>`演算子を使用して、ビット シフト演算を実行します。

```antlr
shift_expression
    : additive_expression
    | shift_expression '<<' additive_expression
    | shift_expression right_shift additive_expression
    ;
```

オペランドの場合、 *shift_expression*コンパイル時の型を持つ`dynamic`、式を動的にバインドし、([動的バインド](expressions.md#dynamic-binding))。 この場合、式のコンパイル時の型は`dynamic`、コンパイル時の型を持つこれらのオペランドの実行時の型を使用して実行時に以下に示す解決が行わ`dynamic`します。

フォームの操作の`x << count`または`x >> count`、二項演算子のオーバー ロードの解決 ([二項演算子のオーバー ロードの解決](expressions.md#binary-operator-overload-resolution)) を適用して特定の演算子の実装を選択します。 オペランドは、選択した演算子のパラメーターの型に変換され、結果の型が演算子の戻り値の型。

最初のオペランドの型では、クラスまたは構造体の演算子の宣言を含むをある必要が常にオーバー ロードされた shift 演算子を宣言するときにあり、2 番目のオペランドの型は常にあります`int`します。

定義済みのシフト演算子は、以下に示します。

*  左にシフトします。

   ```csharp
   int operator <<(int x, int count);
   uint operator <<(uint x, int count);
   long operator <<(long x, int count);
   ulong operator <<(ulong x, int count);
   ```

   `<<`演算子シフト`x`ビット数だけ左が以下に示すように計算します。

   結果型の範囲外の上位ビット`x`が破棄されるので、残りのビットが左にシフトされ、下位の空のビット位置が 0 に設定します。

*  右シフトします。

   ```csharp
   int operator >>(int x, int count);
   uint operator >>(uint x, int count);
   long operator >>(long x, int count);
   ulong operator >>(ulong x, int count);
   ```

   `>>`演算子シフト`x`ビット数だけ右が以下に示すように計算します。

   ときに`x`の種類は`int`または`long`の下位ビット`x`は破棄されるので、残りのビットが右にシフトし、空の上位ビット位置は場合は 0 に設定されます`x`負でないと設定は、1 つの場合に`x`が負の値。

   ときに`x`の種類は`uint`または`ulong`の下位ビット`x`が破棄されるので、残りのビットは右にシフトして、空の上位ビット位置が 0 に設定します。

定義済みの演算子のとおりにシフトするビット数が計算されます。

*  場合の種類`x`は`int`または`uint`の下位 5 ビットで、シフト数を指定`count`します。 つまり、シフト数がから計算された`count & 0x1F`します。
*  場合の種類`x`は`long`または`ulong`の下位 6 ビットで、シフト数を指定`count`します。 つまり、シフト数がから計算された`count & 0x3F`します。

シフト演算子は単の値を返す結果として得られる、シフト数が 0 の場合は、`x`します。

オーバーフローが発生してで同じ結果を生成しないのシフト演算を`checked`と`unchecked`コンテキスト。

ときの左オペランド、`>>`演算子が符号付き整数型は、算術右シフトのオペランドの最上位ビット (符号ビット) の値を反映する、空の上位ビット位置を実行します。 ときの左オペランド、`>>`演算子が符号なし整数型は、演算子、論理右シフトが行われ、空の上位ビット位置には常に 0 が設定されます。 オペランドの型から推論の反対側の操作を実行するには、明示的なキャストを使用していることができます。 たとえば場合、`x`型の変数は、 `int`、操作`unchecked((int)((uint)x >> y))`論理の右シフトを実行します。`x`します。

## <a name="relational-and-type-testing-operators"></a>関係演算子と型検査演算子

`==`、 `!=`、 `<`、 `>`、 `<=`、 `>=`、`is`と`as`演算子は、リレーショナルと型検査演算子と呼ばれます。

```antlr
relational_expression
    : shift_expression
    | relational_expression '<' shift_expression
    | relational_expression '>' shift_expression
    | relational_expression '<=' shift_expression
    | relational_expression '>=' shift_expression
    | relational_expression 'is' type
    | relational_expression 'as' type
    ;

equality_expression
    : relational_expression
    | equality_expression '==' relational_expression
    | equality_expression '!=' relational_expression
    ;
```

`is`演算子については、「 [、演算子は、](expressions.md#the-is-operator)と`as`演算子については、「[演算子として](expressions.md#the-as-operator)します。

`==`、 `!=`、 `<`、 `>`、`<=`と`>=`演算子は***比較演算子***します。

比較演算子のオペランドがコンパイル時の型を持つかどうか`dynamic`、式を動的にバインドし、([動的バインド](expressions.md#dynamic-binding))。 この場合、式のコンパイル時の型は`dynamic`、コンパイル時の型を持つこれらのオペランドの実行時の型を使用して実行時に以下に示す解決が行わ`dynamic`します。

フォームの操作の`x` *op* `y`ここで、 *op*比較演算子をオーバー ロードの解決 ([二項演算子のオーバー ロードの解決](expressions.md#binary-operator-overload-resolution)) を適用して特定の演算子の実装を選択します。 オペランドは、選択した演算子のパラメーターの型に変換され、結果の型が演算子の戻り値の型。

定義済みの比較演算子は、次のセクションで説明します。 すべての定義済みの比較演算子は、型の結果を返す`bool`次の表で説明するようにします。


| __操作__ | __結果__                                                       |
|---------------|------------------------------------------------------------------|
| `x == y`      | `true` 場合`x`と等しい`y`、`false`それ以外の場合                 | 
| `x != y`      | `true` 場合`x`が等しくない`y`、`false`それ以外の場合             | 
| `x < y`       | `true` 場合`x`がより小さい`y`、`false`それ以外の場合                | 
| `x > y`       | `true` 場合`x`がより大きい`y`、`false`それ以外の場合             | 
| `x <= y`      | `true` 場合`x`に等しいまたはそれよりも小さい`y`、`false`それ以外の場合    | 
| `x >= y`      | `true` 場合`x`がより大きいまたは等しい`y`、`false`それ以外の場合 | 

### <a name="integer-comparison-operators"></a>整数の比較演算子

定義済みの整数の比較演算子は次のとおりです。
```csharp
bool operator ==(int x, int y);
bool operator ==(uint x, uint y);
bool operator ==(long x, long y);
bool operator ==(ulong x, ulong y);

bool operator !=(int x, int y);
bool operator !=(uint x, uint y);
bool operator !=(long x, long y);
bool operator !=(ulong x, ulong y);

bool operator <(int x, int y);
bool operator <(uint x, uint y);
bool operator <(long x, long y);
bool operator <(ulong x, ulong y);

bool operator >(int x, int y);
bool operator >(uint x, uint y);
bool operator >(long x, long y);
bool operator >(ulong x, ulong y);

bool operator <=(int x, int y);
bool operator <=(uint x, uint y);
bool operator <=(long x, long y);
bool operator <=(ulong x, ulong y);

bool operator >=(int x, int y);
bool operator >=(uint x, uint y);
bool operator >=(long x, long y);
bool operator >=(ulong x, ulong y);
```

返します、2 つの整数オペランドの数値を比較これらの各演算子を`bool`、特定の関係は、かどうかを示す値`true`または`false`します。

### <a name="floating-point-comparison-operators"></a>浮動小数点の比較演算子

定義済みの浮動小数点数の比較演算子は次のとおりです。
```csharp
bool operator ==(float x, float y);
bool operator ==(double x, double y);

bool operator !=(float x, float y);
bool operator !=(double x, double y);

bool operator <(float x, float y);
bool operator <(double x, double y);

bool operator >(float x, float y);
bool operator >(double x, double y);

bool operator <=(float x, float y);
bool operator <=(double x, double y);

bool operator >=(float x, float y);
bool operator >=(double x, double y);
```

演算子は、IEEE 754 標準の規則に従ってオペランドを比較します。

*  結果は、いずれかのオペランドが NaN の場合は、`false`を除くすべての演算子の`!=`、結果が対象の`true`します。 任意の 2 つのオペランドの`x != y`と同じ結果を常に生成`!(x == y)`します。 ただし、1 つまたは両方のオペランドが NaN の場合が場合、 `<`、 `>`、 `<=`、および`>=`演算子は、反対側の演算子の論理否定演算と同じ結果を生成しません。 たとえば、いずれかの`x`と`y`が NaN の場合、`x < y`は`false`が`!(x >= y)`は`true`。
*  演算子が順序に関して 2 つの浮動小数点のオペランドの値を比較してどちらのオペランドが NaN の場合は、

   ```
   -inf < -max < ... < -min < -0.0 == +0.0 < +min < ... < +max < +inf
   ```

   場所`min`と`max`は、最小および最大の正の有限値を指定した浮動小数点形式で表すことができます。 この順序付けの注目すべき効果は次のとおりです。
   * 負と正のゼロは等しいと見なされます。
   * 負の無限大は小さい他のすべての値よりも、もう 1 つの負の無限大とは等しいと見なされます。
   * 正の無限大は、その他のすべての値より大きい値がもう 1 つの正の無限大に等しいと見なされます。

### <a name="decimal-comparison-operators"></a>10 進数の比較演算子

定義済みの 10 進数の比較演算子は次のとおりです。
```csharp
bool operator ==(decimal x, decimal y);
bool operator !=(decimal x, decimal y);
bool operator <(decimal x, decimal y);
bool operator >(decimal x, decimal y);
bool operator <=(decimal x, decimal y);
bool operator >=(decimal x, decimal y);
```

2 つの 10 進数のオペランドと返しますの数値を比較これらの各演算子を`bool`、特定の関係は、かどうかを示す値`true`または`false`します。 各 10 進数の比較では、対応するリレーショナルまたは型の等値演算子を使用すると`System.Decimal`します。

### <a name="boolean-equality-operators"></a>ブール等価演算子

定義済みのブール値の等値演算子は次のとおりです。
```csharp
bool operator ==(bool x, bool y);
bool operator !=(bool x, bool y);
```

結果`==`は`true`両方`x`と`y`は`true`両方または`x`と`y`は`false`します。 それ以外の場合、結果は `false` です。

結果`!=`は`false`両方`x`と`y`は`true`両方または`x`と`y`は`false`します。 それ以外の場合、結果は `true` です。 型のオペランドが場合`bool`、`!=`演算子と同じ結果を生成する、`^`演算子。

### <a name="enumeration-comparison-operators"></a>列挙体の比較演算子

すべての列挙型には、次の定義済みの比較演算子が暗黙的に用意されています。
```csharp
bool operator ==(E x, E y);
bool operator !=(E x, E y);
bool operator <(E x, E y);
bool operator >(E x, E y);
bool operator <=(E x, E y);
bool operator >=(E x, E y);
```

評価結果`x op y`ここで、`x`と`y`列挙型の式は`E`基になる型`U`、および`op`比較演算子の 1 つと同じでは正確に評価する`((U)x) op ((U)y)`します。 つまり、列挙型の比較演算子は、単に 2 つのオペランドの基になる整数値を比較します。

### <a name="reference-type-equality-operators"></a>参照型の等値演算子

定義済みの参照型の等値演算子は次のとおりです。
```csharp
bool operator ==(object x, object y);
bool operator !=(object x, object y);
```

演算子は、2 つの参照が等値演算子または非等値比較の結果を返します。

定義済みの参照型の等値演算子は、型のオペランドを受け入れるため`object`、適用可能な宣言しないすべての種類に適用される`operator ==`と`operator !=`メンバー。 逆に、任意の該当するユーザー定義の等値演算子には、定義済みの参照型の等値演算子効果的に非表示にします。

定義済みの参照型の等値演算子では、次のいずれかが必要です。

*  両方のオペランドがある既知の型の値を*reference_type*またはリテラル`null`します。 さらに、明示的な参照変換 ([明示的な参照変換](conversions.md#explicit-reference-conversions)) のいずれかのオペランドの型からもう一方のオペランドの型に存在します。
*  1 つのオペランド型の値は、`T`場所`T`は、 *type_parameter*もう一方のオペランドは、リテラルと`null`します。 さらに`T`値型の制約はありません。

これらの条件のいずれかに該当する場合を除き、バインド時のエラーが発生します。 これらのルールの主な特性は次のとおりです。

*  別のバインド時に認識されている 2 つの参照を比較する定義済みの参照型の等値演算子を使用すると、バインド時エラーになります。 たとえば、オペランドのバインド時の型は、2 つのクラス型`A`と`B`、どちらの場合と`A`も`B`の 2 つのオペランドが同じオブジェクトを参照することはできませんし、もう一方の派生です。 そのため、操作は、バインド時のエラーと見なされます。
*  定義済みの参照型の等値演算子は値と比較する型のオペランドを許可しない操作を行います。 そのため、構造体型で独自の等値演算子を宣言しない限り、その構造体の型の値を比較することはできません。
*  定義済みの参照型の等値演算子には、オペランドにボックス化操作が発生しません。 新しく割り当てられたボックス化されたインスタンスへの参照は、必然的に他のすべての参照と異なっているために、このようなボックス化操作を実行しても意味があります。
*  場合、型パラメーターの型のオペランド`T`と比較する`null`の実行時の型と`T`値型である比較の結果は`false`します。

次の例は、制約のない型パラメーターの型の引数がかどうかを確認します。`null`します。
```csharp
class C<T>
{
    void F(T x) {
        if (x == null) throw new ArgumentNullException();
        ...
    }
}
```

`x == null`コンストラクトは許可されている場合でも`T`値の型を表すことができ、結果は、単に定義`false`とき`T`は値型です。

フォームの操作の`x == y`または`x != y`任意の該当する場合は、`operator ==`または`operator !=`存在する場合、演算子のオーバー ロードの解決 ([二項演算子のオーバー ロードの解決](expressions.md#binary-operator-overload-resolution)) ルールを選択します。定義済みの参照型の等値演算子ではなく演算子です。 ただし、いずれかまたは両方のオペランドを型を明示的にキャストすることによって、定義済みの参照型の等値演算子を選択することは常に`object`します。 例では、
```csharp
using System;

class Test
{
    static void Main() {
        string s = "Test";
        string t = string.Copy(s);
        Console.WriteLine(s == t);
        Console.WriteLine((object)s == t);
        Console.WriteLine(s == (object)t);
        Console.WriteLine((object)s == (object)t);
    }
}
```
この例では、次のように出力されます。
```
True
False
False
False
```

`s`と`t`変数を指す 2 つの異なる`string`同じ文字を含むインスタンス。 最初の比較出力`True`ため、定義済みの文字列の等値演算子 ([文字列等値演算子](expressions.md#string-equality-operators)) が選択されているは、両方のオペランド型の場合`string`。 残りの比較をすべて出力`False`1 つまたは両方のオペランドの型の場合、定義済みの参照型の等値演算子が選択されているため、`object`します。

前述の手法が意味のある値型ではないことに注意してください。 例では、
```csharp
class Test
{
    static void Main() {
        int i = 123;
        int j = 123;
        System.Console.WriteLine((object)i == (object)j);
    }
}
```
出力`False`キャストの 2 つのインスタンスへの参照を作成するためのボックス化`int`値。

### <a name="string-equality-operators"></a>文字列の等値演算子

定義済みの文字列の等値演算子は次のとおりです。
```csharp
bool operator ==(string x, string y);
bool operator !=(string x, string y);
```

2 つ`string`値が等しいと見なされる、次のいずれかが true の場合。

*  両方の値が`null`します。
*  両方の値に各文字の位置と同じ長さと同じ文字を含む文字列のインスタンスに null 参照です。

文字列の等値演算子は、文字列の参照ではなく、文字列値を比較します。 2 つの別個の文字列のインスタンスに正確な同じ一連の文字が含まれている場合は、文字列の値が等しいかが、参照は異なります。 」の説明に従って[参照型の等値演算子](expressions.md#reference-type-equality-operators)参照型の等値演算子は、文字列値ではなく文字列の参照を比較するために使用できます。

### <a name="delegate-equality-operators"></a>デリゲートの等値演算子

すべてのデリゲート型には、次の定義済みの比較演算子が暗黙的に用意されています。

```csharp
bool operator ==(System.Delegate x, System.Delegate y);
bool operator !=(System.Delegate x, System.Delegate y);
```

2 つのデリゲート インスタンスが等しいとおり。

*  デリゲートのインスタンスのいずれかの場合`null`、両方とも場合にのみが等しい`null`します。
*  デリゲートがある別の実行時の型と等しいもことはありません。
*  呼び出しリストが両方のデリゲート インスタンスがあるかどうか ([デリゲートの宣言](delegates.md#delegate-declarations))、場合にだけ、それぞれの呼び出しリストが同じ長さと 1 つの呼び出しリスト内の各エントリは (下記を参照) のように、それらのインスタンスが等しいその他の呼び出しリスト内の順序で対応するエントリ。

次の規則は、呼び出しリストのエントリが等しいかどうかを制御します。

*  2 つの呼び出しリストのエントリが両方が同じ静的に参照している場合、メソッド、エントリは等しくなります。
*  2 つの呼び出しリストのエントリが両方が同じターゲット オブジェクトで同じ非静的メソッドを参照してください (参照の等値演算子で定義) された場合、エントリは等しくなります。
*  呼び出しリストのエントリが意味的に同一の評価から生成された*anonymous_method_expression*s または*lambda_expression*キャプチャされた外部変数の同じ (場合によっては空) のセットをインスタンスは許可されている (ただし必要ありません) と同じにします。

### <a name="equality-operators-and-null"></a>等値演算子と null

`==`と`!=`演算子を null 許容型およびその他がの値の 1 つのオペランドの許可、`null`操作の定義済みまたはユーザー定義の演算子 (でリフトされていない形式またはリフト形式) が存在しない場合でも、リテラル。

フォームのいずれかの操作
```csharp
x == null
null == x
x != null
null != x
```
場所`x`演算子のオーバー ロードの解決の場合、null 許容型の式は、([二項演算子のオーバー ロードの解決](expressions.md#binary-operator-overload-resolution)) から、適用可能な演算子の結果の検索に失敗が計算された代わりに、 `HasValue`プロパティの`x`します。 具体的には、最初の 2 つのフォームに変換`!x.HasValue`、および最後の 2 つのフォームに変換が`x.HasValue`します。

### <a name="the-is-operator"></a>演算子

`is`演算子を使用して動的にオブジェクトの実行時の型が指定された型と互換性をチェックします。 操作の結果`E is T`ここで、`E`式を指定し、`T`型、ブール値を示す値かどうか`E`型に正常に変換できます`T`をボックス化の参照変換によって変換またはボックス化解除の変換。 操作は、すべての型パラメーターの型引数が置き換えられた後に次のように評価されます。

*  場合`E`、匿名関数は、コンパイル時エラーが発生しました。
*  場合`E`メソッド グループ、または`null`リテラルの場合は、の種類`E`参照型または null 許容型の値が`E`は、結果は false、null。
*  それ以外の場合、`D`の動的な型を表す`E`次のようにします。
   * 場合の種類`E`、参照型では、`D`によってインスタンスの参照の実行時の型は、`E`します。
   * 場合の種類`E`が null 許容型では、 `D` null 許容型の基になる型です。
   * 場合の種類`E`null 非許容値型では、`D`の型である`E`します。
*  操作の結果が異なります`D`と`T`次のようにします。
   * 場合`T`、参照型では、結果は true 場合`D`と`T`は場合に、同じ型で`D`は、参照型からの暗黙的な参照変換`D`に`T`が存在する場合、または`D`値型からボックス化変換`D`に`T`存在します。
   * 場合`T`が null 許容型では、結果は true 場合`D`の基になる型は、`T`します。
   * 場合`T`null 非許容値型では、結果は true 場合`D`と`T`は同じ型。
   * それ以外の場合、結果は false です。

ユーザー定義変換がによっていないと見なされることに注意してください、`is`演算子。

### <a name="the-as-operator"></a>演算子として、

`as`演算子を使用して、特定の参照型または null 許容型に値を明示的に変換します。 キャスト式とは異なり ([キャスト式](expressions.md#cast-expressions))、`as`演算子が例外をスローしません。 代わりに、指定された変換ができない場合、結果の値は`null`します。

フォームの操作で`E as T`、`E`式を指定する必要がありますと`T`参照型、参照型、または null 許容型を既知の型パラメーターである必要があります。 さらに、true の場合、次の少なくとも 1 つある必要があります。 またはそれ以外の場合、コンパイル時エラーが発生します。

*  Id ([恒等変換](conversions.md#identity-conversion))、暗黙的な null 許容型 ([null 許容型の暗黙的な変換](conversions.md#implicit-nullable-conversions))、暗黙の参照 ([暗黙の参照変換](conversions.md#implicit-reference-conversions))、ボックス化 ([ボックス化変換](conversions.md#boxing-conversions)) 明示的な null 許容型 ([明示的な null 許容変換](conversions.md#explicit-nullable-conversions))、明示的な参照 ([明示的な参照変換](conversions.md#explicit-reference-conversions))、またはボックス化解除 ([ボックス化解除変換](conversions.md#unboxing-conversions)) からの変換が存在する`E`に`T`します。
*  型`E`または`T`がオープン型。
*  `E` `null`リテラル。

コンパイル時の型の場合`E`ない`dynamic`、操作`E as T`と同じ結果になります
```csharp
E is T ? (T)(E) : (T)null
```
ただし、`E` が評価されるのは 1 回だけです。 最適化するために、コンパイラが期待できます`E as T`上記の拡張が含まれる 2 つの動的な型チェックではなく多くて 1 つ動的な型チェックを実行します。

コンパイル時の型の場合`E`は`dynamic`、キャスト演算子とは異なり、`as`演算子が動的にバインドされていない ([動的バインド](expressions.md#dynamic-binding))。 そのため、拡張がここでは。
```csharp
E is T ? (T)(object)(E) : (T)null
```

ユーザー定義変換など、いくつかの変換が可能でないことに注意してください、`as`演算子と、キャスト式を使用する代わりに実行する必要があります。

例
```csharp
class X
{

    public string F(object o) {
        return o as string;        // OK, string is a reference type
    }

    public T G<T>(object o) where T: Attribute {
        return o as T;             // Ok, T has a class constraint
    }

    public U H<U>(object o) {
        return o as U;             // Error, U is unconstrained 
    }
}
```
型パラメーター`T`の`G`は、クラスの制約があるため、参照型に呼ばれます。 型パラメーター`U`の`H`ないただし。 そのための使用、`as`演算子`H`は許可されません。

## <a name="logical-operators"></a>論理演算子

`&`、 `^`、および`|`演算子は論理演算子と呼ばれます。

```antlr
and_expression
    : equality_expression
    | and_expression '&' equality_expression
    ;

exclusive_or_expression
    : and_expression
    | exclusive_or_expression '^' and_expression
    ;

inclusive_or_expression
    : exclusive_or_expression
    | inclusive_or_expression '|' exclusive_or_expression
    ;
```

論理演算子のオペランドがコンパイル時の型を持つかどうか`dynamic`、式を動的にバインドし、([動的バインド](expressions.md#dynamic-binding))。 この場合、式のコンパイル時の型は`dynamic`、コンパイル時の型を持つこれらのオペランドの実行時の型を使用して実行時に以下に示す解決が行わ`dynamic`します。

フォームの操作の`x op y`ここで、`op`論理演算子をオーバー ロードの解決のいずれか ([二項演算子のオーバー ロードの解決](expressions.md#binary-operator-overload-resolution)) を適用して特定の演算子の実装を選択します。 オペランドは、選択した演算子のパラメーターの型に変換され、結果の型が演算子の戻り値の型。

定義済みの論理演算子は、次のセクションで説明します。

### <a name="integer-logical-operators"></a>整数の論理演算子

定義済みの整数の論理演算子は次のとおりです。
```csharp
int operator &(int x, int y);
uint operator &(uint x, uint y);
long operator &(long x, long y);
ulong operator &(ulong x, ulong y);

int operator |(int x, int y);
uint operator |(uint x, uint y);
long operator |(long x, long y);
ulong operator |(ulong x, ulong y);

int operator ^(int x, int y);
uint operator ^(uint x, uint y);
long operator ^(long x, long y);
ulong operator ^(ulong x, ulong y);
```

`&`演算子はビットごとの計算論理`AND`の 2 つのオペランド、`|`演算子はビット演算を計算論理`OR`の 2 つのオペランドと`^`演算子はビットごとの排他的論理を計算`OR`の 2 つのオペランド。 オーバーフローは、これらの操作からではありません。

### <a name="enumeration-logical-operators"></a>列挙体の論理演算子

すべての列挙型`E`暗黙的に、次の定義済みの論理演算子を提供します。

```csharp
E operator &(E x, E y);
E operator |(E x, E y);
E operator ^(E x, E y);
```

評価結果`x op y`ここで、`x`と`y`列挙型の式は`E`基になる型`U`、および`op`論理演算子の 1 つと同じでは正確に評価する`(E)((U)x op (U)y)`します。 つまり、列挙型の論理演算子は、2 つのオペランドの基になる型の論理操作を実行するだけです。

### <a name="boolean-logical-operators"></a>ブール論理演算子

定義済みのブール型の論理演算子は次のとおりです。
```csharp
bool operator &(bool x, bool y);
bool operator |(bool x, bool y);
bool operator ^(bool x, bool y);
```

`x` と `y` の両方が `true` であれば、`x & y` の結果は `true` です。 それ以外の場合、結果は `false` です。

結果`x | y`は`true`場合`x`または`y`は`true`します。 それ以外の場合、結果は `false` です。

結果`x ^ y`は`true`場合`x`は`true`と`y`は`false`、または`x`は`false`と`y`は`true`します。 それ以外の場合、結果は `false` です。 型のオペランドが場合`bool`、`^`演算子と同じ結果を計算する、`!=`演算子。

### <a name="nullable-boolean-logical-operators"></a>Null 許容のブール論理演算子

Null 許容のブール型`bool?`3 つの値を表すことができます`true`、 `false`、および`null`、概念的には、SQL のブール式に使用される 3 つの値の型に似ています。 によって生成される結果を確実に、`&`と`|`演算子の`bool?`オペランドは、SQL の 3 値論理と一貫性のあるが、次の定義済みの演算子が提供は。

```csharp
bool? operator &(bool? x, bool? y);
bool? operator |(bool? x, bool? y);
```

次の表に、これらの演算子、値のすべての組み合わせによって生成される結果`true`、 `false`、および`null`します。

| `x`     | `y`     | `x & y` | <code>x &#124; y</code> |
|:-------:|:-------:|:-------:|:-------:|
| `true`  | `true`  | `true`  | `true`  | 
| `true`  | `false` | `false` | `true`  | 
| `true`  | `null`  | `null`  | `true`  | 
| `false` | `true`  | `false` | `true`  | 
| `false` | `false` | `false` | `false` | 
| `false` | `null`  | `false` | `null`  | 
| `null`  | `true`  | `null`  | `true`  | 
| `null`  | `false` | `false` | `null`  | 
| `null`  | `null`  | `null`  | `null`  | 

## <a name="conditional-logical-operators"></a>条件付き論理演算子

`&&`と`||`演算子は、条件付き論理演算子と呼ばれます。 「ショート サーキット」論理演算子と呼ばれます。

```antlr
conditional_and_expression
    : inclusive_or_expression
    | conditional_and_expression '&&' inclusive_or_expression
    ;

conditional_or_expression
    : conditional_and_expression
    | conditional_or_expression '||' conditional_and_expression
    ;
```

`&&`と`||`演算子は、条件付きのバージョンの`&`と`|`演算子。

*  操作`x && y`、操作に対応する`x & y`ことを除いて、`y`場合にのみ評価されます`x`ない`false`します。
*  操作`x || y`、操作に対応する`x | y`ことを除いて、`y`場合にのみ評価されます`x`ない`true`します。

条件付き論理演算子のオペランドがコンパイル時の型を持つかどうか`dynamic`、式を動的にバインドし、([動的バインド](expressions.md#dynamic-binding))。 この場合、式のコンパイル時の型は`dynamic`、コンパイル時の型を持つこれらのオペランドの実行時の型を使用して実行時に以下に示す解決が行わ`dynamic`します。

フォームの操作を`x && y`または`x || y`オーバー ロードの解決を適用することによって処理されます ([二項演算子のオーバー ロードの解決](expressions.md#binary-operator-overload-resolution))、操作が書き込まれた場合、`x & y`または`x | y`します。 そうしたら

*  1 つの最適な演算子を検索するオーバー ロードの解決が失敗した場合、またはオーバー ロードの解決では、定義済みの整数の論理演算子のいずれかが選択した場合は、バインド時のエラーが発生します。
*  それ以外の場合、選択した演算子が定義済みのブール型の論理演算子のいずれかである場合 ([ブール論理演算子](expressions.md#boolean-logical-operators)) または null 許容のブール論理演算子 ([null 許容のブール論理演算子](expressions.md#nullable-boolean-logical-operators))、操作が処理されるは」の説明に従って[ブール条件付き論理演算子](expressions.md#boolean-conditional-logical-operators)します。
*  それ以外の場合、選択された演算子は、ユーザー定義の演算子と」の説明に従って、操作が処理される[ユーザー定義の条件付き論理演算子](expressions.md#user-defined-conditional-logical-operators)します。

条件付き論理演算子を直接オーバー ロードすることはできません。 ただし、通常の論理演算子の観点から、条件付き論理演算子が評価されるため、通常の論理演算子のオーバー ロードは、一定の制限もと見なされます、条件付き論理演算子のオーバー ロード。 詳細についてはこの[ユーザー定義の条件付き論理演算子](expressions.md#user-defined-conditional-logical-operators)します。

### <a name="boolean-conditional-logical-operators"></a>ブール型の条件付き論理演算子

ときのオペランドは、`&&`または`||`型`bool`、や、該当する定義しない型のオペランドが`operator &`または`operator |`への暗黙的な変換を定義する操作を行いますが、`bool`操作が次のように処理されます。

*  操作`x && y`として評価されます`x ? y : false`します。 つまり、`x`が最初に評価され、型に変換する`bool`します。 その後、場合`x`は`true`、`y`が評価され、型に変換`bool`操作の結果になります。 操作の結果は、それ以外の場合、`false`します。
*  操作`x || y`として評価されます`x ? true : y`します。 つまり、`x`が最初に評価され、型に変換する`bool`します。 場合はその後、`x`は`true`、操作の結果は`true`します。 それ以外の場合、`y`が評価され、型に変換する`bool`操作の結果になります。

### <a name="user-defined-conditional-logical-operators"></a>ユーザー定義の条件付き論理演算子

ときに、オペランドの`&&`または`||`は、該当する宣言型のユーザー定義`operator &`または`operator |`、場所で true の場合、ある、次の両方必要があります`T`は選択した演算子が宣言されている型です。

*  戻り値の型と、選択した演算子の各パラメーターの型である必要があります`T`します。 つまり、演算子を論理計算`AND`または論理`OR`型の 2 つのオペランドの`T`、型の結果を返す必要があります`T`します。
*  `T` 宣言を含める必要があります`operator true`と`operator false`します。

バインディング エラーは、これらの要件のいずれかが満たされない場合に発生します。 それ以外の場合、`&&`または`||`操作は、ユーザー定義を組み合わせることによって評価されます`operator true`または`operator false`選択したユーザー定義演算子を使用します。

*  操作`x && y`として評価されます`T.false(x) ? x : T.&(x, y)`ここで、`T.false(x)`の呼び出し、`operator false`で宣言されている`T`、および`T.&(x, y)`の選択した呼び出し`operator &`します。 つまり、`x`が最初に評価および`operator false`がどうかを判断の結果に対して呼び出す`x`が確実に false。 その後、if`x`が間違いなく false の場合、操作の結果は、以前に計算値`x`します。 それ以外の場合、`y`が評価されと、選択した`operator &`が以前に計算値で呼び出される`x`計算された値と`y`操作の結果を生成します。
*  操作`x || y`として評価されます`T.true(x) ? x : T.|(x, y)`ここで、`T.true(x)`の呼び出し、`operator true`で宣言されている`T`、および`T.|(x,y)`の選択した呼び出し`operator|`します。 つまり、`x`が最初に評価および`operator true`がどうかを判断の結果に対して呼び出す`x`が確実に true です。 その後、if`x`が間違いなく true の場合、操作の結果は、以前に計算値`x`します。 それ以外の場合、`y`が評価されと、選択した`operator |`が以前に計算値で呼び出される`x`計算された値と`y`操作の結果を生成します。

これらの操作が指定された式のいずれかで`x`はによって指定された式で 1 回、評価だけ`y`はないか、評価、1 回だけ評価します。

実装する型の例については`operator true`と`operator false`を参照してください[ブール型のデータベース](structs.md#database-boolean-type)します。

## <a name="the-null-coalescing-operator"></a>Null 合体演算子

`??`演算子は、null 合体演算子と呼ばれます。

```antlr
null_coalescing_expression
    : conditional_or_expression
    | conditional_or_expression '??' null_coalescing_expression
    ;
```

フォームの場合は、null 結合式`a ?? b`必要`a`null 許容型または参照型であります。 場合`a`null 以外の場合は、結果`a ?? b`は`a`、それ以外の結果は`b`します。 操作の評価`b`場合にのみ`a`が null です。

Null 合体演算子の右から左は"右から左へ"です。 たとえば、フォームの式`a ?? b ?? c`として評価されます`a ?? (b ?? c)`します。 一般に用語、フォームの式`E1 ?? E2 ?? ... ?? En`オペランドの最初の null 以外の場合、またはすべてのオペランドが null の場合は null を返します。

式の型`a ?? b`暗黙の変換がオペランドに対して使用可能なによって異なります。 種類の優先度の順序で`a ?? b`は`A0`、 `A`、または`B`ここで、`A`の種類は、 `a` (される`a`型があります)、`B`の種類です`b`(される`b`型があります)、および`A0`の基になる型は、`A`場合`A`が null 許容型では、または`A`それ以外の場合。 具体的には、`a ?? b`ように処理されます。

*  場合`A`が存在し、ない null 許容型または参照型では、コンパイル時エラーが発生します。
*  場合`b`動的な式は、結果型は`dynamic`します。 実行時に、`a`が最初に評価します。 場合`a`が null でない`a`は、動的に変換し、これが結果になります。 それ以外の場合、`b`が評価され、結果になります。
*  の場合`A`が存在する null 許容型であり、からの暗黙的な変換が存在する`b`に`A0`、結果型は`A0`します。 実行時に、`a`が最初に評価します。 場合`a`が null でない`a`型にラップされて`A0`結果になります。 それ以外の場合、`b`が評価され、型に変換する`A0`結果になります。
*  の場合`A`が存在するからの暗黙的な変換が存在して`b`に`A`、結果型は`A`します。 実行時に、`a`が最初に評価します。 場合`a`が null でない`a`結果になります。 それ以外の場合、`b`が評価され、型に変換する`A`結果になります。
*  の場合`b`型を持つ`B`からの暗黙的な変換が存在して`a`に`B`、結果型は`B`します。 実行時に、`a`が最初に評価します。 場合`a`が null でない`a`型にラップされて`A0`(場合`A`が存在し、null 許容) と型に変換された`B`結果になります。 それ以外の場合、`b`が評価され、結果になります。
*  それ以外の場合、`a`と`b`は、互換性のないと、コンパイル時エラーが発生します。

## <a name="conditional-operator"></a>条件演算子

`?:`演算子は条件演算子と呼ばれます。 三項演算子にも呼び出されます。

```antlr
conditional_expression
    : null_coalescing_expression
    | null_coalescing_expression '?' expression ':' expression
    ;
```

フォームの条件式`b ? x : y`条件を最初に評価する`b`します。 その後、if`b`は`true`、`x`が評価され、操作の結果になります。 それ以外の場合、`y`が評価され、操作の結果になります。 条件式を決して両方評価`x`と`y`します。

条件演算子の右から左は"右から左へ"です。 たとえば、フォームの式`a ? b : c ? d : e`として評価されます`a ? b : (c ? d : e)`します。

最初のオペランド、`?:`演算子に暗黙的に変換できる式である必要があります`bool`、または実装する型の式`operator true`します。 どちらもこれらの要件が満たされている場合、コンパイル時エラーが発生します。

2 番目と 3 番目のオペランド`x`と`y`の`?:`演算子は、条件式の種類を制御します。

*  場合`x`型を持つ`X`と`y`型を持つ`Y`し
   * 暗黙の変換 ([暗黙的な変換](conversions.md#implicit-conversions)) から存在する`X`に`Y`がからではなく`Y`に`X`、し`Y`条件式の種類です。
   * 暗黙の変換 ([暗黙的な変換](conversions.md#implicit-conversions)) から存在する`Y`に`X`がからではなく`X`に`Y`、し`X`条件式の種類です。
   * それ以外の場合、式の型を決定できないと、コンパイル時エラーが発生します。
*  だけの場合のいずれかの`x`と`y`種類、およびその両方を持つ`x`と`y`の条件付きの式の型は、その型に暗黙的に変換されます。
*  それ以外の場合、式の型を決定できないと、コンパイル時エラーが発生します。

フォームの条件式の実行時の処理`b ? x : y`次の手順で構成されています。

*  最初に、`b`が評価され、および`bool`の値`b`決定されます。
   * 暗黙の変換の種類から`b`に`bool`この暗黙の変換が生成するために実行されますが、存在する、`bool`値。
   * それ以外の場合、`operator true`の型によって定義された`b`が生成するために呼び出される、`bool`値。
*  場合、`bool`前の手順で生成される値は`true`、し`x`が評価され、条件付きの式の型に変換し、条件付きの式の結果になります。
*  それ以外の場合、`y`が評価され、条件付きの式の型に変換し、条件付きの式の結果になります。

## <a name="anonymous-function-expressions"></a>匿名関数式

***匿名関数***"line"のメソッド定義を表す式を指定します。 匿名関数はありません値または型自体が互換性のあるデリゲートまたは式ツリー型に変換可能です。 匿名関数の変換の評価は、変換のターゲットの種類によって異なります。デリゲート型では、変換は、匿名関数を定義する方法を参照するデリゲート値に評価します。 式ツリー型である場合は、オブジェクトの構造体としてのメソッドの構造を表す式ツリーに変換が評価されます。

歴史的な理由は 2 つ構文種類あります匿名関数は、namely *lambda_expression*s と*anonymous_method_expression*秒。 ほぼすべての目的で、 *lambda_expression*s は簡潔でより表現力豊かな*anonymous_method_expression*で、これは下位互換性の言語で表示します。

```antlr
lambda_expression
    : anonymous_function_signature '=>' anonymous_function_body
    ;

anonymous_method_expression
    : 'delegate' explicit_anonymous_function_signature? block
    ;

anonymous_function_signature
    : explicit_anonymous_function_signature
    | implicit_anonymous_function_signature
    ;

explicit_anonymous_function_signature
    : '(' explicit_anonymous_function_parameter_list? ')'
    ;

explicit_anonymous_function_parameter_list
    : explicit_anonymous_function_parameter (',' explicit_anonymous_function_parameter)*
    ;

explicit_anonymous_function_parameter
    : anonymous_function_parameter_modifier? type identifier
    ;

anonymous_function_parameter_modifier
    : 'ref'
    | 'out'
    ;

implicit_anonymous_function_signature
    : '(' implicit_anonymous_function_parameter_list? ')'
    | implicit_anonymous_function_parameter
    ;

implicit_anonymous_function_parameter_list
    : implicit_anonymous_function_parameter (',' implicit_anonymous_function_parameter)*
    ;

implicit_anonymous_function_parameter
    : identifier
    ;

anonymous_function_body
    : expression
    | block
    ;
```

`=>` 演算子と代入 (`=`) は優先順位が同じで、結合規則が右から左です。

ある匿名関数を`async`修飾子は、非同期関数でありで説明されている規則に従って[反復子](classes.md#iterators)します。

形式で匿名関数のパラメーターを*lambda_expression*明示的または暗黙的に型指定できます。 明示的に型指定されたパラメーター リストの各パラメーターの型を明示的に宣言します。 匿名関数が発生したコンテキストから、暗黙的に型指定されたパラメーターの一覧で、パラメーターの型の推論-互換性のあるデリゲート型または型を提供する式ツリーの型、匿名関数が変換される場合に具体的には、パラメーターの型 ([匿名関数の変換](conversions.md#anonymous-function-conversions))。

1 つ、暗黙的に型指定されたパラメーターを使用して、匿名関数にパラメーター リストから、かっこは省略できます。 つまり、フォームの匿名関数
```csharp
( param ) => expr
```
省略することができます。
```csharp
param => expr
```

形式で匿名関数のパラメーター リスト、 *anonymous_method_expression*は省略可能です。 指定した場合、パラメーターを明示的に入力する必要があります。 匿名の関数は任意のパラメーターを持つデリゲートに変換できる、そうでない場合の一覧が含まれていない`out`パラメーター。

A*ブロック*匿名関数の本体に到達 ([エンドポイントと到達可能性](statements.md#end-points-and-reachability)) しない限り、匿名関数で到達できないステートメント内に発生します。

匿名関数の例をいくつかは、以下に従います。

```csharp
x => x + 1                              // Implicitly typed, expression body
x => { return x + 1; }                  // Implicitly typed, statement body
(int x) => x + 1                        // Explicitly typed, expression body
(int x) => { return x + 1; }            // Explicitly typed, statement body
(x, y) => x * y                         // Multiple parameters
() => Console.WriteLine()               // No parameters
async (t1,t2) => await t1 + await t2    // Async
delegate (int x) { return x + 1; }      // Anonymous method expression
delegate { return 1 + 1; }              // Parameter list omitted
```

動作*lambda_expression*s と*anonymous_method_expression*s は、次の点を除けば同じです。

*  *anonymous_method_expression*s 許可を完全に省略パラメーター リストでもデリゲート パラメーターの値の一覧の型を生成します。
*  *lambda_expression*s パラメーターの型は省略され、一方の推論を許可する*anonymous_method_expression*s がパラメーターの型を明示的に指定する必要があります。
*  本文を*lambda_expression*は式またはステートメント ブロックを指定できますの本文を*anonymous_method_expression*ステートメント ブロックにする必要があります。
*  のみ*lambda_expression*s がある互換性のある式ツリー型への変換 ([式ツリー型](types.md#expression-tree-types))。

### <a name="anonymous-function-signatures"></a>匿名関数のシグネチャ

省略可能な*anonymous_function_signature*匿名関数の名前と必要に応じて、匿名関数の仮パラメーターの種類を定義します。 匿名関数のパラメーターのスコープは、 *anonymous_function_body*します。 ([スコープ](basic-concepts.md#scopes)) 匿名メソッド本体の宣言領域の構成 (指定された) 場合は、パラメーター リストと共に ([宣言](basic-concepts.md#declarations))。 ローカル変数、ローカル定数またはそのスコープに含まれるパラメーターの名前と一致する匿名関数のパラメーターの名前のコンパイル時エラーであるため、 *anonymous_method_expression*または*lambda_式*します。

匿名関数がある場合、 *explicit_anonymous_function_signature*、互換性のあるデリゲート型と式ツリー型のセットは同じ順序で、同じパラメーターの型および修飾子を持つものに制限されています。 メソッド グループ変換とは対照的 ([メソッド グループ変換](conversions.md#method-group-conversions))、匿名関数のパラメーター型の反変性がサポートされていません。 匿名関数がない場合、 *anonymous_function_signature*、互換性のあるデリゲート型と式ツリー型のセットがないものだけに制限し、`out`パラメーター。

なお、 *anonymous_function_signature*属性またはパラメーター配列に含めることはできません。 ただし、 *anonymous_function_signature*パラメーター リスト持つにはには、パラメーター配列が含まれています。 デリゲート型と互換性があります。

互換性のあるがコンパイル時に引き続き失敗する場合でも、式ツリー型に変換をまた ([式ツリー型](types.md#expression-tree-types))。

### <a name="anonymous-function-bodies"></a>匿名関数の本体

本文 (*式*または*ブロック*) 匿名関数は、次の規則に従います。

*  匿名関数には、署名が含まれている場合、シグネチャで指定されたパラメーターは本体で使用できます。 デリゲート型またはパラメーターを持つ式の型に変換できる場合は、匿名関数のシグネチャはありません ([匿名関数の変換](conversions.md#anonymous-function-conversions)) が、パラメーターは、本文にアクセスできません。
*  除く`ref`または`out`最も外側の署名 (存在する場合) で指定されたパラメーター、コンパイル時エラー、本文にアクセスするには匿名関数を`ref`または`out`パラメーター。
*  ときの種類`this`、構造体型には、コンパイル時エラー、本文にアクセスするには`this`します。 これは true かどうか、アクセスが明示的な (としてで`this.x`) または暗黙的な (と`x`場所`x`構造体のインスタンス メンバー)。 単に、このルールは、このようなアクセスを禁止し、メンバーの検索結果、構造体のメンバーであるかどうかには影響しません。
*  本体が外側の変数へのアクセス ([外部変数](expressions.md#outer-variables)) 匿名関数の。 外部変数へのアクセスは、一度にアクティブになっている変数のインスタンスを参照、 *lambda_expression*または*anonymous_method_expression*が評価されます ([の評価匿名関数式](expressions.md#evaluation-of-anonymous-function-expressions))。
*  コンパイル時エラーを含む本文には、`goto`ステートメントでは、`break`ステートメント、または`continue`対象である、本文の外側、または含まれている匿名関数の本体内のステートメント。
*  A`return`本体のステートメントでは、最も近い外側の呼び出しから制御を返します、外側の関数メンバーからではなく、匿名関数です。 指定された式を`return`ステートメントは、デリゲート型または式ツリー型の戻り値の型に暗黙的に変換可能である必要があります囲む最も近い*lambda_expression*または*anonymous_method_expression*変換されます ([匿名関数の変換](conversions.md#anonymous-function-conversions))。

評価版の呼び出しから以外の匿名関数のブロックを実行する方法があるかどうかは明示的に指定されていません、 *lambda_expression*または*anonymous_method_expression*. 具体的には、コンパイラが 1 つを合成することで、匿名関数を実装することをまたは以上の名前付きメソッドまたは型。 このような合成要素の名前は、コンパイラを使用するために予約された形式でなければなりません。

### <a name="overload-resolution-and-anonymous-functions"></a>オーバー ロードの解決と匿名関数

匿名関数の引数リストでは、型の推定に参加し、オーバー ロードの解決。 参照してください[型推論](expressions.md#type-inference)と[オーバー ロードの解決](expressions.md#overload-resolution)の厳密な規則です。

次の例は、匿名関数のオーバー ロードの解決への影響を示しています。

```csharp
class ItemList<T>: List<T>
{
    public int Sum(Func<T,int> selector) {
        int sum = 0;
        foreach (T item in this) sum += selector(item);
        return sum;
    }

    public double Sum(Func<T,double> selector) {
        double sum = 0;
        foreach (T item in this) sum += selector(item);
        return sum;
    }
}
```

`ItemList<T>`クラスには 2 つ`Sum`メソッド。 それぞれ、`selector`引数で、リスト項目から経由での合計に値を抽出します。 抽出された値には、いずれかを指定できます、`int`または`double`し、結果の合計は、いずれかでも同様に、`int`または`double`します。

`Sum`リストの順序の詳細行の合計を計算するメソッドを使用例でした。

```csharp
class Detail
{
    public int UnitCount;
    public double UnitPrice;
    ...
}

void ComputeSums() {
    ItemList<Detail> orderDetails = GetOrderDetails(...);
    int totalUnits = orderDetails.Sum(d => d.UnitCount);
    double orderTotal = orderDetails.Sum(d => d.UnitPrice * d.UnitCount);
    ...
}
```

最初の呼び出しで`orderDetails.Sum`の両方を`Sum`メソッドは、適用可能なため、匿名関数`d => d. UnitCount`は両方と互換性が`Func<Detail,int>`と`Func<Detail,double>`します。 ただし、オーバー ロードの解決が最初に検出`Sum`メソッドのためへの変換`Func<Detail,int>`への変換よりも優れて`Func<Detail,double>`します。

2 つ目の呼び出しで`orderDetails.Sum`し、2 番目`Sum`メソッドは、適用可能なため、匿名関数`d => d.UnitPrice * d.UnitCount`型の値を生成`double`します。 したがって、オーバー ロードの解決は、2 つ目を取得`Sum`その呼び出しのメソッド。

### <a name="anonymous-functions-and-dynamic-binding"></a>匿名関数と動的バインディング

匿名関数は、受信者、引数または動的に連結演算のオペランドにすることはできません。

### <a name="outer-variables"></a>外部変数

任意のローカル変数、パラメーターの値、またはがスコープに含まれるパラメーター配列、 *lambda_expression*または*anonymous_method_expression*と呼ばれますが、***外部変数***匿名関数です。 クラスのインスタンス関数のメンバーで、`this`値が値を持つパラメーターと見なされ、関数メンバー内に含まれるすべての匿名関数の外部変数は、します。

#### <a name="captured-outer-variables"></a>外部変数のキャプチャ

外部変数は、匿名関数によって参照される、外部変数があると言います。***キャプチャ***によって匿名関数です。 通常、ローカル変数の有効期間は、ブロックまたはそれが関連付けられているステートメントの実行に制限されています ([ローカル変数](variables.md#local-variables))。 ただし、キャプチャされた外部変数の有効期間は、デリゲートまで少なくとも拡張または匿名関数から作成された式ツリーがガベージ コレクションの対象になります。

例
```csharp
using System;

delegate int D();

class Test
{
    static D F() {
        int x = 0;
        D result = () => ++x;
        return result;
    }

    static void Main() {
        D d = F();
        Console.WriteLine(d());
        Console.WriteLine(d());
        Console.WriteLine(d());
    }
}
```
ローカル変数`x`は匿名の関数との有効期間によってキャプチャ`x`から返されたデリゲートまで少なくとも拡張`F`(の末尾まで発生しませんが、ガベージ コレクションの対象になります。プログラム)。 匿名関数の呼び出しごとの動作の同じインスタンスであるため`x`例の出力には。
```
1
2
3
```

匿名関数によって、ローカル変数または値を持つパラメーターがキャプチャされると、ローカル変数またはパラメーターは不要になったと見なされます固定変数 ([固定属性と移動可能変数](unsafe-code.md#fixed-and-moveable-variables)) は代わりに、移動可能と見なされますが、変数。 したがって、`unsafe`キャプチャされた外部変数のアドレスを取得するコードを使用する必要があります最初、`fixed`ステートメント、変数を解決します。

なお uncaptured の変数とは異なり、キャプチャされたローカル変数を複数の実行スレッドを同時に公開できます。

#### <a name="instantiation-of-local-variables"></a>ローカル変数のインスタンス化

ローカル変数があると見なされます***インスタンス化***実行が、変数のスコープに入ったとき。 次のメソッドの呼び出し時に、ローカル変数など、`x`がインスタンス化され、3 回の初期化など、ループの反復ごとに 1 回。

```csharp
static void F() {
    for (int i = 0; i < 3; i++) {
        int x = i * 2 + 1;
        ...
    }
}
```

ただしの宣言の移動`x`に 1 つのインスタンス化のループの外側`x`:
```csharp
static void F() {
    int x;
    for (int i = 0; i < 3; i++) {
        x = i * 2 + 1;
        ...
    }
}
```

キャプチャされていないときに、ローカル変数がインスタンス化される正確にどのくらいの頻度を確認する方法はありません: インスタンス化の有効期間が互いに離れて、ため、単に同じストレージの場所を使用するには、各インスタンスのことができます。 ただし、ローカル変数をキャプチャする匿名関数をインスタンス化の効果は明らかになります。

例では、
```csharp
using System;

delegate void D();

class Test
{
    static D[] F() {
        D[] result = new D[3];
        for (int i = 0; i < 3; i++) {
            int x = i * 2 + 1;
            result[i] = () => { Console.WriteLine(x); };
        }
        return result;
    }

    static void Main() {
        foreach (D d in F()) d();
    }
}
```
この例では、次のように出力されます。
```
1
3
5
```

ただしの宣言`x`ループの外側に移動されます。
```csharp
static D[] F() {
    D[] result = new D[3];
    int x;
    for (int i = 0; i < 3; i++) {
        x = i * 2 + 1;
        result[i] = () => { Console.WriteLine(x); };
    }
    return result;
}
```
出力は次のとおりです。
```
5
5
5
```

For ループでは、繰り返し変数を宣言すると、その変数自体をループの外で宣言すると見なされます。 したがって、自体の反復変数をキャプチャする例を変更した場合。

```csharp
static D[] F() {
    D[] result = new D[3];
    for (int i = 0; i < 3; i++) {
        result[i] = () => { Console.WriteLine(i); };
    }
    return result;
}
```
反復変数の 1 つだけのインスタンスをキャプチャしたら、出力が生成されます。
```
3
3
3
```

匿名関数のデリゲートは、いくつかのキャプチャされた変数を共有しながら他のユーザーの別のインスタンスがあることができます。 たとえば場合、`F`に変更されます
```csharp
static D[] F() {
    D[] result = new D[3];
    int x = 0;
    for (int i = 0; i < 3; i++) {
        int y = 0;
        result[i] = () => { Console.WriteLine("{0} {1}", ++x, ++y); };
    }
    return result;
}
```
3 つのデリゲートの同じインスタンスをキャプチャする`x`がのインスタンスを区切る`y`出力は。
```
1 1
2 1
3 1
```

個別の匿名関数には、外部変数の同じインスタンスをキャプチャできます。 次に例を示します。
```csharp
using System;

delegate void Setter(int value);

delegate int Getter();

class Test
{
    static void Main() {
        int x = 0;
        Setter s = (int value) => { x = value; };
        Getter g = () => { return x; };
        s(5);
        Console.WriteLine(g());
        s(10);
        Console.WriteLine(g());
    }
}
```
2 つの匿名関数は、ローカル変数の同じインスタンスをキャプチャ`x`、したがって「通信できる」変数を通じてとします。 この例の出力は次のとおりです。
```
5
10
```

### <a name="evaluation-of-anonymous-function-expressions"></a>匿名関数式の評価

匿名関数`F`常にデリゲート型に変換する必要があります`D`または式ツリー型`E`、直接、またはデリゲート作成式の実行により`new D(F)`します。 」の説明に従って、この変換は、匿名関数の結果を決定します。[匿名関数の変換](conversions.md#anonymous-function-conversions)します。

## <a name="query-expressions"></a>クエリ式

***クエリ式***SQL や XQuery などのリレーショナルで階層的なクエリ言語に類似したクエリに対して統合言語の構文を提供します。

```antlr
query_expression
    : from_clause query_body
    ;

from_clause
    : 'from' type? identifier 'in' expression
    ;

query_body
    : query_body_clauses? select_or_group_clause query_continuation?
    ;

query_body_clauses
    : query_body_clause
    | query_body_clauses query_body_clause
    ;

query_body_clause
    : from_clause
    | let_clause
    | where_clause
    | join_clause
    | join_into_clause
    | orderby_clause
    ;

let_clause
    : 'let' identifier '=' expression
    ;

where_clause
    : 'where' boolean_expression
    ;

join_clause
    : 'join' type? identifier 'in' expression 'on' expression 'equals' expression
    ;

join_into_clause
    : 'join' type? identifier 'in' expression 'on' expression 'equals' expression 'into' identifier
    ;

orderby_clause
    : 'orderby' orderings
    ;

orderings
    : ordering (',' ordering)*
    ;

ordering
    : expression ordering_direction?
    ;

ordering_direction
    : 'ascending'
    | 'descending'
    ;

select_or_group_clause
    : select_clause
    | group_clause
    ;

select_clause
    : 'select' expression
    ;

group_clause
    : 'group' expression 'by' expression
    ;

query_continuation
    : 'into' identifier query_body
    ;
```

クエリ式の始まりを`from`句といずれかで終わる、`select`または`group`句。 初期`from`句の後に 0 個以上をできます`from`、 `let`、 `where`、`join`または`orderby`句。 各`from`句は、ジェネレーターの概要、***範囲変数***の要素範囲を***シーケンス***します。 各`let`句には前の範囲変数を使用して計算値を表す範囲変数が導入されています。 各`where`句は結果から項目を除外するフィルター。 各`join`句がソース シーケンスの指定のキーと一致するペアを生成するもう 1 つのシーケンスのキーを比較します。 各`orderby`句が指定した条件に従って項目を並べ替えます。最終的な`select`または`group`句は、範囲変数の観点から結果の形状を指定します。 最後に、`into`句は、1 つのクエリの結果を後続のクエリでのジェネレーターとして扱うことでクエリを「接続」を使用できます。

### <a name="ambiguities-in-query-expressions"></a>クエリ式のあいまいさ

クエリ式には、「コンテキスト キーワード」、つまりを特定のコンテキストで特別な意味を持つ識別子の数が含まれています。 具体的には、これらは`from`、 `where`、 `join`、 `on`、 `equals`、 `into`、 `let`、 `orderby`、 `ascending`、 `descending`、 `select`、`group`と`by`. キーワードまたは簡易名としてこれらの識別子の混在の使用によって発生するクエリ式のあいまいさを回避するためにこれらの識別子はキーワード時に考慮クエリ式内で任意の場所に発生します。

この目的では、クエリ式は任意の式で始まる"`from identifier`「を除く任意のトークンが続く」`;`「,」`=`「または」`,`"。

クエリ式内で識別子としてこれらの単語を使用するには、先頭"`@`"([識別子](lexical-structure.md#identifiers))。

### <a name="query-expression-translation"></a>クエリ式の変換

C# 言語では、クエリ式の実行のセマンティクスが指定されていません。 代わりに、クエリ式に準拠しているメソッドの呼び出しに変換、*クエリ式パターン*([、クエリ式パターン](expressions.md#the-query-expression-pattern))。 具体的には、クエリ式は、名前付きメソッドの呼び出しに変換`Where`、 `Select`、 `SelectMany`、 `Join`、 `GroupJoin`、 `OrderBy`、 `OrderByDescending`、 `ThenBy`、 `ThenByDescending`、 `GroupBy`、および`Cast`します。」の説明に従って、これらのメソッドが特定のシグネチャと結果型が予想される[、クエリ式パターン](expressions.md#the-query-expression-pattern)します。 これらのメソッドは、クエリ対象のオブジェクトのインスタンス メソッドまたは外部のオブジェクトにある拡張メソッドを指定でき、クエリの実際の実行を実装します。

クエリ式からのメソッド呼び出しへの変換は、型のバインディングの前に発生した構文マップまたはオーバー ロードの解決が実行されています。 構文的に正しい変換のことが保証されますが、意味的に正しい C# コードを生成するためには保証されません。 次のクエリ式の変換は、通常のメソッドの呼び出しとして処理されます結果として得られるメソッドの呼び出しをこの可能性がありますさらに発見し、エラーの例では、メソッドが存在しない場合、引数が正しくない型を持つ場合、またはメソッドがジェネリックの場合、。型の推論は失敗します。

クエリ式は、考えられるさらなる削減がなくなるまで繰り返し次の変換を適用することで処理されます。 翻訳は、アプリケーションの順序で並んでいる: 各セクションでは、前のセクションで翻訳が徹底的に、実行されることと、不足すると後、セクションがいない後で再訪問する同じクエリ式の処理に前提としています。

クエリ式では、範囲変数に代入することはできません。 ただし、C# の実装は、常にではありませんので、これも不可能になるここに示す構文変換の方法で、この制限を適用する許可されます。

特定の翻訳によって示される透過的な識別子を持つ範囲変数に挿入`*`します。 透過的な識別子の特殊なプロパティの説明でさらに[透過的識別子](expressions.md#transparent-identifiers)します。

#### <a name="select-and-groupby-clauses-with-continuations"></a>継続を選択し、groupby 句

連続したクエリ式
```csharp
from ... into x ...
```
変換されます。
```csharp
from x in ( from ... ) ...
```

次のセクションでの翻訳がクエリされていないことを想定しています`into`継続します。

例では、
```csharp
from c in customers
group c by c.Country into g
select new { Country = g.Key, CustCount = g.Count() }
```
変換されます。
```csharp
from g in
    from c in customers
    group c by c.Country
select new { Country = g.Key, CustCount = g.Count() }
```
最終的な変換は、します。
```csharp
customers.
GroupBy(c => c.Country).
Select(g => new { Country = g.Key, CustCount = g.Count() })
```

#### <a name="explicit-range-variable-types"></a>明示的な範囲変数の型

A`from`範囲変数の型を明示的に指定する句
```csharp
from T x in e
```
変換されます。
```csharp
from x in ( e ) . Cast < T > ( )
```

A`join`範囲変数の型を明示的に指定する句
```
join T x in e on k1 equals k2
```
変換されます。
```
join x in ( e ) . Cast < T > ( ) on k1 equals k2
```

次のセクションでの翻訳では、クエリに明示的な範囲変数の型があるないことを前提としています。

例では、
```csharp
from Customer c in customers
where c.City == "London"
select c
```
変換されます。
```csharp
from c in customers.Cast<Customer>()
where c.City == "London"
select c
```
最終的な変換は、します。
```csharp
customers.
Cast<Customer>().
Where(c => c.City == "London")
```

明示的な範囲変数の型は、非ジェネリックを実装するコレクションを照会するための便利な`IEnumerable`インターフェイスがジェネリックではない`IEnumerable<T>`インターフェイス。 上記の例では、となり場合`customers`型の`ArrayList`します。

#### <a name="degenerate-query-expressions"></a>逆クエリ式

形式のクエリ式
```csharp
from x in e select x
```
変換されます。
```csharp
( e ) . Select ( x => x )
```

例では、
```csharp
from c in customers
select c
```
変換されます。
```csharp
customers.Select(c => c)
```

逆クエリ式では、普通に元の要素を選択する 1 つです。 翻訳の後のフェーズでは、逆のクエリには、ソースで置き換えることで、その他の翻訳の手順で導入されたを削除します。 こと、クエリの結果を確認するは決して自体には、ソース オブジェクトに式の種類とソースの id を明らかに、クエリのクライアント。 そのため、この手順が明示的に呼び出すことによって、ソース コードに直接書き込まれた逆のクエリを保護`Select`ソース。 実装側の役目です`Select`とこれらのメソッドが、ソース オブジェクト自体を返さないことを確認するには、その他のクエリ演算子。

#### <a name="from-let-where-join-and-orderby-clauses"></a>Let、where、結合と orderby 句

2 番目のクエリ式`from`句が続く、`select`句
```csharp
from x1 in e1
from x2 in e2
select v
```
変換されます。
```csharp
( e1 ) . SelectMany( x1 => e2 , ( x1 , x2 ) => v )
```

2 番目のクエリ式`from`句が以外のものに後に、`select`句。

```csharp
from x1 in e1
from x2 in e2
...
```
変換されます。
```csharp
from * in ( e1 ) . SelectMany( x1 => e2 , ( x1 , x2 ) => new { x1 , x2 } )
...
```

クエリ式、`let`句
```csharp
from x in e
let y = f
...
```
変換されます。
```csharp
from * in ( e ) . Select ( x => new { x , y = f } )
...
```

クエリ式、`where`句
```csharp
from x in e
where f
...
```
変換されます。
```csharp
from x in ( e ) . Where ( x => f )
...
```

クエリ式、`join`句なしで、`into`続けて、`select`句
```csharp
from x1 in e1
join x2 in e2 on k1 equals k2
select v
```
変換されます。
```csharp
( e1 ) . Join( e2 , x1 => k1 , x2 => k2 , ( x1 , x2 ) => v )
```

クエリ式、`join`句なしで、`into`以外のものによってその後に、`select`句
```csharp
from x1 in e1
join x2 in e2 on k1 equals k2
...
```
変換されます。
```csharp
from * in ( e1 ) . Join( e2 , x1 => k1 , x2 => k2 , ( x1 , x2 ) => new { x1 , x2 })
...
```

クエリ式、`join`句、`into`続けて、`select`句
```csharp
from x1 in e1
join x2 in e2 on k1 equals k2 into g
select v
```
変換されます。
```csharp
( e1 ) . GroupJoin( e2 , x1 => k1 , x2 => k2 , ( x1 , g ) => v )
```

クエリ式、`join`句、`into`以外のものによってその後に、`select`句
```csharp
from x1 in e1
join x2 in e2 on k1 equals k2 into g
...
```
変換されます。
```csharp
from * in ( e1 ) . GroupJoin( e2 , x1 => k1 , x2 => k2 , ( x1 , g ) => new { x1 , g })
...
```

クエリ式、`orderby`句
```csharp
from x in e
orderby k1 , k2 , ..., kn
...
```
変換されます。
```csharp
from x in ( e ) . 
OrderBy ( x => k1 ) . 
ThenBy ( x => k2 ) .
... .
ThenBy ( x => kn )
...
```

句を指定している場合は、順序付け、`descending`方向インジケーターの呼び出しが、`OrderByDescending`または`ThenByDescending`代わりに生成されます。

次の変換があることを想定していますありません`let`、 `where`、`join`または`orderby`句、および 1 つ初期`from`各クエリ式の句。

例では、
```csharp
from c in customers
from o in c.Orders
select new { c.Name, o.OrderID, o.Total }
```
変換されます。
```csharp
customers.
SelectMany(c => c.Orders,
     (c,o) => new { c.Name, o.OrderID, o.Total }
)
```

例では、
```csharp
from c in customers
from o in c.Orders
orderby o.Total descending
select new { c.Name, o.OrderID, o.Total }
```
変換されます。
```csharp
from * in customers.
    SelectMany(c => c.Orders, (c,o) => new { c, o })
orderby o.Total descending
select new { c.Name, o.OrderID, o.Total }
```
最終的な変換は、します。
```csharp
customers.
SelectMany(c => c.Orders, (c,o) => new { c, o }).
OrderByDescending(x => x.o.Total).
Select(x => new { x.c.Name, x.o.OrderID, x.o.Total })
```
場所`x`アクセスは、それ以外の場合、コンパイラによって生成された識別子です。

例では、
```csharp
from o in orders
let t = o.Details.Sum(d => d.UnitPrice * d.Quantity)
where t >= 1000
select new { o.OrderID, Total = t }
```
変換されます。
```csharp
from * in orders.
    Select(o => new { o, t = o.Details.Sum(d => d.UnitPrice * d.Quantity) })
where t >= 1000 
select new { o.OrderID, Total = t }
```
最終的な変換は、します。
```csharp
orders.
Select(o => new { o, t = o.Details.Sum(d => d.UnitPrice * d.Quantity) }).
Where(x => x.t >= 1000).
Select(x => new { x.o.OrderID, Total = x.t })
```
場所`x`アクセスは、それ以外の場合、コンパイラによって生成された識別子です。

例では、
```csharp
from c in customers
join o in orders on c.CustomerID equals o.CustomerID
select new { c.Name, o.OrderDate, o.Total }
```
変換されます。
```csharp
customers.Join(orders, c => c.CustomerID, o => o.CustomerID,
    (c, o) => new { c.Name, o.OrderDate, o.Total })
```

例では、
```csharp
from c in customers
join o in orders on c.CustomerID equals o.CustomerID into co
let n = co.Count()
where n >= 10
select new { c.Name, OrderCount = n }
```
変換されます。
```csharp
from * in customers.
    GroupJoin(orders, c => c.CustomerID, o => o.CustomerID,
        (c, co) => new { c, co })
let n = co.Count()
where n >= 10 
select new { c.Name, OrderCount = n }
```
最終的な変換は、します。
```csharp
customers.
GroupJoin(orders, c => c.CustomerID, o => o.CustomerID,
    (c, co) => new { c, co }).
Select(x => new { x, n = x.co.Count() }).
Where(y => y.n >= 10).
Select(y => new { y.x.c.Name, OrderCount = y.n)
```
場所`x`と`y`は非表示とアクセスできない、それ以外の場合はコンパイラによって生成された識別子です。

例では、
```csharp
from o in orders
orderby o.Customer.Name, o.Total descending
select o
```
最終的な変換には
```csharp
orders.
OrderBy(o => o.Customer.Name).
ThenByDescending(o => o.Total)
```

#### <a name="select-clauses"></a>Select 句

形式のクエリ式
```csharp
from x in e select v
```
変換されます。
```csharp
( e ) . Select ( x => v )
```
v が識別子の場合を除き、x、翻訳は単に
```csharp
( e )
```

次に例を示します。
```csharp
from c in customers.Where(c => c.City == "London")
select c
```
単に変換されます。
```csharp
customers.Where(c => c.City == "London")
```

#### <a name="groupby-clauses"></a>Groupby 句

形式のクエリ式
```csharp
from x in e group v by k
```
変換されます。
```csharp
( e ) . GroupBy ( x => k , x => v )
```
v が識別子の場合を除き、x、翻訳は、
```csharp
( e ) . GroupBy ( x => k )
```

例では、
```csharp
from c in customers
group c.Name by c.Country
```
変換されます。
```csharp
customers.
GroupBy(c => c.Country, c => c.Name)
```

#### <a name="transparent-identifiers"></a>透過的な識別子

特定の翻訳を持つ範囲変数を挿入する***透過的識別子***によって示される`*`します。 透過的な識別子は、適切な言語機能です。クエリ式の変換処理では中間の手順としてのみ存在するとします。

クエリ変換では、透過的な識別子を挿入、ときに、変換の手順は匿名関数と匿名オブジェクト初期化子に透過識別子を伝達さらに。 これらのコンテキストでは、透過的な識別子は、次の動作をあります。

*  透過識別子が、匿名関数にパラメーターとして発生したときに、関連付けられている匿名型のメンバーは自動的に匿名関数の本体のスコープ。
*  透過的な識別子を持つメンバーがスコープ内にある場合、そのメンバーのメンバーは、スコープもになります。
*  透過的な識別子は、匿名オブジェクト初期化子のメンバー宣言子としてときに、透過的な識別子を持つメンバーが導入されています。
*  上記で説明した変換の手順で透過的な識別子は常に 1 つのオブジェクトのメンバーとして複数の範囲変数をキャプチャする目的で、匿名型と共に導入されました。 C# の実装は、匿名型よりも、別のメカニズムを使用して、複数の範囲変数をグループ化する許可されます。 次の変換の例には、匿名型を使用して透明度の識別子を表示することが前提としていますから変換できます。

例では、
```csharp
from c in customers
from o in c.Orders
orderby o.Total descending
select new { c.Name, o.Total }
```
変換されます。
```csharp
from * in customers.
    SelectMany(c => c.Orders, (c,o) => new { c, o })
orderby o.Total descending
select new { c.Name, o.Total }
```

これはさらに変換されます。
```csharp
customers.
SelectMany(c => c.Orders, (c,o) => new { c, o }).
OrderByDescending(* => o.Total).
Select(* => new { c.Name, o.Total })
```
、透過的な識別子が消去されると、ときに、
```csharp
customers.
SelectMany(c => c.Orders, (c,o) => new { c, o }).
OrderByDescending(x => x.o.Total).
Select(x => new { x.c.Name, x.o.Total })
```
場所`x`アクセスは、それ以外の場合、コンパイラによって生成された識別子です。

例では、
```csharp
from c in customers
join o in orders on c.CustomerID equals o.CustomerID
join d in details on o.OrderID equals d.OrderID
join p in products on d.ProductID equals p.ProductID
select new { c.Name, o.OrderDate, p.ProductName }
```
変換されます。
```csharp
from * in customers.
    Join(orders, c => c.CustomerID, o => o.CustomerID, 
        (c, o) => new { c, o })
join d in details on o.OrderID equals d.OrderID
join p in products on d.ProductID equals p.ProductID
select new { c.Name, o.OrderDate, p.ProductName }
```
これはさらに縮小
```csharp
customers.
Join(orders, c => c.CustomerID, o => o.CustomerID, (c, o) => new { c, o }).
Join(details, * => o.OrderID, d => d.OrderID, (*, d) => new { *, d }).
Join(products, * => d.ProductID, p => p.ProductID, (*, p) => new { *, p }).
Select(* => new { c.Name, o.OrderDate, p.ProductName })
```
最終的な変換は、します。
```csharp
customers.
Join(orders, c => c.CustomerID, o => o.CustomerID,
    (c, o) => new { c, o }).
Join(details, x => x.o.OrderID, d => d.OrderID,
    (x, d) => new { x, d }).
Join(products, y => y.d.ProductID, p => p.ProductID,
    (y, p) => new { y, p }).
Select(z => new { z.y.x.c.Name, z.y.x.o.OrderDate, z.p.ProductName })
```
場所`x`、 `y`、および`z`は非表示とアクセスできない、それ以外の場合はコンパイラによって生成された識別子です。

### <a name="the-query-expression-pattern"></a>クエリ式パターン

***クエリ式パターン***型は、クエリ式をサポートするために実装できるメソッドのパターンを確立します。 クエリ式は、構文のマップを使用して、メソッドの呼び出しに変換は、ために、かなり柔軟にクエリ式パターンを実装する方法がある型。 たとえば、パターンのメソッド実装できますインスタンス メソッド、または拡張メソッドとして、2 つが、同じ呼び出し構文があるため、匿名関数は両方に変換するために、メソッドがデリゲートまたは式ツリーを要求できます。

ジェネリック型の推奨される図形`C<T>`をサポートする、クエリ式パターンを次に示します。 ジェネリック型は、パラメーターと結果の型の間で、適切な関係を説明するために使用されますが、非ジェネリック型に同様のパターンを実装することは。

```csharp
delegate R Func<T1,R>(T1 arg1);

delegate R Func<T1,T2,R>(T1 arg1, T2 arg2);

class C
{
    public C<T> Cast<T>();
}

class C<T> : C
{
    public C<T> Where(Func<T,bool> predicate);

    public C<U> Select<U>(Func<T,U> selector);

    public C<V> SelectMany<U,V>(Func<T,C<U>> selector,
        Func<T,U,V> resultSelector);

    public C<V> Join<U,K,V>(C<U> inner, Func<T,K> outerKeySelector,
        Func<U,K> innerKeySelector, Func<T,U,V> resultSelector);

    public C<V> GroupJoin<U,K,V>(C<U> inner, Func<T,K> outerKeySelector,
        Func<U,K> innerKeySelector, Func<T,C<U>,V> resultSelector);

    public O<T> OrderBy<K>(Func<T,K> keySelector);

    public O<T> OrderByDescending<K>(Func<T,K> keySelector);

    public C<G<K,T>> GroupBy<K>(Func<T,K> keySelector);

    public C<G<K,E>> GroupBy<K,E>(Func<T,K> keySelector,
        Func<T,E> elementSelector);
}

class O<T> : C<T>
{
    public O<T> ThenBy<K>(Func<T,K> keySelector);

    public O<T> ThenByDescending<K>(Func<T,K> keySelector);
}

class G<K,T> : C<T>
{
    public K Key { get; }
}
```

上記のメソッドを使用して、汎用デリゲート型`Func<T1,R>`と`Func<T1,T2,R>`が、でした同様が他のデリゲートまたは式ツリー型と共に使用パラメーターと結果の種類で同じリレーションシップ。

推奨の関係に注意してください`C<T>`と`O<T>`を確実、`ThenBy`と`ThenByDescending`メソッドがの結果でのみ使用できますが、`OrderBy`または`OrderByDescending`します。 また、推奨される図形の結果の`GroupBy`--各内部シーケンスに追加して、シーケンスのシーケンス`Key`プロパティ。

`System.Linq`名前空間を実装する任意の型のクエリ演算子のパターンの実装を提供する、`System.Collections.Generic.IEnumerable<T>`インターフェイス。

## <a name="assignment-operators"></a>代入演算子

代入演算子は、変数、プロパティ、イベント、またはインデクサーの要素を新しい値を割り当てます。

```antlr
assignment
    : unary_expression assignment_operator expression
    ;

assignment_operator
    : '='
    | '+='
    | '-='
    | '*='
    | '/='
    | '%='
    | '&='
    | '|='
    | '^='
    | '<<='
    | right_shift_assignment
    ;
```

代入式の左側のオペランドは、変数、プロパティ アクセス、インデクサー アクセス、またはイベント アクセスとして分類される式である必要があります。

`=`演算子が呼び出される、***単純代入演算子***します。 左側のオペランドで指定されている変数、プロパティ、またはインデクサーの要素に右側のオペランドの値を割り当てます。 単純な代入演算子の左側のオペランドをイベント アクセスできない可能性があります (」に記載されていない限り[フィールドのようなイベント](classes.md#field-like-events))。 単純な代入演算子が記載[単純な代入](expressions.md#simple-assignment)します。

以外の代入演算子、`=`演算子を呼び出す、***複合代入演算子***します。 これらの演算子は、2 つのオペランドで指定された操作を実行し、左側のオペランドで指定されている変数、プロパティ、またはインデクサーの要素に、結果の値を割り当てます。 複合代入演算子が記載されて[複合代入](expressions.md#compound-assignment)します。

`+=`と`-=`イベントへのアクセス式で、左側のオペランドと演算子が呼び出されます、*イベント代入演算子*します。 その他の代入演算子はありません、イベントのアクセス権を持つ有効な左側のオペランドとして。 イベントの代入演算子が記載されて[イベント割り当て](expressions.md#event-assignment)します。

代入演算子が右から左の操作が右から左にまとめられていることを意味します。 たとえば、フォームの式`a = b = c`として評価されます`a = (b = c)`します。

### <a name="simple-assignment"></a>単純代入

`=`演算子は、単純な代入演算子と呼ばれます。

フォームの単純な代入の左辺のオペランドが`E.P`または`E[Ei]`場所`E`コンパイル時の型を持つ`dynamic`、割り当てが動的にバインドし、([動的バインド](expressions.md#dynamic-binding))。 この場合、代入式のコンパイル時の型は`dynamic`の実行時の型に基づいて実行時に以下に示す解決が行わ`E`します。

単純な代入では、右側のオペランドが左のオペランドの型に暗黙的に変換する式必要があります。 操作は、左側のオペランドで指定されている変数、プロパティ、またはインデクサーの要素を右側のオペランドの値を割り当てます。

単純な代入式の結果は、左側のオペランドに割り当てられている値です。 結果は、左オペランドと同じ型を備え、値として常に分類されます。

左側のオペランドがプロパティまたはインデクサーのアクセスの場合は、プロパティまたはインデクサーがいる必要があります、`set`アクセサー。 サポートしていない場合は、バインド時エラーが発生します。

フォームの単純な割り当ての実行時の処理`x = y`次の手順で構成されています。

*  場合`x`変数として分類されます。
   * `x` 変数を生成するために評価されます。
   * `y` 評価して、必要な場合、変換の型に`x`暗黙的な変換を行って ([暗黙的な変換](conversions.md#implicit-conversions))。
   * 場合によって指定される変数`x`の配列要素である、 *reference_type*の値を計算することを確認する実行時チェックが行われます`y`うち配列インスタンスとの互換性は`x`が、要素。 場合、チェックは成功`y`は`null`、暗黙の参照変換の場合、または ([暗黙の参照変換](conversions.md#implicit-reference-conversions)) 参照しているインスタンスの実際の型からが存在する`y`実際の要素の型に含んでいる配列インスタンスの`x`します。 それ以外の場合は、`System.ArrayTypeMismatchException` がスローされます。
   * 評価との変換から得られた値`y`の評価によって指定された場所に格納されます`x`します。
*  場合`x`プロパティまたはインデクサーのアクセスに分類されます。
   * インスタンス式 (場合`x`ない`static`) および引数リスト (場合`x`インデクサー アクセス) に関連付けられている`x`が評価されると、その後で、結果の使用`set`アクセサーの呼び出し。
   * `y` 評価して、必要な場合、変換の型に`x`暗黙的な変換を行って ([暗黙的な変換](conversions.md#implicit-conversions))。
   * `set`のアクセサー`x`に対して計算された値で呼び出される`y`としてその`value`引数。

配列の共変性規則 ([配列の共変性](arrays.md#array-covariance)) 配列型の値を許可`A[]`配列型のインスタンスへの参照である`B[]`から暗黙の参照変換が存在する限り、`B`に`A`. これらの規則の配列要素への割り当てのため、 *reference_type*割り当てられている値が配列のインスタンスと互換性があることを確認する実行時チェックが必要です。 例
```csharp
string[] sa = new string[10];
object[] oa = sa;

oa[0] = null;               // Ok
oa[1] = "Hello";            // Ok
oa[2] = new ArrayList();    // ArrayTypeMismatchException
```
最後の割り当てにより、`System.ArrayTypeMismatchException`がスローされるインスタンスの`ArrayList`の要素に格納することはできません、 `string[]`。

プロパティまたはインデクサーを宣言で、 *struct_type*インスタンス式を代入式のターゲットに関連付けられているプロパティまたはインデクサー アクセスは、変数として分類する必要があります。 インスタンス式が値として分類は、バインド時エラーが発生します。 ため[メンバー アクセス](expressions.md#member-access)、同じルールは、フィールドにも適用されます。

宣言があるとします。
```csharp
struct Point
{
    int x, y;

    public Point(int x, int y) {
        this.x = x;
        this.y = y;
    }

    public int X {
        get { return x; }
        set { x = value; }
    }

    public int Y {
        get { return y; }
        set { y = value; }
    }
}

struct Rectangle
{
    Point a, b;

    public Rectangle(Point a, Point b) {
        this.a = a;
        this.b = b;
    }

    public Point A {
        get { return a; }
        set { a = value; }
    }

    public Point B {
        get { return b; }
        set { b = value; }
    }
}
```
例
```csharp
Point p = new Point();
p.X = 100;
p.Y = 100;
Rectangle r = new Rectangle();
r.A = new Point(10, 10);
r.B = p;
```
割り当て`p.X`、 `p.Y`、 `r.A`、および`r.B`ので許可されます`p`と`r`変数します。 ただしの例
```csharp
Rectangle r = new Rectangle();
r.A.X = 10;
r.A.Y = 10;
r.B.X = 100;
r.B.Y = 100;
```
割り当ては、以降、すべての無効な`r.A`と`r.B`変数ではないです。

### <a name="compound-assignment"></a>複合代入。

フォームの複合代入の左辺のオペランドが`E.P`または`E[Ei]`場所`E`コンパイル時の型を持つ`dynamic`、割り当てが動的にバインドし、([動的バインド](expressions.md#dynamic-binding))。 この場合、代入式のコンパイル時の型は`dynamic`の実行時の型に基づいて実行時に以下に示す解決が行わ`E`します。

フォームの操作を`x op= y`二項演算子のオーバー ロードの解決を適用することによって処理されます ([二項演算子のオーバー ロードの解決](expressions.md#binary-operator-overload-resolution))、操作が書き込まれた場合、`x op y`します。 そうしたら

*  選択した演算子の戻り値の型がの型に暗黙的に変換できる場合は`x`、操作として評価されます`x = x op y`ことを除いて、`x`は 1 回だけ評価されます。
*  それ以外の場合、選択した演算子の定義済みの演算子の型に明示的に変換できる場合は、選択した演算子の戻り値の型場合`x`、場合`y`の型に暗黙的に変換できる`x`または演算子が、演算子をシフトとして、操作が評価されます`x = (T)(x op y)`ここで、`T`の型である`x`ことを除いて、`x`は 1 回だけ評価されます。
*  それ以外の場合、複合代入が有効でないと、バインド エラーが発生します。

「1 回だけ評価」という用語では、ことを意味の評価で`x op y`の構成要素である式の結果`x`一時的に保存されからへの代入を実行するときに再使用`x`します。 割り当ての例では、`A()[B()] += C()`ここで、`A`を返すメソッドは、 `int[]`、および`B`と`C`を返すメソッド`int`、メソッドは、順序で 1 回だけ呼び出されます`A`、`B`, `C`.

プロパティまたはインデクサーが、両方にいる必要があります複合代入の左辺のオペランドは、プロパティ アクセスまたはインデクサーのアクセスには、ときに、`get`アクセサーと`set`アクセサー。 サポートしていない場合は、バインド時エラーが発生します。

前記の 2 番目のルール`x op= y`として評価される`x = (T)(x op y)`特定のコンテキストでします。 定義済みの演算子の左側のオペランドの型はときに、複合演算子として使用できるように、ルールが存在する`sbyte`、 `byte`、 `short`、 `ushort`、または`char`します。 両方の引数がこれらの型のいずれかの場合でも表示、定義済みの演算子で型の結果を生成`int`」の説明に従って、[バイナリ数値プロモーション](expressions.md#binary-numeric-promotions)します。 したがってをキャストなしことはできません、左側のオペランドに結果を代入すること。

定義済みの演算子のルールの直感的な効果には単には、`x op= y`両方が許可されているの`x op y`と`x = y`が許可されます。 例
```csharp
byte b = 0;
char ch = '\0';
int i = 0;

b += 1;             // Ok
b += 1000;          // Error, b = 1000 not permitted
b += i;             // Error, b = i not permitted
b += (byte)i;       // Ok

ch += 1;            // Error, ch = 1 not permitted
ch += (char)1;      // Ok
```
各エラーの直感的な理由は、対応する単純な代入もされていること、エラーです。

これは、複合代入演算が操作を持ち上げることも意味します。 例
```csharp
int? i = 0;
i += 1;             // Ok
```
リフトされた演算子`+(int?,int?)`使用されます。

### <a name="event-assignment"></a>イベントの割り当て

場合の左オペランド、`+=`または`-=`演算子は、イベント アクセスとして分類し、次のように、式が評価されます。

*  インスタンス式では、存在する場合、イベントへのアクセスの評価されます。
*  右オペランド、`+=`または`-=`演算子が評価され、必要な場合は、暗黙的な変換を左側のオペランドの型に変換 ([暗黙的な変換](conversions.md#implicit-conversions))。
*  右側のオペランドを評価した後で構成される引数リストで、イベントのイベント アクセサーが呼び出されると、必要に応じて、変換します。 演算子が場合`+=`、`add`アクセサーが呼び出されます。 演算子が場合`-=`、`remove`アクセサーが呼び出されます。

イベントの代入式では、値を生成しません。 したがって、イベントの代入式のコンテキストでのみ有効ですが、 *statement_expression* ([式ステートメント](statements.md#expression-statements))。

## <a name="expression"></a>正規表現

*式*か、 *non_assignment_expression*または*割り当て*します。

```antlr
expression
    : non_assignment_expression
    | assignment
    ;

non_assignment_expression
    : conditional_expression
    | lambda_expression
    | query_expression
    ;
```

## <a name="constant-expressions"></a>定数式

A *constant_expression*コンパイル時に完全に評価される式を指定します。

```antlr
constant_expression
    : expression
    ;
```

定数式である必要があります、`null`リテラル値または、次の種類のいずれかの値: `sbyte`、 `byte`、 `short`、 `ushort`、 `int`、 `uint`、 `long`、 `ulong`、 `char`、 `float`、 `double`、 `decimal`、 `bool`、 `object`、 `string`、または列挙型。 定数式で、次の構成要素のみが許可されています。

*  リテラル (など、`null`リテラル) です。
*  参照`const`クラスと構造体の型のメンバー。
*  列挙型のメンバーへの参照。
*  参照`const`パラメーターまたはローカル変数
*  かっこで囲まれたサブ式自体は定数式です。
*  指定されたターゲット型のキャスト式では、上記の型の 1 つです。
*  `checked` `unchecked`式
*  既定値の式
*  Nameof 式
*  定義済み`+`、 `-`、 `!`、および`~`単項演算子。
*  定義済み`+`、 `-`、 `*`、 `/`、 `%`、 `<<`、 `>>`、 `&`、 `|`、 `^`、 `&&`、 `||`、 `==`、 `!=`、 `<`、 `>`、 `<=`、および`>=`上に示した型の各オペランドは、二項の演算子が提供されます。
*  `?:`条件演算子。

次の変換は、定数式で許可されています。

*  恒等変換
*  数値変換
*  列挙型の変換
*  定数式の変換
*  暗黙的および明示的な参照変換、変換のソースが null の値に評価される定数式であることを表示します。

その他の変換では、ボックス化を含む、null 以外の値のボックス化解除と暗黙の参照変換は定数式で許可されていません。 例:
```csharp
class C {
    const object i = 5;         // error: boxing conversion not permitted
    const object str = "hello"; // error: implicit reference conversion
}
```
初期化のボックス化変換が必要なため、i は、エラーです。 Str の初期化は、null 以外の値から暗黙の参照変換が必要になるために、エラーです。

式は、上記の要件を満たして、ときに、式はコンパイル時に評価されます。 これは、式が非定数の構成要素を含むより大きな式のサブ式である場合でも当てはまります。

定数式のコンパイル時の評価は、実行時の評価をスローすると、例外、コンパイル時の評価によって発生するコンパイル時エラーが発生する点を除いて、非定数式の評価を実行時と同じ規則を使用します。

定数式を明示的に配置しない限り、`unchecked`コンパイル時エラーが発生するコンテキストには、常に式のコンパイル時の評価時に整数型の算術演算および変換で発生するオーバーフロー ([定数式](expressions.md#constant-expressions))。

定数式は、以下のコンテキストで発生します。 これらのコンテキストでは、コンパイル時エラーは、式はコンパイル時に完全に評価できない場合に発生します。

*  定数宣言 ([定数](classes.md#constants))。
*  列挙体メンバーの宣言 ([列挙型メンバー](enums.md#enum-members))。
*  既定の仮パラメーター リストの引数 ([メソッド パラメーター](classes.md#method-parameters))
*  `case` ラベルを`switch`ステートメント ([switch ステートメント](statements.md#the-switch-statement))。
*  `goto case` ステートメント ([goto ステートメント](statements.md#the-goto-statement))。
*  次元の配列作成式の長さ ([配列作成式](expressions.md#array-creation-expressions)) 初期化子が含まれます。
*  属性 ([属性](attributes.md))。

定数式が暗黙的な変換を ([定数式が暗黙的な変換](conversions.md#implicit-constant-expression-conversions)) により、型の定数式`int`に変換する`sbyte`、 `byte`、 `short`、 `ushort`、 `uint`、または`ulong`定数式の値が変換先の型の範囲内に提供します。

## <a name="boolean-expressions"></a>ブール式

A *boolean_expression*型の結果を生成する式は、`bool`いずれかのアプリケーションまたは直接`operator true`以下で指定されている特定のコンテキストでします。

```antlr
boolean_expression
    : expression
    ;
```

制御の条件付きの式、 *if_statement* ([if ステートメント](statements.md#the-if-statement))、 *while_statement* ([、while ステートメント](statements.md#the-while-statement))、*do_statement* ([do ステートメント](statements.md#the-do-statement))、または*for_statement* ([、ステートメントの](statements.md#the-for-statement)) は、 *boolean_式*します。 制御の条件付きの式、`?:`演算子 ([条件演算子](expressions.md#conditional-operator)) と同じ規則に従います、 *boolean_expression*演算子の上の理由から、優先順位が分類されますが、として、 *conditional_or_expression*します。

A *boolean_expression* `E`型の値を生成するためにできるようにするために必要な`bool`、次のようにします。

*  場合`E`暗黙的に変換できる`bool`実行時に暗黙的な変換が適用されます。
*  それ以外の場合、単項演算子のオーバー ロード解決 ([単項演算子のオーバー ロードの解決](expressions.md#unary-operator-overload-resolution)) 演算子の一意の最適な実装を検索するために使用`true`で`E`、その実装は実行時に適用します。
*  このような演算子が検出されない場合、バインド時のエラーが発生します。

`DBBool`で構造体型[ブール型のデータベース](structs.md#database-boolean-type)を実装する型の例を示します`operator true`と`operator false`します。
