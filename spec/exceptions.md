# <a name="exceptions"></a><span data-ttu-id="901a9-101">例外</span><span class="sxs-lookup"><span data-stu-id="901a9-101">Exceptions</span></span>

<span data-ttu-id="901a9-102">C# での例外システム レベルとアプリケーション レベルの両方を処理する構造化、統一された、およびタイプ セーフな方法を使用するエラー条件。</span><span class="sxs-lookup"><span data-stu-id="901a9-102">Exceptions in C# provide a structured, uniform, and type-safe way of handling both system level and application level error conditions.</span></span> <span data-ttu-id="901a9-103">C# の例外処理機構は、いくつかの重要な相違点、C に非常に似ています。</span><span class="sxs-lookup"><span data-stu-id="901a9-103">The exception mechanism in C# is quite similar to that of C++, with a few important differences:</span></span>

*  <span data-ttu-id="901a9-104">C# の場合は、すべての例外をから派生したクラス型のインスタンスで表す必要がある`System.Exception`します。</span><span class="sxs-lookup"><span data-stu-id="901a9-104">In C#, all exceptions must be represented by an instance of a class type derived from `System.Exception`.</span></span> <span data-ttu-id="901a9-105">C++ では、例外を表す任意の型の任意の値を使用できます。</span><span class="sxs-lookup"><span data-stu-id="901a9-105">In C++, any value of any type can be used to represent an exception.</span></span>
*  <span data-ttu-id="901a9-106">C# の finally ブロック ([try ステートメント](statements.md#the-try-statement)) 通常の実行と例外条件の両方で実行される終了コードを記述するために使用できます。</span><span class="sxs-lookup"><span data-stu-id="901a9-106">In C#, a finally block ([The try statement](statements.md#the-try-statement)) can be used to write termination code that executes in both normal execution and exceptional conditions.</span></span> <span data-ttu-id="901a9-107">このようなコードは C++ で記述するコードを複製しなくても困難です。</span><span class="sxs-lookup"><span data-stu-id="901a9-107">Such code is difficult to write in C++ without duplicating code.</span></span>
*  <span data-ttu-id="901a9-108">C# の場合は、オーバーフロー、0 による除算、および null の逆参照などのシステム レベルの例外は、適切に定義の例外クラスとアプリケーション レベルのエラー状態と同等にします。</span><span class="sxs-lookup"><span data-stu-id="901a9-108">In C#, system-level exceptions such as overflow, divide-by-zero, and null dereferences have well defined exception classes and are on a par with application-level error conditions.</span></span>

## <a name="causes-of-exceptions"></a><span data-ttu-id="901a9-109">例外の原因</span><span class="sxs-lookup"><span data-stu-id="901a9-109">Causes of exceptions</span></span>

<span data-ttu-id="901a9-110">2 つの方法では、例外をスローできます。</span><span class="sxs-lookup"><span data-stu-id="901a9-110">Exception can be thrown in two different ways.</span></span>

*  <span data-ttu-id="901a9-111">A`throw`ステートメント ([throw ステートメント](statements.md#the-throw-statement)) すぐに、無条件で例外をスローします。</span><span class="sxs-lookup"><span data-stu-id="901a9-111">A `throw` statement ([The throw statement](statements.md#the-throw-statement)) throws an exception immediately and unconditionally.</span></span> <span data-ttu-id="901a9-112">制御がすぐに次のステートメントに到達しません、`throw`します。</span><span class="sxs-lookup"><span data-stu-id="901a9-112">Control never reaches the statement immediately following the `throw`.</span></span>
*  <span data-ttu-id="901a9-113">C# のステートメントと式の処理中に発生する特定の例外的な条件では、特定の状況で例外が発生、操作を正常に終了できない場合。</span><span class="sxs-lookup"><span data-stu-id="901a9-113">Certain exceptional conditions that arise during the processing of C# statements and expression cause an exception in certain circumstances when the operation cannot be completed normally.</span></span> <span data-ttu-id="901a9-114">たとえば、整数除算演算を ([除算演算子](expressions.md#division-operator)) がスローされます、`System.DivideByZeroException`分母が 0 の場合。</span><span class="sxs-lookup"><span data-stu-id="901a9-114">For example, an integer division operation ([Division operator](expressions.md#division-operator)) throws a `System.DivideByZeroException` if the denominator is zero.</span></span> <span data-ttu-id="901a9-115">参照してください[共通例外クラス](exceptions.md#common-exception-classes)この方法で発生するさまざまな例外の一覧についてはします。</span><span class="sxs-lookup"><span data-stu-id="901a9-115">See [Common Exception Classes](exceptions.md#common-exception-classes) for a list of the various exceptions that can occur in this way.</span></span>

## <a name="the-systemexception-class"></a><span data-ttu-id="901a9-116">System.Exception クラス</span><span class="sxs-lookup"><span data-stu-id="901a9-116">The System.Exception class</span></span>

<span data-ttu-id="901a9-117">`System.Exception`クラスは、すべての例外の基本型。</span><span class="sxs-lookup"><span data-stu-id="901a9-117">The `System.Exception` class is the base type of all exceptions.</span></span> <span data-ttu-id="901a9-118">このクラスでは、すべての例外を共有するいくつかの注目すべきプロパティがあります。</span><span class="sxs-lookup"><span data-stu-id="901a9-118">This class has a few notable properties that all exceptions share:</span></span>

*  <span data-ttu-id="901a9-119">`Message` 型の読み取り専用プロパティは、`string`例外の原因の人間が判読できる説明を格納しています。</span><span class="sxs-lookup"><span data-stu-id="901a9-119">`Message` is a read-only property of type `string` that contains a human-readable description of the reason for the exception.</span></span>
*  <span data-ttu-id="901a9-120">`InnerException` 型の読み取り専用プロパティは、`Exception`します。</span><span class="sxs-lookup"><span data-stu-id="901a9-120">`InnerException` is a read-only property of type `Exception`.</span></span> <span data-ttu-id="901a9-121">現在の例外の原因となった例外をその値が null 以外の場合は、参照: catch ブロックで現在の例外が発生したは、処理、`InnerException`します。</span><span class="sxs-lookup"><span data-stu-id="901a9-121">If its value is non-null, it refers to the exception that caused the current exception—that is, the current exception was raised in a catch block handling the `InnerException`.</span></span> <span data-ttu-id="901a9-122">それ以外の場合、その値が null の場合、この例外が別の例外によって原因がないことを示します。</span><span class="sxs-lookup"><span data-stu-id="901a9-122">Otherwise, its value is null, indicating that this exception was not caused by another exception.</span></span> <span data-ttu-id="901a9-123">この方法で連結例外オブジェクトの数は任意にできます。</span><span class="sxs-lookup"><span data-stu-id="901a9-123">The number of exception objects chained together in this manner can be arbitrary.</span></span>

<span data-ttu-id="901a9-124">これらのプロパティの値は、インスタンス コンス トラクターの呼び出しで指定できます`System.Exception`します。</span><span class="sxs-lookup"><span data-stu-id="901a9-124">The value of these properties can be specified in calls to the instance constructor for `System.Exception`.</span></span>

## <a name="how-exceptions-are-handled"></a><span data-ttu-id="901a9-125">例外の処理方法</span><span class="sxs-lookup"><span data-stu-id="901a9-125">How exceptions are handled</span></span>

<span data-ttu-id="901a9-126">例外の処理によって、`try`ステートメント ([try ステートメント](statements.md#the-try-statement))。</span><span class="sxs-lookup"><span data-stu-id="901a9-126">Exceptions are handled by a `try` statement ([The try statement](statements.md#the-try-statement)).</span></span>

<span data-ttu-id="901a9-127">例外が発生したときに、システム検索、最も近い`catch`句を例外の実行時の型によって決定される例外を処理することができます。</span><span class="sxs-lookup"><span data-stu-id="901a9-127">When an exception occurs, the system searches for the nearest `catch` clause that can handle the exception, as determined by the run-time type of the exception.</span></span> <span data-ttu-id="901a9-128">字句外側の現在のメソッドを検索する最初に、`try`ステートメント、および try ステートメントの関連付けられている catch 句は、順番と見なされます。</span><span class="sxs-lookup"><span data-stu-id="901a9-128">First, the current method is searched for a lexically enclosing `try` statement, and the associated catch clauses of the try statement are considered in order.</span></span> <span data-ttu-id="901a9-129">現在のメソッドを呼び出したメソッドが構文的囲む検索失敗した場合、`try`ステートメントを囲むの現在のメソッドの呼び出しをポイントします。</span><span class="sxs-lookup"><span data-stu-id="901a9-129">If that fails, the method that called the current method is searched for a lexically enclosing `try` statement that encloses the point of the call to the current method.</span></span> <span data-ttu-id="901a9-130">この検索はまで継続されます、`catch`によっては、同じクラスまたは基本クラス、スローされる例外の実行時の型の例外クラスの名前を付け、現在の例外を処理できる句が見つかった。</span><span class="sxs-lookup"><span data-stu-id="901a9-130">This search continues until a `catch` clause is found that can handle the current exception, by naming an exception class that is of the same class, or a base class, of the run-time type of the exception being thrown.</span></span> <span data-ttu-id="901a9-131">A`catch`を例外クラスを指定しない句は、すべての例外を処理できます。</span><span class="sxs-lookup"><span data-stu-id="901a9-131">A `catch` clause that doesn't name an exception class can handle any exception.</span></span>

<span data-ttu-id="901a9-132">一致する catch 句が見つかったら、catch 句の最初のステートメントに制御を転送する、システムを準備します。</span><span class="sxs-lookup"><span data-stu-id="901a9-132">Once a matching catch clause is found, the system prepares to transfer control to the first statement of the catch clause.</span></span> <span data-ttu-id="901a9-133">Catch 句の実行が開始する前に、システム最初に実行される、順番にいずれかの`finally`try ステートメントの詳細に関連付けられていた句はするよりも、例外をキャッチした入れ子になった。</span><span class="sxs-lookup"><span data-stu-id="901a9-133">Before execution of the catch clause begins, the system first executes, in order, any `finally` clauses that were associated with try statements more nested that than the one that caught the exception.</span></span>

<span data-ttu-id="901a9-134">一致する catch 句が見つからない場合は、次の 2 つのいずれかに発生します。</span><span class="sxs-lookup"><span data-stu-id="901a9-134">If no matching catch clause is found, one of two things occurs:</span></span>

*  <span data-ttu-id="901a9-135">一致する catch 句の検索には、静的コンス トラクターに達すると ([静的コンス トラクター](classes.md#static-constructors)) または静的フィールド初期化子、`System.TypeInitializationException`が静的コンス トラクターの呼び出しをトリガーした時点でスローされます。</span><span class="sxs-lookup"><span data-stu-id="901a9-135">If the search for a matching catch clause reaches a static constructor ([Static constructors](classes.md#static-constructors)) or static field initializer, then a `System.TypeInitializationException` is thrown at the point that triggered the invocation of the static constructor.</span></span> <span data-ttu-id="901a9-136">内部例外、`System.TypeInitializationException`最初にスローされた例外が含まれています。</span><span class="sxs-lookup"><span data-stu-id="901a9-136">The inner exception of the `System.TypeInitializationException` contains the exception that was originally thrown.</span></span>
*  <span data-ttu-id="901a9-137">一致する catch 句の検索では、最初のスレッドを開始するコードに達すると、スレッドの実行が終了します。</span><span class="sxs-lookup"><span data-stu-id="901a9-137">If the search for matching catch clauses reaches the code that initially started the thread, then execution of the thread is terminated.</span></span> <span data-ttu-id="901a9-138">このような終了の影響は、実装定義です。</span><span class="sxs-lookup"><span data-stu-id="901a9-138">The impact of such termination is implementation-defined.</span></span>

<span data-ttu-id="901a9-139">デストラクターの実行中に発生する例外は、特に注意する必要があります。</span><span class="sxs-lookup"><span data-stu-id="901a9-139">Exceptions that occur during destructor execution are worth special mention.</span></span> <span data-ttu-id="901a9-140">デストラクターの実行中に例外が発生して、その例外はキャッチされず場合、は、そのデストラクターの実行を終了し、(ある場合) は、基底クラスのデストラクターが呼び出されます。</span><span class="sxs-lookup"><span data-stu-id="901a9-140">If an exception occurs during destructor execution, and that exception is not caught, then the execution of that destructor is terminated and the destructor of the base class (if any) is called.</span></span> <span data-ttu-id="901a9-141">基底クラスが存在しない場合 (の場合と同様、`object`型) または基底クラスのデストラクターがないかどうかは、例外は破棄されます。</span><span class="sxs-lookup"><span data-stu-id="901a9-141">If there is no base class (as in the case of the `object` type) or if there is no base class destructor, then the exception is discarded.</span></span>

## <a name="common-exception-classes"></a><span data-ttu-id="901a9-142">一般的な例外クラス</span><span class="sxs-lookup"><span data-stu-id="901a9-142">Common Exception Classes</span></span>

<span data-ttu-id="901a9-143">特定の c# 操作によっては、次の例外がスローされます。</span><span class="sxs-lookup"><span data-stu-id="901a9-143">The following exceptions are thrown by certain C# operations.</span></span>

|                                      |                |
|--------------------------------------|----------------|
| `System.ArithmeticException`         | <span data-ttu-id="901a9-144">算術演算中に発生する例外 (`System.DivideByZeroException`、`System.OverflowException` など) の基底クラスです。</span><span class="sxs-lookup"><span data-stu-id="901a9-144">A base class for exceptions that occur during arithmetic operations, such as `System.DivideByZeroException` and `System.OverflowException`.</span></span> | 
| `System.ArrayTypeMismatchException`  | <span data-ttu-id="901a9-145">格納される要素の実際の型は、配列の実際の型と互換性がないために、配列への格納が失敗したときにスローされます。</span><span class="sxs-lookup"><span data-stu-id="901a9-145">Thrown when a store into an array fails because the actual type of the stored element is incompatible with the actual type of the array.</span></span> | 
| `System.DivideByZeroException`       | <span data-ttu-id="901a9-146">整数値を 0 で除算しようとすると、発生したときにスローされます。</span><span class="sxs-lookup"><span data-stu-id="901a9-146">Thrown when an attempt to divide an integral value by zero occurs.</span></span> | 
| `System.IndexOutOfRangeException`    | <span data-ttu-id="901a9-147">0 未満か、配列の境界の外側であるインデックスを使用して、配列のインデックスを作成するとスローされます。</span><span class="sxs-lookup"><span data-stu-id="901a9-147">Thrown when an attempt to index an array via an index that is less than zero or outside the bounds of the array.</span></span> | 
| `System.InvalidCastException`        | <span data-ttu-id="901a9-148">実行時に基本型またはインターフェイスから派生型への明示的な変換が失敗したときにスローされます。</span><span class="sxs-lookup"><span data-stu-id="901a9-148">Thrown when an explicit conversion from a base type or interface to a derived type fails at run time.</span></span> | 
| `System.NullReferenceException`      | <span data-ttu-id="901a9-149">場合にスローされる、`null`参照が参照先オブジェクトを必要とする方法で使用されています。</span><span class="sxs-lookup"><span data-stu-id="901a9-149">Thrown when a `null` reference is used in a way that causes the referenced object to be required.</span></span> | 
| `System.OutOfMemoryException`        | <span data-ttu-id="901a9-150">メモリを割り当てようとした場合にスローされます (を使用して`new`) が失敗します。</span><span class="sxs-lookup"><span data-stu-id="901a9-150">Thrown when an attempt to allocate memory (via `new`) fails.</span></span> | 
| `System.OverflowException`           | <span data-ttu-id="901a9-151">`checked` コンテキストで算術演算がオーバーフローしたときにスローされます。</span><span class="sxs-lookup"><span data-stu-id="901a9-151">Thrown when an arithmetic operation in a `checked` context overflows.</span></span> | 
| `System.StackOverflowException`      | <span data-ttu-id="901a9-152">保留中のメソッドの呼び出しが多すぎる; することで実行スタックが空になった場合にスローされます。非常に深いか、無限再帰の通常気付く。</span><span class="sxs-lookup"><span data-stu-id="901a9-152">Thrown when the execution stack is exhausted by having too many pending method calls; typically indicative of very deep or unbounded recursion.</span></span> | 
| `System.TypeInitializationException` | <span data-ttu-id="901a9-153">静的コンス トラクターが存在し、例外をスローする場合にスロー`catch`キャッチする句が存在します。</span><span class="sxs-lookup"><span data-stu-id="901a9-153">Thrown when a static constructor throws an exception, and no `catch` clauses exists to catch it.</span></span> | 
