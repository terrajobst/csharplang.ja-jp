---
ms.openlocfilehash: 1c3d05674f8f7b69e70e0d9e06021537fc45f7ed
ms.sourcegitcommit: 94a3d151c438d34ede1d99de9eb4ebdc07ba4699
ms.translationtype: MT
ms.contentlocale: ja-JP
ms.lasthandoff: 04/25/2019
ms.locfileid: "64488485"
---
# <a name="basic-concepts"></a>基本的な概念

## <a name="application-startup"></a>アプリケーションの起動

アセンブリが、***エントリ ポイント***と呼ばれますが、***アプリケーション***します。 ときに、アプリケーションは、実行、新しい***アプリケーション ドメイン***が作成されます。 同時に、アプリケーションのいくつかの異なるインスタンス化が同じコンピューターに存在して、それぞれが独自のアプリケーション ドメイン。

アプリケーション ドメインでは、アプリケーションの状態のコンテナーとして機能するによって、アプリケーション分離を実現します。 アプリケーション ドメインは、コンテナーと、アプリケーションと、使用するクラス ライブラリで定義された型の境界として機能します。 1 つのアプリケーション ドメインに読み込まれた型は別のアプリケーション ドメインに読み込まれる同じ種類の異なると、オブジェクトのインスタンスは直接のアプリケーション ドメイン間で共有されません。 たとえば、各アプリケーション ドメインは、これらの型の静的変数の独自のコピーと、型の静的コンス トラクターはアプリケーション ドメインごとに最大 1 回実行します。 実装では、作成とアプリケーション ドメインの破棄の実装に固有のポリシーまたはメカニズムを提供する無料です。

***アプリケーションの起動***実行環境がアプリケーションのエントリ ポイントと呼ばれる、指定されたメソッドを呼び出すときに発生します。 このエントリ ポイント メソッドの名前は常に`Main`、次のシグネチャのいずれかを指定できます。

```csharp
static void Main() {...}

static void Main(string[] args) {...}

static int Main() {...}

static int Main(string[] args) {...}
```

エントリ ポイントが必要に応じて返す可能性がありますに示すように、`int`値。 これでアプリケーションの終了値が使用されますが返されます ([アプリケーションの終了](basic-concepts.md#application-termination))。

エントリ ポイントは、1 つの仮パラメーターを必要に応じてがあります。 パラメーターは、任意の名前を必要がありますが、パラメーターの型である必要があります`string[]`します。 実行環境を作成し、渡します仮パラメーターが存在する場合、`string[]`されたコマンドライン引数を含む引数は、アプリケーションが開始された日時を指定します。 `string[]`引数が null ではありませんが、コマンドライン引数が指定されていない場合、長さ 0 の可能性があります。

C# メソッドのオーバー ロードをサポートするためクラスまたは構造体を含めることはいくつかのメソッドの複数の定義それぞれがある異なるシグネチャで提供されます。 ただし、1 つのプログラム内でクラスまたは構造体ことないという 1 つ以上のメソッドが`Main`の定義が適用されるアプリケーションのエントリ ポイントとして使用されるようにします。 他のオーバー ロードされたバージョンの`Main`は許可されて、ただし、1 つ以上のパラメーター、または型以外の唯一のパラメーターは、提供される`string[]`します。

アプリケーションは、複数のクラスまたは構造体の構成できます。 呼び出されるメソッドを格納するこれらのクラスまたは構造体の 1 つ以上のことは`Main`の定義が適用されるアプリケーションのエントリ ポイントとして使用されるようにします。 このような場合は、次のいずれかを選択する (コマンド ライン コンパイラ オプション) などの外部メカニズムを使用する必要があります`Main`エントリ ポイントとしてメソッド。

C# でクラスまたは構造体のメンバーとしてすべてのメソッドを定義する必要があります。 通常、宣言されたアクセシビリティ ([宣言されたアクセシビリティ](basic-concepts.md#declared-accessibility)) メソッドのアクセス修飾子によって決定されます ([アクセス修飾子](classes.md#access-modifiers))、その宣言と同様に宣言で指定されました。型のアクセシビリティは、その宣言で指定されたアクセス修飾子によって決定されます。 指定された型の特定のメソッドを呼び出せるようにする、型とメンバーの両方必要がありますでアクセスできます。 ただし、アプリケーションのエントリ ポイントは、特殊なケースです。 具体的には、実行環境は、宣言されたアクセシビリティに関係なく、その外側の型宣言の宣言されたアクセシビリティに関係なく、アプリケーションのエントリ ポイントにアクセスできます。

アプリケーションのエントリ ポイント メソッドがジェネリック クラス宣言でできないがあります。

その他のすべての点は、エントリ ポイント メソッドは、エントリ ポイントではないよう動作します。

## <a name="application-termination"></a>アプリケーションの終了

***アプリケーションの終了***実行環境にコントロールを返します。

戻り値の型のアプリケーションの場合***エントリ ポイント***メソッドは`int`、返される値は、アプリケーションの***終了ステータス コード***します。 このコードでは、成功または失敗、実行時環境への通信を許可します。

エントリ ポイント メソッドの戻り値の型がある場合`void`、右中かっこに到達 (`}`) を終了するメソッド、またはを実行する、`return`式を持たないステートメントの結果の終了ステータス コード`0`します。

このようなクリーンアップが中止された場合を除き、アプリケーションの終了前にすべてのガベージ コレクションをまだしていないオブジェクトのデストラクターが呼び出されます (ライブラリのメソッドを呼び出して`GC.SuppressFinalize`など)。

## <a name="declarations"></a>宣言

C# プログラム内の宣言では、プログラムの構成要素を定義します。 名前空間を使用して c# プログラムの構成 ([名前空間](namespaces.md))、型を含めることができる宣言と入れ子になった名前空間を宣言します。 型宣言 ([入力宣言](namespaces.md#type-declarations)) クラスを定義するために使用されます ([クラス](classes.md))、構造体 ([構造体](structs.md))、インターフェイス ([インターフェイス](interfaces.md))、列挙型 ([列挙型](enums.md))、およびデリゲート ([デリゲート](delegates.md))。 型の宣言でメンバーの種類は、型宣言の形式に依存します。 たとえば、クラス宣言が定数の宣言を含めることができます ([定数](classes.md#constants))、フィールド ([フィールド](classes.md#fields))、メソッド ([メソッド](classes.md#methods))、プロパティ ([プロパティ](classes.md#properties))、イベント ([イベント](classes.md#events))、インデクサー ([インデクサー](classes.md#indexers))、演算子 ([演算子](classes.md#operators))、インスタンス コンス トラクター ([インスタンス コンス トラクター](classes.md#instance-constructors))、静的コンス トラクター ([静的コンス トラクター](classes.md#static-constructors))、デストラクター ([デストラクター](classes.md#destructors))、入れ子にされた型と ([入れ子になった型](classes.md#nested-types)).

宣言内の名前を定義する、***宣言領域***宣言が属しています。 以外のメンバーはオーバー ロード ([シグネチャとオーバー ロード](basic-concepts.md#signatures-and-overloading))、宣言領域内の同じ名前のメンバーを導入する 2 つ以上の宣言すると、コンパイル時エラーします。 さまざまな種類の同じ名前を持つメンバーを格納する宣言領域のことはできません。 たとえば、宣言領域が含まれないことフィールドとメソッドを同じ名前。

さまざまな種類の宣言のスペースがある、次に示すようにします。

*  プログラムのすべてのソース ファイル内で*namespace_member_declaration*を囲むありません*namespace_declaration*という 1 つの結合された宣言領域のメンバーである、***グローバル宣言領域***します。
*  プログラムのすべてのソース ファイル内で*namespace_member_declaration*内*namespace_declaration*s 同じ完全修飾名前空間の名前を持つ 1 つの結合された宣言のメンバーであります。領域。
*  各クラス、構造体、またはインターフェイスの宣言は、新しい宣言領域を作成します。 この宣言領域に名前が導入*class_member_declaration*s、 *struct_member_declaration*s、 *interface_member_declaration*s、または*type_parameter*秒。 オーバー ロードされたコンス トラクターを除く宣言と宣言、クラスまたは構造体の静的コンス トラクターは、クラスまたは構造体と同じ名前のメンバーの宣言を含めることはできません。 クラス、構造体、またはインターフェイスは、オーバー ロードされたメソッドとインデクサーの宣言を許可します。 さらに、クラスまたは構造体は、オーバー ロードされたインスタンスのコンス トラクターと演算子の宣言を許可します。 たとえば、クラス、構造体、またはインターフェイス含めることができます、同じ名前を持つ複数のメソッド宣言のシグネチャでこれらのメソッド宣言が異なるので ([シグネチャとオーバー ロード](basic-concepts.md#signatures-and-overloading))。 基底クラスは、クラスの宣言領域には影響しません、基本インターフェイスは、インターフェイスの宣言領域に関係のないことに注意してください。 したがって、派生クラスまたはインターフェイスは継承メンバーと同じ名前のメンバーを宣言できます。 このようなメンバーといいます***を非表示に***継承されたメンバー。
*  各デリゲート宣言では、新しい宣言領域を作成します。 仮パラメーターでは、この宣言領域に名前が導入 (*fixed_parameter*s と*括ら*s) と*type_parameter*秒。
*  各列挙体の宣言は、新しい宣言領域を作成します。 この宣言領域に名前が導入*enum_member_declarations*します。
*  各メソッドの宣言、インデクサーの宣言、演算子の宣言、インスタンス コンス トラクターの宣言および匿名関数の作成と呼ばれる新しい宣言領域、***ローカル変数の宣言領域***します。 仮パラメーターでは、この宣言領域に名前が導入 (*fixed_parameter*s と*括ら*s) と*type_parameter*秒。 関数メンバーまたは匿名関数の本体、存在する場合と見なされます、ローカル変数の宣言領域内で入れ子にします。 ローカル変数の宣言領域と同じ名前の要素を格納するローカル変数の宣言を入れ子になった領域エラーになります。 したがって、入れ子になった宣言領域の外側の宣言領域で、ローカル変数またはローカル変数と同じ名前の定数または定数を宣言することはできません。 どちらの宣言領域に、もう一方が含まれている限り、同じ名前の要素を格納する 2 つの宣言スペースのことができます。
*  各*ブロック*または*switch_block*と同様に、*の*、 *foreach*と*を使用して*ステートメントでは、作成します。ローカル変数とローカル定数のローカル変数の宣言領域です。 この宣言領域に名前が導入*local_variable_declaration*s と*local_constant_declaration*秒。 として、または関数のメンバーまたは匿名関数の本文内で発生するブロックがそのパラメーターに対してこれらの関数によって宣言されたローカル変数の宣言領域内で入れ子にされていることに注意してください。 そのため、エラーにローカル変数と同じ名前のパラメーターのメソッドになどになります。
*  各*ブロック*または*switch_block*ラベルの別の宣言領域を作成します。 この宣言領域に名前が導入*labeled_statement*秒、および名前がを通じて参照*goto_statement*s。 ***宣言領域にラベルを付ける***ブロックの入れ子になったブロックが含まれています。 したがって、入れ子になったブロックの外側のブロックのラベルと同じ名前のラベルを宣言することはできません。

名が宣言されているテキストの順序は、一般にあまり意味はありません。 具体的には、テキストの順序は、宣言と名前空間、定数、メソッド、プロパティ、イベント、インデクサー、演算子、インスタンス コンス トラクター、デストラクター、静的コンス トラクター、および種類の意味ではありません。 宣言の順序は、次の方法で重要です。

*  フィールドの宣言とローカル変数宣言の宣言の順序は、(ある場合) には、初期化子が実行される順序を決定します。
*  使用されるように、ローカル変数を定義する必要があります ([スコープ](basic-concepts.md#scopes))。
*  列挙型メンバーの宣言の宣言の順序 ([列挙型メンバー](enums.md#enum-members)) ときに、大きな*constant_expression*値が省略されます。

名前空間の宣言領域は、"終了"開き、2 つの名前空間と同じ完全修飾名の宣言が同じ宣言領域を構成します。 次に例を示します。
```csharp
namespace Megacorp.Data
{
    class Customer
    {
        ...
    }
}

namespace Megacorp.Data
{
    class Order
    {
        ...
    }
}
```

ここで完全修飾の名前を持つ 2 つのクラスを宣言する、同じ宣言領域に 2 つの名前空間宣言が貢献`Megacorp.Data.Customer`と`Megacorp.Data.Order`します。 同じ宣言領域に 2 つの宣言がドキュメントに投稿するためにはエラーが発生、コンパイル時場合と同じ名前のクラスの宣言が含まれている各します。

上で指定した、ブロックの宣言領域には、任意の入れ子になったブロックが含まれています。 したがって、次の例で、`F`と`G`メソッドがコンパイル時エラーが発生するため、名前`i`は外側のブロックで宣言されており、内側のブロックで再宣言することはできません。 ただし、`H`と`I`メソッドは、2 つから有効な`i`の入れ子になっていない別のブロックで宣言されます。

```csharp
class A
{
    void F() {
        int i = 0;
        if (true) {
            int i = 1;            
        }
    }

    void G() {
        if (true) {
            int i = 0;
        }
        int i = 1;                
    }

    void H() {
        if (true) {
            int i = 0;
        }
        if (true) {
            int i = 1;
        }
    }

    void I() {
        for (int i = 0; i < 10; i++)
            H();
        for (int i = 0; i < 10; i++)
            H();
    }
}
```

## <a name="members"></a>メンバー

名前空間と型が***メンバー***します。 エンティティのメンバーは、一般提供開始後に、エンティティへの参照で始まる修飾名を使用して、"`.`"トークン、その後に、メンバーの名前。

型のメンバーが型の宣言で宣言されたか、または***継承***型の基本クラスから。 型が基本クラス、インスタンス コンス トラクター、デストラクター、および静的コンス トラクターを除く、基底クラスのすべてのメンバーから継承する場合は、派生型のメンバーになります。 基底クラスのメンバーの宣言されたアクセシビリティは、メンバーが継承されるかどうかを制御しません-継承は、インスタンス コンス トラクター、静的コンス トラクターまたはデストラクター以外の任意のメンバーを拡張します。 ただし、継承されたメンバーをアクセスできない派生型で宣言されたアクセシビリティのいずれかで ([宣言されたアクセシビリティ](basic-concepts.md#declared-accessibility))、型自体で宣言によって非表示になっているため、または ([を非表示継承](basic-concepts.md#hiding-through-inheritance))。

### <a name="namespace-members"></a>Namespace メンバー

名前空間とそれを囲む名前空間を持たない型のメンバーである、***グローバル名前空間***します。 これは、グローバル宣言領域で宣言された名前に直接対応します。

名前空間と名前空間内で宣言された型は、その名前空間のメンバーです。 これは、名前空間の宣言領域で宣言された名前に直接対応します。

名前空間には、アクセス制限がありません。 プライベート、プロテクト、または内部の名前空間を宣言することはできませんし、名前空間の名前はパブリックにアクセスできる、常にします。

### <a name="struct-members"></a>構造体のメンバー

構造体のメンバーは、構造体で宣言されたメンバーと、構造体の直接基底クラスから継承されたメンバー`System.ValueType`間接基底クラスと`object`します。

単純型のメンバーは、単純型によって構造体の型エイリアスのメンバーに直接対応しています。

*  メンバー`sbyte`のメンバーである、`System.SByte`構造体。
*  メンバー`byte`のメンバーである、`System.Byte`構造体。
*  メンバー`short`のメンバーである、`System.Int16`構造体。
*  メンバー`ushort`のメンバーである、`System.UInt16`構造体。
*  メンバー`int`のメンバーである、`System.Int32`構造体。
*  メンバー`uint`のメンバーである、`System.UInt32`構造体。
*  メンバー`long`のメンバーである、`System.Int64`構造体。
*  メンバー`ulong`のメンバーである、`System.UInt64`構造体。
*  メンバー`char`のメンバーである、`System.Char`構造体。
*  メンバー`float`のメンバーである、`System.Single`構造体。
*  メンバー`double`のメンバーである、`System.Double`構造体。
*  メンバー`decimal`のメンバーである、`System.Decimal`構造体。
*  メンバー`bool`のメンバーである、`System.Boolean`構造体。

### <a name="enumeration-members"></a>列挙型メンバー

列挙体のメンバーは、列挙体で宣言された定数と列挙型の直接基底クラスから継承されたメンバー`System.Enum`と間接基底クラス`System.ValueType`と`object`します。

### <a name="class-members"></a>クラス メンバー

クラスのメンバーは、クラスで宣言されたメンバーと基本クラスから継承されたメンバー (クラスを除く`object`する基本クラスがありません)。 基本クラスから継承されたメンバーには、定数、フィールド、メソッド、プロパティ、イベント、インデクサー、演算子、および、基底クラスですがない、インスタンス コンス トラクター、デストラクターおよび基底クラスの静的コンス トラクターの型が含まれます。 アクセシビリティに関係なく、基本クラスのメンバーが継承されます。

クラス宣言では、定数、フィールド、メソッド、プロパティ、イベント、インデクサー、演算子、インスタンス コンス トラクター、デストラクター、静的コンス トラクターと型の宣言を含めることができます。

メンバー`object`と`string`に直接対応して、クラス型のメンバーがエイリアス。

*  メンバー`object`のメンバーである、`System.Object`クラス。
*  メンバー`string`のメンバーである、`System.String`クラス。

### <a name="interface-members"></a>インターフェイスのメンバー

インターフェイスのメンバーは、インターフェイス、およびインターフェイスのすべての基本インターフェイスで宣言されたメンバーです。 クラスでメンバー`object`厳密に言うと、任意のインターフェイスのメンバーは使用されません ([インターフェイスのメンバー](interfaces.md#interface-members))。 ただし、クラスでメンバー`object`は任意のインターフェイス型でメンバーの検索で利用できます ([メンバー ルックアップ](expressions.md#member-lookup))。

### <a name="array-members"></a>配列メンバー

配列のメンバーは、クラスから継承されたメンバー`System.Array`します。

### <a name="delegate-members"></a>デリゲートのメンバー

デリゲートのメンバーは、クラスから継承されたメンバー`System.Delegate`します。

## <a name="member-access"></a>メンバー アクセス。

メンバーの宣言では、メンバー アクセス制御を許可します。 メンバーのアクセシビリティが宣言されたアクセシビリティで確立されます ([宣言されたアクセシビリティ](basic-concepts.md#declared-accessibility)) メンバーのアクセシビリティとの組み合わせ、すぐにそれを含む型の存在する場合。

特定のメンバーへのアクセスを許可すると、メンバーがあると言います。***アクセス***します。 逆に、特定のメンバーへのアクセスが許可されていない場合、メンバー言います***アクセスできない***します。 アクセシビリティ ドメインにアクセスが行われる場所が含まれている場合、メンバーへのアクセスが許可されて ([アクセシビリティ ドメイン](basic-concepts.md#accessibility-domains)) のメンバー。

### <a name="declared-accessibility"></a>アクセシビリティの宣言

***宣言されたアクセシビリティ***メンバーのことができますが、次のいずれか。

*  パブリックで、含めることでが選択されている、`public`メンバーの宣言での修飾子。 直感的な意味`public`「アクセスは制限されません」です。
*  保護をオンになっていますを含めることによって、`protected`メンバーの宣言での修飾子。 直感的な意味`protected`が"アクセスはコンテナーのクラスまたは型に制限されます、コンテナー クラスから派生"。
*  内部で、含めることでが選択されている、`internal`メンバーの宣言での修飾子。 直感的な意味`internal`「このプログラムにだけがアクセス」。
*  プロテクト内部 (つまり、protected、または内部) 両方を含めることによってこれが選択されている、`protected`と`internal`メンバーの宣言に修飾子。 直感的な意味`protected internal`が「このプログラムにだけがアクセスまたは含んでいるクラスから派生した型」です。
*  プライベートで、含めることでが選択されている、`private`メンバーの宣言での修飾子。 直感的な意味`private`「を含んでいる型だけがアクセス」。

メンバーの宣言をコンテキストに応じて配置、宣言されたアクセシビリティの特定の種類のみが許可されます。 さらに、メンバーの宣言に、アクセス修飾子が含まれていない場合、宣言が行われるコンテキストには、既定の宣言されたアクセシビリティが決まります。

*  名前空間が暗黙的が`public`アクセシビリティを宣言します。 名前空間の宣言では、アクセス修飾子は許可されません。
*  コンパイル単位または名前空間で宣言された型を持つことができます`public`または`internal`アクセシビリティおよび既定値は宣言されている`internal`アクセシビリティを宣言します。
*  クラスのメンバーが宣言されたアクセシビリティの 5 種類のいずれかがあるし、する既定の`private`アクセシビリティを宣言します。 (を型として宣言されたクラスのメンバーが宣言されたアクセシビリティの 5 種類のいずれかを持つことができますのみ名前空間のメンバーは、宣言された型に対してに注意してください`public`または`internal`アクセシビリティで宣言されています。)。
*  構造体のメンバーが持つことができます`public`、 `internal`、または`private`アクセシビリティおよび既定値は宣言されている`private`構造体は暗黙的にシールされているため、アクセシビリティを宣言します。 構造体のメンバー (には、その構造体によって継承されません) 構造体で導入されたことはできません`protected`または`protected internal`アクセシビリティを宣言します。 (構造体のメンバーであることができますが型に宣言されていることに注意してください`public`、 `internal`、または`private`のみ名前空間のメンバーは、宣言された型は、アクセシビリティを宣言`public`または`internal`宣言されたアクセシビリティ。)。
*  インターフェイス メンバーが暗黙的が`public`アクセシビリティを宣言します。 インターフェイス メンバー宣言では、アクセス修飾子は許可されません。
*  列挙型メンバーが暗黙的が`public`アクセシビリティを宣言します。 列挙体メンバーの宣言では、アクセス修飾子は許可されません。

### <a name="accessibility-domains"></a>アクセシビリティ ドメイン

***アクセシビリティ ドメイン***メンバーのメンバーへのアクセスが許可されているプログラム テキストの (場合によって不整合のある) のセクションで構成されます。 メンバーのアクセシビリティ ドメインを定義するために、メンバーがあると言います***トップレベル***場合は、型の中で宣言されていないと、メンバーがあると言います***入れ子になった***別の種類内で宣言されている場合。 さらに、***プログラム テキスト***プログラムは、すべてのプログラム、プログラムのすべてのソース ファイルに含まれるテキストと型のプログラム テキストがすべてのプログラム テキストに含まれるように定義されている、定義、 *type_declaration*など、場合によっては、型の中で入れ子にされた型、その型の秒。

定義済みの型のアクセシビリティ ドメイン (など`object`、 `int`、または`double`) に制限はありません。

最上位のアクセシビリティ ドメインには、型がバインドされていない`T`([バインドされ、型がバインドされていない](types.md#bound-and-unbound-types)) プログラムで宣言されている`P`が次のように定義されています。

*  場合の宣言されたアクセシビリティ`T`は`public`のアクセシビリティ ドメイン`T`のプログラム テキスト`P`と参照するすべてのプログラム`P`します。
*  `T` に対して宣言されているアクセシビリティが `internal` の場合、`T` のアクセシビリティ ドメインは `P` のプログラム テキストになります。

これらの定義からは、最上位レベルのバインドされていない型のアクセシビリティ ドメインは常に、少なくともを次の種類をプログラムのプログラム テキストを宣言します。

構築された型のアクセシビリティ ドメイン`T<A1, ..., An>`バインドされていないジェネリック型のアクセシビリティ ドメインとの積集合`T`と型引数のアクセシビリティ ドメイン`A1, ..., An`します。

入れ子にされたメンバーのアクセシビリティ ドメイン`M`型で宣言`T`、プログラム内で`P`が次のように定義されている (いう`M`自体は型である可能性があります可能性があります)。

*  `M` に対して宣言されたアクセシビリティが `public` の場合、`M` のアクセシビリティ ドメインは `T` のアクセシビリティ ドメインになります。
*  場合の宣言されたアクセシビリティ`M`は`protected internal`、`D`のプログラム テキストの和集合をする`P`から派生した任意の型のプログラム テキストと`T`の外部で宣言されている`P`します。 アクセシビリティ ドメイン`M`のアクセシビリティ ドメインとの積集合`T`で`D`します。
*  場合の宣言されたアクセシビリティ`M`は`protected`、`D`のプログラム テキストの和集合をする`T`から派生した任意の型のプログラム テキストと`T`します。 アクセシビリティ ドメイン`M`のアクセシビリティ ドメインとの積集合`T`で`D`します。
*  `M` に対して宣言されているアクセシビリティが `internal` の場合、`M` のアクセシビリティ ドメインは、`T` のアクセシビリティ ドメインと `P` のプログラム テキストとの積集合になります。
*  `M` に対して宣言されているアクセシビリティが `private` の場合、`M` のアクセシビリティ ドメインは `T` のプログラム テキストになります。

これらの定義からは、入れ子にされたメンバーのアクセシビリティ ドメインは常に、少なくともを次のメンバーが宣言されている種類のプログラム テキストです。 さらに、メンバーのアクセシビリティ ドメインはさらに、メンバーが宣言されている型のアクセシビリティ ドメインより包括的でないことに従います。

わかりやすく言うと、型またはメンバーと`M`がアクセスするには、次の手順は、アクセスが許可されていることを確認に評価されます。

*  最初に、if `M` (と対照的にコンパイル単位または名前空間)、型で宣言は、その型にアクセスできない場合、コンパイル時エラーが発生します。
*  場合はその後、`M`は`public`アクセスを許可します。
*  の場合`M`は`protected internal`、をプログラム内で発生した場合、アクセスが許可されます`M`を宣言したクラスから派生したクラス内に現れたかどうかまたは`M`は宣言されており、派生クラスで行われますクラスの種類 ([保護されるインスタンスのメンバーにアクセス](basic-concepts.md#protected-access-for-instance-members))。
*  の場合`M`は`protected`、クラス内で発生した場合、アクセスが許可されて`M`が宣言されているクラスから派生したクラス内に現れたかどうかまたは`M`は宣言されており、派生クラスで行われますクラスの種類 ([保護されるインスタンスのメンバーにアクセス](basic-concepts.md#protected-access-for-instance-members))。
*  の場合`M`は`internal`、をプログラム内で発生した場合に、アクセスが許可されている`M`は宣言されています。
*  の場合`M`は`private`、の種類内で発生した場合、アクセスが許可されて`M`は宣言されています。
*  それ以外の場合、型またはメンバーにアクセスできないと、コンパイル時エラーが発生します。

例
```csharp
public class A
{
    public static int X;
    internal static int Y;
    private static int Z;
}

internal class B
{
    public static int X;
    internal static int Y;
    private static int Z;

    public class C
    {
        public static int X;
        internal static int Y;
        private static int Z;
    }

    private class D
    {
        public static int X;
        internal static int Y;
        private static int Z;
    }
}
```
クラスとメンバーは、次のアクセシビリティ ドメインにあります。

*  アクセシビリティ ドメイン`A`と`A.X`に制限はありません。
*  アクセシビリティ ドメイン`A.Y`、 `B`、 `B.X`、 `B.Y`、 `B.C`、 `B.C.X`、および`B.C.Y`含んでいるプログラムのプログラム テキストです。
*  アクセシビリティ ドメイン`A.Z`のプログラム テキスト`A`します。
*  アクセシビリティ ドメイン`B.Z`と`B.D`のプログラム テキスト`B`のプログラム テキストを含む`B.C`と`B.D`します。
*  アクセシビリティ ドメイン`B.C.Z`のプログラム テキスト`B.C`します。
*  アクセシビリティ ドメイン`B.D.X`と`B.D.Y`のプログラム テキスト`B`のプログラム テキストを含む`B.C`と`B.D`します。
*  アクセシビリティ ドメイン`B.D.Z`のプログラム テキスト`B.D`します。

例に示すように、メンバーのアクセシビリティ ドメインを含んでいる型よりも大きいことはありません。 たとえば、場合でもすべて`X`があるパブリックの宣言されたアクセシビリティのメンバー以外のすべて`A.X`アクセシビリティ ドメインは、それを含む型によって制限されます。

」の説明に従って[メンバー](basic-concepts.md#members)、コンス トラクター、デストラクター、および静的コンス トラクター、インスタンスを除く、基底クラスのすべてのメンバーが派生型によって継承されます。 これには、基底クラスのプライベート メンバーも含まれています。 ただし、プライベート メンバーのアクセシビリティ ドメインには、メンバーが宣言されている型のプログラム テキストのみが含まれています。 例
```csharp
class A
{
    int x;

    static void F(B b) {
        b.x = 1;        // Ok
    }
}

class B: A
{
    static void F(B b) {
        b.x = 1;        // Error, x not accessible
    }
}
```
`B`クラスは、プライベート メンバーを継承`x`から、`A`クラス。 内でアクセスできる、のみ、メンバーはプライベートなので、 *class_body*の`A`します。 アクセスをそのため、`b.x`に成功すると、`A.F`メソッドが失敗で、`B.F`メソッド。

### <a name="protected-access-for-instance-members"></a>インスタンス メンバーの保護されたアクセス

ときに、`protected`インスタンス メンバーのアクセスが宣言されるクラスのプログラム テキストの外側とタイミングを`protected internal`インスタンス メンバーが宣言されているプログラムのプログラム テキストの外側からアクセス、アクセスは内で行う必要があります、宣言されているクラスから派生したクラスの宣言。 さらに、アクセスは、そこから作成されたクラス型、またはその派生クラス型のインスタンスを介して行う必要があります。 この制限は、1 つの派生クラスが、メンバーが、同じ基本クラスから継承された場合でも、他の派生クラスのプロテクト メンバーにアクセスすることを防ぎます。

ように`B`保護されたインスタンス メンバーを宣言する基本クラスである`M`、させて`D`から派生したクラスでなければ`B`します。 内で、 *class_body*の`D`へのアクセスを`M`形式は次のいずれかを実行します。

*  非限定*type_name*または*primary_expression*フォームの`M`します。
*  A *primary_expression*フォームの`E.M`の型を提供`E`は`T`から派生したクラスまたは`T`ここで、`T`クラス型は、 `D`、またはクラス型構築されました。 `D`
*  A *primary_expression*フォームの`base.M`します。

派生クラスがで基底クラスのインスタンスが保護されたコンス トラクターのアクセス時にこれらの形式のアクセスに加え、 *constructor_initializer* ([コンス トラクター初期化子](classes.md#constructor-initializers))。

例
```csharp
public class A
{
    protected int x;

    static void F(A a, B b) {
        a.x = 1;        // Ok
        b.x = 1;        // Ok
    }
}

public class B: A
{
    static void F(A a, B b) {
        a.x = 1;        // Error, must access through instance of B
        b.x = 1;        // Ok
    }
}
```
内で`A`、アクセスすることは`x`両方のインスタンスを通じて`A`と`B`いずれの場合では、アクセスがのインスタンスを通じて行われますので、`A`から派生したクラスまたは`A`します。 ただし、内`B`にアクセスすることはできません`x`のインスタンスを通じて`A`、ため`A`から派生していない`B`します。

例
```csharp
class C<T>
{
    protected T x;
}

class D<T>: C<T>
{
    static void F() {
        D<T> dt = new D<T>();
        D<int> di = new D<int>();
        D<string> ds = new D<string>();
        dt.x = default(T);
        di.x = 123;
        ds.x = "test";
    }
}
```
次の 3 つの割り当てを`x`ジェネリック型から構築されたクラス型のインスタンスで実行されるので許可されます。

### <a name="accessibility-constraints"></a>アクセシビリティの制約

C# 言語のいくつかの構成要素に必要な型に***として以上のアクセシビリティ***メンバーまたは別の型。 型`T`少なくともメンバーまたは型と同程度にアクセスできるように言います`M`場合のアクセシビリティ ドメイン`T`のアクセシビリティ ドメインのスーパー セット`M`します。 つまり、`T`として以上のアクセシビリティは`M`場合`T`をすべてのコンテキストでアクセス可能な`M`にアクセスします。

次のユーザー補助の制約があります。

*  クラスの型の直接基底クラスは、少なくとも、クラスの型自体と同程度にアクセス可能である必要があります。
*  インターフェイスの型の明示的な基本インターフェイスは、少なくとも、インターフェイスの型自体と同程度にアクセス可能である必要があります。
*  デリゲート型の戻り値の型およびパラメーターの型は、少なくとも、デリゲート型自体と同程度にアクセス可能である必要があります。
*  定数の型は、少なくとも定数自体と同程度にアクセス可能である必要があります。
*  フィールドの型は、少なくともフィールド自体と同程度にアクセス可能である必要があります。
*  メソッドの戻り値の型およびパラメーターの型は、少なくとも、メソッド自体と同程度にアクセス可能である必要があります。
*  プロパティの型は、少なくともプロパティ自体と同程度にアクセス可能である必要があります。
*  イベントの型は、少なくともイベント自体と同程度にアクセス可能である必要があります。
*  インデクサーの型とパラメーターの型は、少なくとも、インデクサー自体と同程度にアクセス可能である必要があります。
*  演算子の戻り値の型とパラメーターの型は、少なくとも、演算子自体と同程度にアクセス可能である必要があります。
*  インスタンス コンス トラクターのパラメーターの型は、少なくとも、インスタンス コンス トラクター自体と同程度にアクセスできなければなりません。

例
```csharp
class A {...}

public class B: A {...}
```
`B`ため、クラスがコンパイル時エラー結果`A`として少なくともアクセス可能でない`B`します。

例では同様に、
```csharp
class A {...}

public class B
{
    A F() {...}

    internal A G() {...}

    public A H() {...}
}
```
`H`メソッド`B`結果、戻り値の型のため、コンパイル時エラー、`A`は少なくともメソッドと同程度にアクセスできません。

## <a name="signatures-and-overloading"></a>シグネチャとオーバー ロード

メソッド、インスタンス コンス トラクター、インデクサー、および演算子の特性は、その***署名***:

*  メソッドのシグネチャは、メソッド、型パラメーターの数と型と仮パラメーターが左から右へ順に検討のそれぞれの種類 (値、参照、または出力) の名前で構成されます。 このため、その名前ではなく、メソッドの型引数リストの序数位置を使用して、仮パラメーターの型で使用されるメソッドの型パラメーターが識別されます。 メソッドのシグネチャが具体的には戻り値の型では含まない、`params`右端のパラメーターも省略可能な型パラメーターの制約で指定できる修飾子。
*  インスタンス コンス トラクターのシグネチャは、型と仮パラメーターが左から右へ順に検討のそれぞれの種類 (値、参照、または出力) で構成されます。 具体的には、インスタンス コンス トラクターのシグネチャが含まれません場合は、`params`右端のパラメーターで指定できる修飾子。
*  インデクサーのシグネチャは、左から右へ順番と見なされます、仮パラメーターのそれぞれの種類で構成されます。 インデクサーのシグネチャが具体的には、要素の型では含まないも含まれる、`params`右端のパラメーターで指定できる修飾子。
*  演算子のシグネチャは、演算子と仮パラメーターが左から右へ順に検討のそれぞれの型の名前で構成されます。 具体的には、演算子のシグネチャでは、結果型は含まれません。

署名の有効化のメカニズムは、***オーバー ロード***クラス、構造体、およびインターフェイス内のメンバーの。

*  メソッドのオーバー ロードは、クラス、構造体、またはシグネチャの同じ名前を持つ複数のメソッドはそのクラス、構造体、またはインターフェイス内で一意で宣言するインターフェイスを許可します。
*  インスタンス コンス トラクターのオーバー ロードは、そのシグネチャはそのクラスまたは構造体内で一意で提供される、クラスまたは複数のインスタンス コンス トラクターを宣言する構造体をできます。
*  そのシグネチャは、クラス、構造体、またはインターフェイス内で一意で提供される、クラス、構造体、または複数のインデクサーを宣言するインターフェイスを許可インデクサーのオーバー ロードします。
*  演算子のオーバー ロードにより、クラスまたは構造体がそのクラスまたは構造体内で一意で、シグネチャの同じ名前の複数の演算子を宣言します。

`out`と`ref`パラメーター修飾子は、シグネチャの一部と見なされます、1 つの型で宣言されたメンバーがだけでの署名で異なることはできません`ref`と`out`します。 2 つのメンバーが宣言されている場合場合でも同じになるシグネチャを持つ同じ型ですべてのパラメーターを両方の方法で、コンパイル時エラーが発生した`out`に変更された修飾子`ref`修飾子。 シグネチャの一致の他の目的 (非表示やオーバーライドなど)、`ref`と`out`シグネチャの一部と見なされ、他の一致していません。 (この制限は、許可するC#実行で、共通言語基盤 (CLI) でのみ異なるメソッドを定義する方法を提供しないに簡単に変換するプログラム`ref`と`out`.)

型の署名のため`object`と`dynamic`同じと見なされます。 1 つの型で宣言されたメンバーできますしたがってされませんが異なるシグネチャでのみ`object`と`dynamic`します。

次の例では、一連のオーバー ロードされたメソッドの宣言とそのシグネチャを示します。
```csharp
interface ITest
{
    void F();                        // F()

    void F(int x);                   // F(int)

    void F(ref int x);               // F(ref int)

    void F(out int x);               // F(out int)      error

    void F(int x, int y);            // F(int, int)

    int F(string s);                 // F(string)

    int F(int x);                    // F(int)          error

    void F(string[] a);              // F(string[])

    void F(params string[] a);       // F(string[])     error
}
```

注意してください`ref`と`out`パラメーター修飾子 ([メソッド パラメーター](classes.md#method-parameters)) は、署名の一部です。 したがって、`F(int)`と`F(ref int)`は一意の署名。 ただし、`F(ref int)`と`F(out int)`、シグネチャがによって異なるため、同じインターフェイス内で宣言することはできません`ref`と`out`します。 また、戻り値の型を注と`params`修飾子に含まれていない、シグネチャの戻り値の型または包含または除外のみに基づいてオーバー ロードすることはできませんので、`params`修飾子。 これらのメソッドの宣言として`F(int)`と`F(params string[])`上に示したコンパイル時エラーが発生します。

## <a name="scopes"></a>スコープ

***スコープ***の名前が名前の修飾なしの名前で宣言されたエンティティを参照する、プログラム テキストの範囲。 スコープは、***入れ子になった***、内側のスコープを再宣言することがあります、外部スコープから名前の意味と (これは、ただし、削除されませんによって課される制限[宣言](basic-concepts.md#declarations)入れ子になったブロック内ではありません可能な限り、それを囲むブロック内のローカル変数と同じ名前でローカル変数を宣言する)。 外側のスコープの名前にしすることを言います***隠し***プログラムのリージョン内のテキストが内側のスコープでカバーし、外部名へのアクセスは、名前を修飾することによってのみ可能です。

*  宣言された名前空間のメンバーのスコープを*namespace_member_declaration* ([Namespace メンバー](namespaces.md#namespace-members)) それを囲むなしで*namespace_declaration*プログラム全体は、テキスト。
*  宣言された名前空間のメンバーのスコープを*namespace_member_declaration*内、 *namespace_declaration*の完全修飾名は`N`は、 *namespace_body*のすべて*namespace_declaration*の完全修飾名は`N`で始まるまたは`N`とピリオドが続く。
*  によって定義された名前のスコープ、 *extern_alias_directive*にわたる、 *using_directive*s、 *global_attributes*と*namespace_member_宣言*s がすぐに親のコンパイル単位または名前空間本文。 *Extern_alias_directive*基になる宣言領域に新しいメンバーは含まれません。 つまり、 *extern_alias_directive* 、推移的ではありませんが、コンパイル単位または名前空間本文のみが発生するのではなく、影響を与えます。
*  名前のスコープが定義されているまたはによってインポートされた、 *using_directive* ([ディレクティブを使用して](namespaces.md#using-directives)) にわたる、 *namespace_member_declaration*の s、 *compilation_unit*または*namespace_body*を*using_directive*に発生します。 A *using_directive* 0 個以上の名前空間、型またはメンバー名を特定内で使用できるように*compilation_unit*または*namespace_body*、しませんが、基になる宣言領域に新しいメンバーを追加します。 つまり、 *using_directive*は推移的ではありませんが、代わりにのみ影響、 *compilation_unit*または*namespace_body*それが出現します。
*  宣言された型パラメーターのスコープを*type_parameter_list*上、 *class_declaration* ([クラス クラスの宣言](classes.md#class-declarations)) は、 *class_base*、 *type_parameter_constraints_clause*秒、および*class_body*その*class_declaration*します。
*  宣言された型パラメーターのスコープを*type_parameter_list*上、 *struct_declaration* ([構造体の宣言](structs.md#struct-declarations)) は、 *struct_interfaces*、 *type_parameter_constraints_clause*秒、および*struct_body*その*struct_declaration*します。
*  宣言された型パラメーターのスコープを*type_parameter_list*上、 *interface_declaration* ([インターフェイスの宣言](interfaces.md#interface-declarations)) は、 *interface_base*、 *type_parameter_constraints_clause*秒、および*interface_body*その*interface_declaration*します。
*  宣言された型パラメーターのスコープを*type_parameter_list*上、 *delegate_declaration* ([デリゲートの宣言](delegates.md#delegate-declarations)) は、 *return_type*、 *formal_parameter_list*、および*type_parameter_constraints_clause*その s *delegate_declaration*します。
*  宣言されたメンバーのスコープを*class_member_declaration* ([クラス本体](classes.md#class-body)) は、 *class_body*の宣言が発生します。 クラス メンバーのスコープまで、さらに、 *class_body*これらのアクセシビリティ ドメインに含まれているクラスを派生 ([アクセシビリティ ドメイン](basic-concepts.md#accessibility-domains)) のメンバー。
*  宣言されたメンバーのスコープを*struct_member_declaration* ([構造体のメンバー](structs.md#struct-members)) は、 *struct_body*の宣言が発生します。
*  宣言されたメンバーのスコープ、 *enum_member_declaration* ([列挙型メンバー](enums.md#enum-members)) は、 *enum_body*の宣言が発生します。
*  宣言されたパラメーターのスコープを*method_declaration* ([メソッド](classes.md#methods)) は、 *method_body*その*method_declaration*します。
*  宣言されたパラメーターのスコープ、 *indexer_declaration* ([インデクサー](classes.md#indexers)) は、 *accessor_declarations*その*indexer_declaration*.
*  宣言されたパラメーターのスコープ、 *operator_declaration* ([演算子](classes.md#operators)) は、*ブロック*その*operator_declaration*します。
*  宣言されたパラメーターのスコープを*constructor_declaration* ([インスタンス コンス トラクター](classes.md#instance-constructors)) は、 *constructor_initializer*と*ブロック*その*constructor_declaration*します。
*  宣言されたパラメーターのスコープを*lambda_expression* ([匿名関数式](expressions.md#anonymous-function-expressions)) は、 *anonymous_function_body*その*lambda_式*
*  宣言されたパラメーターのスコープ、 *anonymous_method_expression* ([匿名関数式](expressions.md#anonymous-function-expressions)) は、*ブロック*その*anonymous_method_expression*します。
*  宣言されているラベルのスコープを*labeled_statement* ([というラベルの付いたステートメント](statements.md#labeled-statements)) は、*ブロック*の宣言が発生します。
*  宣言されたローカル変数のスコープを*local_variable_declaration* ([ローカル変数宣言](statements.md#local-variable-declarations)) ブロックの宣言が発生します。
*  宣言されたローカル変数のスコープを*switch_block*の`switch`ステートメント ([switch ステートメント](statements.md#the-switch-statement)) は、 *switch_block*します。
*  宣言されたローカル変数のスコープを*for_initializer*の`for`ステートメント ([、ステートメントの](statements.md#the-for-statement)) は、 *for_initializer*、 *for_condition*、 *for_iterator*、格納されていると*ステートメント*の`for`ステートメント。
*  宣言されたローカル定数のスコープを*local_constant_declaration* ([ローカル定数宣言](statements.md#local-constant-declarations)) ブロックの宣言が発生します。 前にあるテキストの位置でのローカル定数を参照すると、コンパイル時エラーがその*constant_declarator*します。
*  変数のスコープが宣言の一部として、 *foreach_statement*、 *using_statement*、 *lock_statement*または*query_expression*は特定の構造の拡張によって決まります。

名前空間、クラス、構造体、または列挙型メンバーのスコープ内のメンバーの宣言の前にあるテキストの位置にメンバーを参照することです。 次に例を示します。
```csharp
class A
{
    void F() {
        i = 1;
    }

    int i = 0;
}
```
ここでは、それが有効で`F`を参照する`i`宣言されています。

前にあるテキストの位置にローカル変数を参照すると、コンパイル時エラーは、ローカル変数のスコープ内で、 *local_variable_declarator*のローカル変数。 次に例を示します。
```csharp
class A
{
    int i = 0;

    void F() {
        i = 1;                  // Error, use precedes declaration
        int i;
        i = 2;
    }

    void G() {
        int j = (j = 1);        // Valid
    }

    void H() {
        int a = 1, b = ++a;    // Valid
    }
}
```

`F`上記のメソッドは、最初の割り当てを`i`具体的には、外側のスコープで宣言されているフィールドを参照しません。 代わりに、ローカル変数を参照し、代入変数の宣言にコンパイル時エラーが発生します。 `G`メソッドは、の使用`j`の宣言の初期化子で`j`ため、使用前に有効では、 *local_variable_declarator*します。 `H`メソッドは、後ろに続く*local_variable_declarator*以前で宣言されたローカル変数を正しく指す*local_variable_declarator*内で同じ*local_variable_declaration*します。

ローカル変数のスコープ規則は、式のコンテキストで使用される名前の意味が常に同じであるブロック内で保証するために設計されています。 ローカル変数のスコープ、ブロックの末尾に、宣言からのみを拡張する場合は、上記の例では、最初の代入は、インスタンス変数、2 つ目の代入はローカル変数につながる可能性があります。ブロックのステートメントが再整列される以降の場合のコンパイル時エラー。

ブロック内で名前の意味は、名前が使用されるコンテキストに応じて異なる場合があります。 例
```csharp
using System;

class A {}

class Test
{
    static void Main() {
        string A = "hello, world";
        string s = A;                            // expression context

        Type t = typeof(A);                      // type context

        Console.WriteLine(s);                    // writes "hello, world"
        Console.WriteLine(t);                    // writes "A"
    }
}
```
名前`A`式のコンテキストでローカル変数を参照するために使用`A`と、クラスを参照する型のコンテキストで`A`します。

### <a name="name-hiding"></a>名前の隠ぺい

通常、エンティティのスコープには、エンティティの宣言領域よりも多くのプログラム テキストが含まれます。 具体的には、エンティティのスコープは、同じ名前のエンティティを含む新しい宣言空間を導入する宣言を含めることができます。 このような宣言により、元のエンティティになる***隠し***します。 逆に、エンティティがあると言えます***表示***非表示しない場合。

名前の非表示には、スコープが入れ子スコープが継承によるオーバー ラップしてが重複する場合に発生します。 次のセクションでは、2 種類の非表示の特性を説明します。

#### <a name="hiding-through-nesting"></a>入れ子を非表示

入れ子による名前の隠ぺいは、名前空間またはクラスまたは構造体、およびパラメーターやローカル変数の宣言型の入れ子の結果として、名前空間内の型の入れ子の結果として発生します。

例
```csharp
class A
{
    int i = 0;

    void F() {
        int i = 1;
    }

    void G() {
        i = 1;
    }
}
```
内で、`F`メソッドは、インスタンス変数`i`ローカル変数によって隠されている`i`が内、`G`メソッド、`i`インスタンス変数を参照します。

内側のスコープに名前が外側のスコープでの名前を非表示にすると、その名前のすべてのオーバー ロードされた出現箇所は非表示になります。 例
```csharp
class Outer
{
    static void F(int i) {}

    static void F(string s) {}

    class Inner
    {
        void G() {
            F(1);              // Invokes Outer.Inner.F
            F("Hello");        // Error
        }

        static void F(long l) {}
    }
}
```
呼び出し`F(1)`呼び出す、`F`で宣言されている`Inner`ため、外部出現するすべての`F`内部宣言では表示されません。 同じ理由、呼び出しから`F("Hello")`コンパイル時エラーが発生します。

#### <a name="hiding-through-inheritance"></a>継承によって非表示

継承による名前の隠ぺいは、クラスまたは構造体の基本クラスから継承した名前を再宣言するときに発生します。 この種類の名前の隠ぺいは、次の種類のいずれかです。

*  定数、フィールド、プロパティ、イベント、またはクラスまたは構造体で導入された型と同じ名前のすべての基底クラス メンバーを非表示にします。
*  クラスまたは構造体で導入されたメソッドには、同じ名前を持つすべてのメソッド以外の基本クラス メンバーと (メソッド名とパラメーターの数、修飾子、および種類) は、同じシグネチャを持つすべての基底クラス メソッドが非表示にします。
*  クラスまたは構造体で導入されたインデクサーには、(パラメーターの数と型) は、同じシグネチャを持つすべての基底クラス インデクサーが非表示にします。

演算子の宣言に関する規則 ([演算子](classes.md#operators)) 基本クラスでは演算子として同じシグネチャを持つ演算子を宣言する派生クラスを使用できなくなります。 そのため、演算子が互いの演算子を隠ぺいすることはありません。

外側のスコープから名前を非表示とは異なりは、継承したスコープからアクセス可能な名前を非表示と、警告が報告されます。 例
```csharp
class Base
{
    public void F() {}
}

class Derived: Base
{
    public void F() {}        // Warning, hiding an inherited name
}
```
宣言`F`で`Derived`により警告が報告されます。 継承された名前を非表示でない具体的には、エラーを基底クラスの個別の進化を来たすため。 たとえば、上記のような状況が発生する以降のバージョンの`Base`導入された、`F`以前のバージョンのクラスには存在しなかったメソッド。 上記のような状況は、エラーになっていた、個別にバージョン管理されたクラス ライブラリで基底クラスへの変更可能性がある可能性が派生クラスを無効になります。

使用して、継承された名前を非表示にして警告を取り除くことができます、`new`修飾子。
```csharp
class Base
{
    public void F() {}
}

class Derived: Base
{
    new public void F() {}
}
```

`new`修飾子には、ことを示します、`F`で`Derived`はこれが実際にものである継承されたメンバーを非表示にして"new"。

新しいメンバーの宣言では、新しいメンバーのスコープ内でのみ、継承されたメンバーを非表示にします。

```csharp
class Base
{
    public static void F() {}
}

class Derived: Base
{
    new private static void F() {}    // Hides Base.F in Derived only
}

class MoreDerived: Derived
{
    static void G() { F(); }          // Invokes Base.F
}
```

宣言の前の例では`F`で`Derived`を非表示に、`F`から継承されている`Base`、ただし、新しい`F`で`Derived`プライベート アクセスは、そのスコープには適用されません`MoreDerived`. したがって、呼び出し`F()`で`MoreDerived.G`が有効では呼び出す`Base.F`します。

## <a name="namespace-and-type-names"></a>Namespace と型の名前

内のいくつかのコンテキストをC#プログラムが必要な*namespace_name*または*type_name*を指定します。

```antlr
namespace_name
    : namespace_or_type_name
    ;

type_name
    : namespace_or_type_name
    ;

namespace_or_type_name
    : identifier type_argument_list?
    | namespace_or_type_name '.' identifier type_argument_list?
    | qualified_alias_member
    ;
```

A *namespace_name*は、 *namespace_or_type_name*名前空間を参照します。 以下に示すように、解像度を次の*namespace_or_type_name*の*namespace_name* 、名前空間を参照する必要がありますそれ以外の場合、コンパイル時エラーが発生します。 型引数なし ([引数を入力](types.md#type-arguments)) で使用できる、 *namespace_name* (専用の種類には、型引数を指定できます)。

A *type_name*は、 *namespace_or_type_name*型を参照します。 以下に示すように、解像度を次、 *namespace_or_type_name*の*type_name*型を参照する必要がありますそれ以外の場合、コンパイル時エラーが発生します。

場合、 *namespace_or_type_name*修飾-エイリアス - メンバーの意味は」の説明に従って[Namespace エイリアス修飾子](namespaces.md#namespace-alias-qualifiers)します。 それ以外の場合、 *namespace_or_type_name*が 4 つの形式のいずれか。

*  `I`
*  `I<A1, ..., Ak>`
*  `N.I`
*  `N.I<A1, ..., Ak>`

場所`I`、単一の識別子は、`N`は、 *namespace_or_type_name*と`<A1, ..., Ak>`は省略可能な*type_argument_list*。 ない場合*type_argument_list*が指定するを検討してください`k`を 0 にします。

意味を*namespace_or_type_name*は次のように決定されます。

*   場合、 *namespace_or_type_name*の形式は`I`またはフォームの`I<A1, ..., Ak>`:
    * 場合`K`ゼロ、 *namespace_or_type_name*ジェネリック メソッドの宣言内で表示されます ([メソッド](classes.md#methods)) し、その宣言には、型パラメーターが含まれている場合 ([型パラメーター](classes.md#type-parameters)) 名前を持つ `I`、 *namespace_or_type_name*その型パラメーターを参照します。
    * の場合、 *namespace_or_type_name*型の宣言内で次の各インスタンス タイプが表示されます `T`([インスタンス型](classes.md#the-instance-type))、その型のインスタンスの型宣言と各外側のクラスまたは構造体の宣言のインスタンスの型 (存在する場合) を続行します。
        * 場合`K`は 0 との宣言`T`名前の型パラメーターを含む `I`、 *namespace_or_type_name*その型パラメーターを参照します。
        * の場合、 *namespace_or_type_name*型の宣言の本文内に表示し、`T`またはその基本型の名前を持つ入れ子になったアクセス可能な型が含まれている `I`と`K`  パラメーターを入力し、 *namespace_or_type_name*は特定の型引数を使用して構築する型を表します。 このような 1 つ以上の型がある場合より強い派生型で宣言された型が選択されます。 意味を決定するときに、非型のメンバー (定数、フィールド、メソッド、プロパティ、インデクサー、演算子、インスタンス コンス トラクター、デストラクター、および静的コンス トラクター) と型パラメーターの数が異なる型のメンバーが無視されることに注意してください、*namespace_or_type_name*します。
    * かどうか、前の手順を各名前空間の次に、失敗しました `N`を名前空間を以降の*namespace_or_type_name*外側にある各名前空間 (存在する場合) を続行し、終わるが発生した、グローバル名前空間、エンティティが見つかるまで、次の手順が評価されます。
        * 場合`K`ゼロと`I`で名前空間の名前を指定 `N`、し。
            * 場合、場所を*namespace_or_type_name*が発生した名前空間の宣言で囲まれた`N`名前空間宣言が含まれています、 *extern_alias_directive*または*using_alias_directive*名前に関連付ける `I`型、または名前空間、 *namespace_or_type_name*があいまいですし、コンパイル時エラーが発生します。
            * それ以外の場合、 *namespace_or_type_name*という名前の名前空間を指す`I`で`N`します。
        * の場合`N`名前を持つアクセス可能な型が含まれています `I`と`K` し、パラメーターを入力します。
            * 場合`K`は 0 と場所を*namespace_or_type_name*が発生した名前空間の宣言で囲まれた`N`名前空間宣言が含まれています、 *extern_alias_directive*または*using_alias_directive*名前に関連付ける `I`型、または名前空間、 *namespace_or_type_name*あいまいな、コンパイル時にエラーが発生します。
            * それ以外の場合、 *namespace_or_type_name*は特定の型引数を使用して構築型を表します。
        * の場合、場所を、 *namespace_or_type_name*が発生した名前空間の宣言で囲まれた`N`:
            * 場合`K`がゼロで、名前空間宣言が含まれています、 *extern_alias_directive*または*using_alias_directive*名前に関連付ける `I`でインポートされた名前空間または型、 *namespace_or_type_name*その名前空間または型を参照します。
            * それ以外の場合、名前空間と型の宣言をインポートした場合、 *using_namespace_directive*s と*using_alias_directive*名前空間宣言の s がアクセス可能な型の 1 つだけを含める名前を持つ `I`と`K` パラメーター、入力、 *namespace_or_type_name*は特定の型引数を使用して構築する型を表します。
            * それ以外の場合、名前空間と型の宣言をインポートした場合、 *using_namespace_directive*s と*using_alias_directive*名前空間の宣言の 1 つ以上のアクセス可能な型を含めることが名前を持つ `I`と`K` パラメーター、入力、 *namespace_or_type_name*があいまい、エラーが発生します。
    * それ以外の場合、 *namespace_or_type_name*は未定義となり、コンパイル時エラーが発生します。
*  それ以外の場合、 *namespace_or_type_name*の形式は`N.I`またはフォームの`N.I<A1, ..., Ak>`します。 `N` として解決は、まず、 *namespace_or_type_name*します。 場合の解像度`N`が成功すると、コンパイル時エラーが発生します。 それ以外の場合、`N.I`または`N.I<A1, ..., Ak>`次のように解決されます。
    * 場合`K`ゼロと`N`参照名前空間と`N`入れ子になった名前空間が含まれています`I`、 *namespace_or_type_name*その入れ子になった名前空間を参照します。
    * の場合`N`参照名前空間と`N`名前を持つアクセス可能な型が含まれています `I`と`K` パラメーターを入力し、 *namespace_or_type_name*参照その型指定された型引数を使用して構築します。
    * の場合`N`(場合によって構築された) クラスまたは構造体の型を参照し、`N`またはその基本クラスの名前を持つ入れ子になったアクセス可能な型が含まれている `I`と`K`  、パラメーターの型*namespace_or_type_name*は特定の型引数を使用して構築する型を表します。 このような 1 つ以上の型がある場合より強い派生型で宣言された型が選択されます。 場合の意味に注意してください`N.I`解決の基底クラスの指定の一部として特定する複素数が`N`の直接の基本クラスから`N`オブジェクトと見なされます ([基底クラス](classes.md#base-classes))。
    * それ以外の場合、`N.I`は無効な*namespace_or_type_name*コンパイル時エラーが発生したとします。

A *namespace_or_type_name*静的クラスの参照が許可されている ([静的クラス](classes.md#static-classes)) 場合にのみ

*  *Namespace_or_type_name*は、`T`で、 *namespace_or_type_name*フォームの`T.I`、または
*  *Namespace_or_type_name*は、`T`で、 *typeof_expression* ([引数リスト](expressions.md#argument-lists)1) フォームの`typeof(T)`します。

### <a name="fully-qualified-names"></a>完全修飾名

すべての名前空間と型に、***完全修飾名***、名前空間または他のすべてのユーザーの間で型を一意に識別します。 名前空間または型の完全修飾名`N`は次のように決定されます。

*  場合`N`メンバーは、その完全修飾名には、グローバル名前空間の`N`します。
*  その完全修飾名は、それ以外の場合、`S.N`ここで、 `S` 、名前空間の種類の完全修飾名は、`N`は宣言されています。

完全修飾名、つまり`N`につながる識別子の完全な階層パスは、 `N`、グローバル名前空間から開始します。 名前空間または型のすべてのメンバーには、一意の名前を持つ必要があります、ために、名前空間または型の完全修飾名が常に一意であることに従います。

次の例では、関連付けられている、完全修飾名と名前空間と型の宣言をいくつかを示します。
```csharp
class A {}                // A

namespace X               // X
{
    class B               // X.B
    {
        class C {}        // X.B.C
    }

    namespace Y           // X.Y
    {
        class D {}        // X.Y.D
    }
}

namespace X.Y             // X.Y
{
    class E {}            // X.Y.E
}
```

## <a name="automatic-memory-management"></a>自動メモリ管理

C# 開発者は手動での割り当てとオブジェクトによって占有されているメモリを解放してから、自動メモリ管理を採用しています。 自動メモリ管理ポリシーがによって実装される、***ガベージ コレクター***します。 オブジェクトのメモリ管理のライフ サイクルは次のとおりです。

1. オブジェクトが作成されたときに、メモリが割り当てられたし、コンス トラクターを実行すると、オブジェクトは、ライブと見なされます。
2. 場合は、オブジェクトまたはその一部は、実行可能な継続がアクセスできない、デストラクターの実行以外オブジェクトと見なされ不要になった使用中で破壊の対象になります。 C# コンパイラと、ガベージ コレクターは、オブジェクトへの参照は、今後使用される可能性がありますを決定するコードを分析できます。 たとえば、スコープ内のローカル変数は、オブジェクトを唯一の参照から、現在実行中の実行の手順でポイントをそのローカル変数が参照されない場合は、ガベージ コレクターについて、可能性があります (がないです。ために必要) 使用されていないと、オブジェクトを処理します。
3. 時間、デストラクターを後で指定されていない一部のオブジェクトが破壊の対象とすると ([デストラクター](classes.md#destructors)) (あれば) のオブジェクトを実行します。 通常の状況で、オブジェクトのデストラクターは実装に固有の Api は、オーバーライドするには、この動作を使用する可能性がありますが 1 回だけ実行されます。
4. デストラクターの実行を含む実行可能な継続して、そのオブジェクトまたはその一部にアクセスできない場合、オブジェクトのデストラクターが実行されると、オブジェクトがアクセスできないと見なされます、オブジェクトがコレクションの対象になります。
5. 最後に、いくつかの時点で、オブジェクトがコレクションの対象になると、ガベージ コレクターが解放そのオブジェクトに関連付けられているメモリ。

ガベージ コレクターは、オブジェクトの使用方法に関する情報を保持し、メモリ管理、決定を行うなど、オブジェクト、およびオブジェクトを再配置がなくなったときに使用されていたり、新しく作成されたオブジェクトを検索するためのメモリ内の場所はこの情報を使用します。

ガベージ コレクターの存在を前提としている他の言語と同様に c# もはガベージ コレクターがさまざまなメモリ管理ポリシーを実装できるように設計されています。 たとえば、c# は必要ありませんデストラクターの実行は、対象となるとすぐに、オブジェクトを収集またはデストラクターの実行します。

クラスの静的メソッドを使用して、ある程度までのガベージ コレクターの動作を制御できます`System.GC`します。 このクラスは、コレクションの実行 (または実行されません)、デストラクターの実行を要求するために使用してなど。

ガベージ コレクターがオブジェクトを収集し、デストラクターを実行する状況の判断に広くを許可されているために、準拠した実装は次のコードで示されているのとは異なる出力を生成可能性があります。 プログラム
```csharp
using System;

class A
{
    ~A() {
        Console.WriteLine("Destruct instance of A");
    }
}

class B
{
    object Ref;

    public B(object o) {
        Ref = o;
    }

    ~B() {
        Console.WriteLine("Destruct instance of B");
    }
}

class Test
{
    static void Main() {
        B b = new B(new A());
        b = null;
        GC.Collect();
        GC.WaitForPendingFinalizers();
    }
}
```
クラスのインスタンスを作成します`A`クラスのインスタンスと`B`します。 これらのオブジェクトがガベージ コレクションの対象になるときに変数`b`値が割り当てられている`null`この時刻より後ではないためそれらにアクセスするユーザーが記述したコードを可能な。 出力は、いずれか
```
Destruct instance of A
Destruct instance of B
```
または
```
Destruct instance of B
Destruct instance of A
```
注文の言語の制約がないため、オブジェクトはガベージ コレクションです。

わかりにくい場合は、「消滅できる」と「コレクションの対象」の違いは重要にできます。 例えば以下のようにします。
```csharp
using System;

class A
{
    ~A() {
        Console.WriteLine("Destruct instance of A");
    }

    public void F() {
        Console.WriteLine("A.F");
        Test.RefA = this;
    }
}

class B
{
    public A Ref;

    ~B() {
        Console.WriteLine("Destruct instance of B");
        Ref.F();
    }
}

class Test
{
    public static A RefA;
    public static B RefB;

    static void Main() {
        RefB = new B();
        RefA = new A();
        RefB.Ref = RefA;
        RefB = null;
        RefA = null;

        // A and B now eligible for destruction
        GC.Collect();
        GC.WaitForPendingFinalizers();

        // B now eligible for collection, but A is not
        if (RefA != null)
            Console.WriteLine("RefA is not null");
    }
}
```

ガベージ コレクターがのデストラクターを実行する場合は、上記のプログラムで`A`のデストラクターの前に`B`、このプログラムの出力である可能性があります。
```
Destruct instance of A
Destruct instance of B
A.F
RefA is not null
```

インスタンス`A`使用されていないと`A`のデストラクターが実行された、方法のことができますが`A`(この場合、 `F`) 別のデストラクターから呼び出されます。 また、デストラクターの実行は、オブジェクトをもう一度でメインライン プログラムから使用可能な状態で発生する可能性がありますに注意してください。 ここでの実行`B`デストラクターは、インスタンスの原因となった`A`が以前ではなくを使用するライブ参照からアクセスできるように`Test.RefA`します。 呼び出し後`WaitForPendingFinalizers`のインスタンス`B`が、コレクションが、インスタンスの対象である`A`、参照が原因でない`Test.RefA`します。

混乱や予期しない動作を避けるため、一般に、お勧めのデストラクターのみ、オブジェクトのフィールドに格納されているデータに対してクリーンアップを実行してを参照先のオブジェクトまたは静的フィールドに対するアクションは実行が。

デストラクターを使用する代わりには、実装クラスを使用する、`System.IDisposable`インターフェイス。 これにより、クライアントは、リソースとして、オブジェクトにアクセスして、通常、オブジェクトのリソースを解放するタイミングを決定するオブジェクトの`using`ステートメント ([、ステートメントを使用して](statements.md#the-using-statement))。

## <a name="execution-order"></a>実行順序

C# プログラムの実行は、各実行中のスレッドの副作用が重大な実行ポイントで維持されるように進みます。 A***副作用***読み取りまたは書き込み volatile フィールドの非揮発性変数への書き込み、外部のリソースと、例外のスローへの書き込みとして定義されます。 副作用の順序を保持する必要がある重大な実行ポイントは volatile フィールドへの参照 ([Volatile フィールド](classes.md#volatile-fields))、`lock`ステートメント ([lock ステートメント](statements.md#the-lock-statement))、およびスレッドの作成と終了します。 実行環境では、次の制約を前提と c# プログラムの実行の順序を変更する無料です。

*  データの依存関係は、実行のスレッド内で保持されます。 つまり、各変数の値は、スレッドのすべてのステートメントは、元のプログラムの順序で実行されたかのように計算されます。
*  初期化の順序の規則は保持されます ([フィールドの初期化](classes.md#field-initialization)と[変数初期化子](classes.md#variable-initializers))。
*  揮発性の読み取りと書き込みに関して、副作用の順序は保持されます ([Volatile フィールド](classes.md#volatile-fields))。 さらに、その式の値が使用されないことと、必要な副作用は生成されません (メソッドの呼び出しまたは volatile フィールドへのアクセスが原因でいずれかを含む) を推定できる場合、実行環境は式の一部を評価しない必要があります。 (別のスレッドによってスローされる例外) など、非同期イベントでは、プログラムの実行が中断された場合、監視可能な副作用が元のプログラムの順序で表示されることは限りません。
