---
ms.openlocfilehash: ff31585520c9090ad92893a930327112743c8e77
ms.sourcegitcommit: 892af9016b3317a8fae12d195014dc38ba51cf16
ms.translationtype: MT
ms.contentlocale: ja-JP
ms.lasthandoff: 10/01/2019
ms.locfileid: "71704004"
---
# <a name="basic-concepts"></a>基本的な概念

## <a name="application-startup"></a>アプリケーションの起動

***エントリポイント***を持つアセンブリは、***アプリケーション***と呼ばれます。 アプリケーションを実行すると、新しい***アプリケーションドメイン***が作成されます。 アプリケーションの複数の異なるインスタンス化が同時に同じコンピューター上に存在し、それぞれに独自のアプリケーションドメインが存在する場合があります。

アプリケーションドメインは、アプリケーションの状態のコンテナーとして機能することによって、アプリケーションの分離を可能にします。 アプリケーションドメインは、アプリケーションで定義されている型とそれが使用するクラスライブラリのコンテナーおよび境界として機能します。 1つのアプリケーションドメインに読み込まれる型は、別のアプリケーションドメインに読み込まれる同じ型とは異なり、オブジェクトのインスタンスはアプリケーションドメイン間で直接共有されません。 たとえば、各アプリケーションドメインには、これらの型の静的変数の独自のコピーがあり、型の静的コンストラクターはアプリケーションドメインごとに1回だけ実行されます。 実装には、アプリケーションドメインの作成と破棄を行うための実装固有のポリシーやメカニズムを無料で用意しています。

***アプリケーションの起動***は、実行環境が、アプリケーションのエントリポイントと呼ばれる指定されたメソッドを呼び出すと発生します。 このエントリポイントメソッドは常に `Main` という名前で、次のいずれかのシグネチャを持つことができます。

```csharp
static void Main() {...}

static void Main(string[] args) {...}

static int Main() {...}

static int Main(string[] args) {...}
```

示されているように、エントリポイントは必要に応じて @no__t 0 の値を返す場合があります。 この戻り値は、アプリケーションの終了 ([アプリケーションの終了](basic-concepts.md#application-termination)) で使用されます。

エントリポイントには、必要に応じて、1つの仮パラメーターを指定できます。 パラメーターには任意の名前を指定できますが、パラメーターの型は @no__t 0 にする必要があります。 仮パラメーターが存在する場合、実行環境は、アプリケーションの起動時に指定されたコマンドライン引数を含む @no__t 0 引数を作成して渡します。 @No__t-0 引数は null ではありませんが、コマンドライン引数が指定されていない場合、長さが0になることがあります。

でC#はメソッドのオーバーロードがサポートされているため、クラスまたは構造体には、それぞれ異なるシグネチャを持つメソッドの複数の定義を含めることができます。 ただし、1つのプログラム内で、クラスまたは構造体には、アプリケーションのエントリポイントとして使用されることを修飾する定義を持つ `Main` という2つ以上のメソッドを含めることができます。 ただし、複数のパラメーターがある場合、またはその唯一のパラメーターが型 `string[]` 以外の場合は、`Main` の他のオーバーロードされたバージョンを使用できます。

アプリケーションは、複数のクラスまたは構造体で構成できます。 これらのクラスまたは構造体の1つに、アプリケーションのエントリポイントとして使用されることを定義する `Main` という名前のメソッドを含めることができます。 このような場合は、外部機構 (コマンドラインコンパイラオプションなど) を使用して、これらの `Main` メソッドのいずれかをエントリポイントとして選択する必要があります。

でC#は、すべてのメソッドをクラスまたは構造体のメンバーとして定義する必要があります。 通常、メソッドのアクセシビリティ ([アクセシビリティ宣言](basic-concepts.md#declared-accessibility)) は、宣言で指定されているアクセス修飾子 ([アクセス修飾子](classes.md#access-modifiers)) によって決定されます。また、型の宣言されたアクセシビリティは、宣言で指定されたアクセス修飾子。 特定の型の特定のメソッドを呼び出し可能にするためには、型とメンバーの両方にアクセスできる必要があります。 ただし、アプリケーションのエントリポイントは特殊なケースです。 具体的には、実行環境は、宣言されたアクセシビリティに関係なく、それを囲む型宣言のアクセシビリティに関係なく、アプリケーションのエントリポイントにアクセスできます。

アプリケーションエントリポイントメソッドがジェネリッククラス宣言に含まれていない可能性があります。

それ以外の点では、エントリポイントメソッドはエントリポイントではないもののように動作します。

## <a name="application-termination"></a>アプリケーションの終了

***アプリケーションの終了***では、実行環境に制御が戻ります。

アプリケーションの***エントリポイント***メソッドの戻り値の型が `int` の場合、返される値はアプリケーションの***終了ステータスコード***として機能します。 このコードの目的は、実行環境への成功または失敗の通信を許可することです。

エントリポイントメソッドの戻り値の型が `void` の場合、そのメソッドを終了する右中かっこ (`}`) に到達するか、式のない `return` ステートメントを実行すると、終了状態コードは `0` になります。

アプリケーションの終了前に、ガベージコレクションされていないすべてのオブジェクトのデストラクターが呼び出されます。ただし、このようなクリーンアップが抑制されている場合 (ライブラリメソッドの呼び出しによって `GC.SuppressFinalize` など) が発生する場合は除きます。

## <a name="declarations"></a>宣言

C#プログラムの宣言は、プログラムの構成要素を定義します。 C#プログラムは名前空間 ([名前空間](namespaces.md)) を使用して編成され、型宣言と入れ子になった名前空間宣言を含めることができます。 型宣言 ([型宣言](namespaces.md#type-declarations)) は、クラス ([クラス](classes.md))、構造体 ([構造体](structs.md))、インターフェイス ([インターフェイス](interfaces.md))、列挙型 ([列挙](enums.md)型)、およびデリゲート ([デリゲート](delegates.md)) を定義するために使用されます。 型宣言で許可されるメンバーの種類は、型宣言の形式によって異なります。 たとえば、クラス宣言には、定数 ([定数](classes.md#constants))、フィールド ([フィールド](classes.md#fields))、メソッド ([メソッド](classes.md#methods))、プロパティ ([プロパティ](classes.md#properties))、イベント ([イベント](classes.md#events))、インデクサー ([インデクサー](classes.md#indexers)) の宣言を含めることができます。演算子 ([演算子](classes.md#operators))、インスタンスコンストラクター ([インスタンスコンストラクター](classes.md#instance-constructors))、静的コンストラクター ([静的コンストラクター](classes.md#static-constructors))、デストラクター ([デストラクター](classes.md#destructors))、および入れ子にされた型 (入れ子にされた[型](classes.md#nested-types))。

宣言は、宣言が属する宣言***空間***内の名前を定義します。 オーバーロードされたメンバー ([シグネチャおよびオーバーロード](basic-concepts.md#signatures-and-overloading)) を除き、宣言空間で同じ名前のメンバーを導入する2つ以上の宣言があると、コンパイル時にエラーになります。 宣言空間には、同じ名前を持つ異なる種類のメンバーを含めることはできません。 たとえば、宣言空間には、同じ名前のフィールドとメソッドを含めることはできません。

次に示すように、さまざまな種類の宣言スペースがあります。

*  プログラムのすべてのソースファイル内で、 *namespace_member_declaration*s と外側の*namespace_declaration*は、***グローバル宣言空間***と呼ばれる1つの結合された宣言空間のメンバーになります。
*  プログラムのすべてのソースファイル内で、 *namespace_declaration*内の*namespace_member_declaration*s は、完全修飾された同じ名前空間名を持つ1つの組み合わせの宣言空間のメンバーになります。
*  クラス、構造体、またはインターフェイスの宣言ごとに、新しい宣言領域が作成されます。 名前は、 *class_member_declaration*s、 *struct_member_declaration*s、 *interface_member_declaration*s、または*type_parameter*s を介してこの宣言領域に導入されます。 オーバーロードされたインスタンスコンストラクター宣言と静的コンストラクター宣言を除き、クラスまたは構造体には、クラスまたは構造体と同じ名前を持つメンバー宣言を含めることはできません。 クラス、構造体、またはインターフェイスは、オーバーロードされたメソッドとインデクサーの宣言を許可します。 さらに、クラスまたは構造体は、オーバーロードされたインスタンスコンストラクターと演算子の宣言を許可します。 たとえば、クラス、構造体、またはインターフェイスには、同じ名前を持つ複数のメソッド宣言が含まれている場合があります。これらのメソッド宣言がシグネチャ ([シグネチャとオーバーロード](basic-concepts.md#signatures-and-overloading)) で異なる場合に限ります。 基底クラスはクラスの宣言空間に関与しないことに注意してください。基本インターフェイスは、インターフェイスの宣言空間に関与しません。 したがって、派生クラスまたはインターフェイスは、継承されたメンバーと同じ名前を持つメンバーを宣言できます。 このようなメンバーは、継承されたメンバーを***非表示***にすると言います。
*  各デリゲート宣言によって、新しい宣言空間が作成されます。 名前は、仮パラメーター (*fixed_parameter*s and *parameter_array*s) と*type_parameter*s を使用して、この宣言領域に導入されます。
*  列挙型の宣言ごとに、新しい宣言空間が作成されます。 名前は、 *enum_member_declarations*を介してこの宣言領域に導入されます。
*  各メソッド宣言、インデクサー宣言、演算子宣言、インスタンスコンストラクター宣言、および匿名関数は、***ローカル変数宣言空間***と呼ばれる新しい宣言領域を作成します。 名前は、仮パラメーター (*fixed_parameter*s and *parameter_array*s) と*type_parameter*s を使用して、この宣言領域に導入されます。 関数メンバーまたは匿名関数 (存在する場合) の本体は、ローカル変数宣言領域内で入れ子になっていると見なされます。 ローカル変数宣言空間と入れ子になったローカル変数宣言空間が同じ名前の要素を含むようにすると、エラーになります。 したがって、入れ子になった宣言領域内では、ローカル変数または定数を、外側の宣言空間内のローカル変数または定数と同じ名前で宣言することはできません。 2つの宣言空間に、同じ名前の要素を含めることができます。ただし、宣言領域に他方の要素が含まれている必要はありません。
*  各*ブロック*または*switch_block* 、および*for*、 *foreach* 、および*using*ステートメントでは、ローカル変数とローカル定数のローカル変数宣言空間が作成されます。 名前は、 *local_variable_declaration*s と*local_constant_declaration*s を介してこの宣言領域に導入されます。 関数メンバーまたは匿名関数の本体内またはその内部で発生するブロックは、それらのパラメーターの関数によって宣言されたローカル変数宣言領域内で入れ子になっています。 したがって、ローカル変数を持つメソッドや、同じ名前のパラメーターを使用すると、エラーになります。
*  各*ブロック*または*switch_block*は、ラベル用に個別の宣言領域を作成します。 名前は*labeled_statement*s を介してこの宣言領域に導入され、名前は*goto_statement*s を介して参照されます。 ブロックの***ラベル宣言領域***には、入れ子になったブロックが含まれます。 したがって、入れ子になったブロック内では、外側のブロックでラベルと同じ名前のラベルを宣言することはできません。

名前が宣言される文字列の順序は、一般に意味がありません。 特に、名前空間、定数、メソッド、プロパティ、イベント、インデクサー、演算子、インスタンスコンストラクター、デストラクター、静的コンストラクター、および型の宣言と使用については、テキストの順序は重要ではありません。 宣言の順序は、次の点で重要です。

*  フィールド宣言とローカル変数宣言の宣言順序によって、初期化子 (存在する場合) が実行される順序が決まります。
*  ローカル変数は、使用する前に定義する必要があります ([スコープ](basic-concepts.md#scopes))。
*  列挙メンバー宣言 ([列挙メンバー](enums.md#enum-members)) の宣言順序は、 *constant_expression*値を省略した場合に重要になります。

名前空間の宣言領域は "open 終了" であり、同じ完全修飾名を持つ2つの名前空間宣言は、同じ宣言空間に関与します。 次に例を示します。
```csharp
namespace Megacorp.Data
{
    class Customer
    {
        ...
    }
}

namespace Megacorp.Data
{
    class Order
    {
        ...
    }
}
```

上記の2つの名前空間宣言は同じ宣言領域に寄与します。この例では、完全修飾名を使用して2つのクラスを宣言します (`Megacorp.Data.Customer` および `Megacorp.Data.Order`)。 2つの宣言は同じ宣言領域に関与するため、それぞれに同じ名前のクラスの宣言が含まれていると、コンパイル時エラーが発生します。

前述のように、ブロックの宣言空間には、入れ子になったブロックが含まれます。 したがって、次の例では、`F` と `G` の各メソッドはコンパイル時エラーになります。これは、名前 `i` が外側のブロックで宣言されており、内部ブロックで再宣言できないためです。 ただし、2つの `i` が入れ子になっていない個別のブロックで宣言されているため、`H` および `I` の各メソッドは有効です。

```csharp
class A
{
    void F() {
        int i = 0;
        if (true) {
            int i = 1;            
        }
    }

    void G() {
        if (true) {
            int i = 0;
        }
        int i = 1;                
    }

    void H() {
        if (true) {
            int i = 0;
        }
        if (true) {
            int i = 1;
        }
    }

    void I() {
        for (int i = 0; i < 10; i++)
            H();
        for (int i = 0; i < 10; i++)
            H();
    }
}
```

## <a name="members"></a>メンバー

名前空間と型には***メンバー***があります。 エンティティのメンバーは、エンティティへの参照で始まる修飾名を使用し、その後に "@no__t 0" トークン、その後にメンバーの名前を指定することで、一般に使用できます。

型のメンバーは、型宣言で宣言されているか、型の基底クラスから***継承***されています。 型が基本クラスから継承する場合、インスタンスコンストラクター、デストラクター、および静的コンストラクターを除く、基本クラスのすべてのメンバーが派生型のメンバーになります。 基底クラスのメンバーに対して宣言されたアクセシビリティでは、メンバーが継承されるかどうかは制御されません。継承は、インスタンスコンストラクター、静的コンストラクター、またはデストラクターではない任意のメンバーに及びます。 ただし、継承されたメンバーは、アクセシビリティが宣言されている ([アクセシビリティが宣言](basic-concepts.md#declared-accessibility)されている) か、型自体の宣言によって非表示になっている (継承によって[隠ぺい](basic-concepts.md#hiding-through-inheritance)されている) ため、派生型ではアクセスできない可能性があります。

### <a name="namespace-members"></a>名前空間のメンバー

外側の名前空間を持たない名前空間と型は、***グローバル名前空間***のメンバーです。 これは、グローバル宣言領域で宣言されている名前に直接対応します。

名前空間内で宣言された名前空間と型は、その名前空間のメンバーになります。 これは、名前空間の宣言空間で宣言されている名前に直接対応します。

名前空間には、アクセス制限がありません。 プライベート、プロテクト、または内部の名前空間を宣言することはできません。また、名前空間名には常にパブリックにアクセスできます。

### <a name="struct-members"></a>構造体のメンバー

構造体のメンバーは、構造体で宣言されたメンバーと、構造体の直接基底クラスから継承されたメンバー `System.ValueType` と間接基本クラス `object` です。

単純型のメンバーは、単純型によってエイリアス化された構造体型のメンバーに直接対応します。

*  @No__t-0 のメンバーは、`System.SByte` 構造体のメンバーになります。
*  @No__t-0 のメンバーは、`System.Byte` 構造体のメンバーになります。
*  @No__t-0 のメンバーは、`System.Int16` 構造体のメンバーになります。
*  @No__t-0 のメンバーは、`System.UInt16` 構造体のメンバーになります。
*  @No__t-0 のメンバーは、`System.Int32` 構造体のメンバーになります。
*  @No__t-0 のメンバーは、`System.UInt32` 構造体のメンバーになります。
*  @No__t-0 のメンバーは、`System.Int64` 構造体のメンバーになります。
*  @No__t-0 のメンバーは、`System.UInt64` 構造体のメンバーになります。
*  @No__t-0 のメンバーは、`System.Char` 構造体のメンバーになります。
*  @No__t-0 のメンバーは、`System.Single` 構造体のメンバーになります。
*  @No__t-0 のメンバーは、`System.Double` 構造体のメンバーになります。
*  @No__t-0 のメンバーは、`System.Decimal` 構造体のメンバーになります。
*  @No__t-0 のメンバーは、`System.Boolean` 構造体のメンバーになります。

### <a name="enumeration-members"></a>列挙型のメンバー

列挙体のメンバーは、列挙体で宣言された定数と、列挙体の direct 基底クラスから継承されたメンバー `System.Enum` および間接基本クラス `System.ValueType` と `object` です。

### <a name="class-members"></a>クラス メンバー

クラスのメンバーは、クラスで宣言されたメンバーと、基本クラスから継承されたメンバーです (クラス `object` は基底クラスを持たない)。 基本クラスから継承されたメンバーには、基本クラスの定数、フィールド、メソッド、プロパティ、イベント、インデクサー、演算子、および型が含まれますが、インスタンスコンストラクター、デストラクター、および基底クラスの静的コンストラクターは含まれません。 基底クラスのメンバーは、アクセシビリティに関係なく継承されます。

クラス宣言には、定数、フィールド、メソッド、プロパティ、イベント、インデクサー、演算子、インスタンスコンストラクター、デストラクター、静的コンストラクター、および型の宣言を含めることができます。

@No__t-0 および `string` のメンバーは、エイリアスを持つクラス型のメンバーに直接対応します。

*  @No__t-0 のメンバーは、`System.Object` クラスのメンバーです。
*  @No__t-0 のメンバーは、`System.String` クラスのメンバーです。

### <a name="interface-members"></a>インターフェイスのメンバー

インターフェイスのメンバーは、インターフェイス内で宣言されたメンバーと、インターフェイスのすべての基本インターフェイスで宣言されています。 クラス @no__t 0 のメンバーは、厳密に言うと、インターフェイス ([インターフェイスメンバー](interfaces.md#interface-members)) のメンバーではありません。 ただし、クラス `object` のメンバーは、任意のインターフェイス型 ([メンバー参照](expressions.md#member-lookup)) でメンバー参照を介して使用できます。

### <a name="array-members"></a>配列のメンバー

配列のメンバーは、クラス `System.Array` から継承されたメンバーです。

### <a name="delegate-members"></a>デリゲートメンバー

デリゲートのメンバーは、クラス `System.Delegate` から継承されたメンバーです。

## <a name="member-access"></a>メンバー アクセス。

メンバーの宣言によって、メンバーアクセスを制御できます。 メンバーのアクセシビリティは、メンバーのアクセシビリティ ([宣言](basic-concepts.md#declared-accessibility)されたアクセシビリティ) によって、すぐに含まれる型のアクセシビリティ (存在する場合) と組み合わせて確立されます。

特定のメンバーへのアクセスが許可されている場合、そのメンバーは***アクセス可能***であると言われます。 逆に、特定のメンバーへのアクセスが許可されていない場合、そのメンバーはアクセス***不可能***と見なされます。 メンバーへのアクセスが許可されるのは、アクセスが行われるテキストの場所が、メンバーのアクセシビリティドメイン ([アクセシビリティ](basic-concepts.md#accessibility-domains)ドメイン) に含まれている場合です。

### <a name="declared-accessibility"></a>アクセシビリティの宣言

メンバーに対して宣言された***アクセシビリティ***は、次のいずれかになります。

*  Public。メンバー宣言に @no__t 0 修飾子を含めることによって選択されます。 @No__t-0 の直感的な意味は、"アクセスが制限されていません" です。
*  Protected。メンバー宣言に @no__t 0 修飾子を含めることによって選択されます。 @No__t-0 という直感的な意味は、"含んでいるクラスに対するアクセスが制限されています" または "含まれているクラスから派生した型" です。
*  内部。メンバー宣言に @no__t 0 修飾子を含めることによって選択されます。 @No__t-0 の直感的な意味は、"このプログラムに対するアクセスが制限されています" です。
*  Protected internal (protected または internal)。メンバー宣言に @no__t 0 と `internal` 修飾子の両方を含めることによって選択されます。 @No__t-0 という直感的な意味は、"このプログラムにはアクセスが制限されているか、または含まれているクラスから派生した型" です。
*  Private。メンバー宣言に @no__t 0 修飾子を含めることによって選択されます。 @No__t-0 の直感的な意味は、"含んでいる型に限定されたアクセス" です。

メンバー宣言が行われるコンテキストによっては、特定の種類のアクセシビリティのみが許可されます。 さらに、メンバー宣言にアクセス修飾子が含まれていない場合、宣言が実行されるコンテキストによって、既定で宣言されたアクセシビリティが決まります。

*  名前空間は、暗黙的に @no__t 0 と宣言されています。 名前空間宣言でアクセス修飾子を使用することはできません。
*  コンパイル単位または名前空間で宣言された型では、@no__t 0 または @no__t がアクセシビリティと宣言されている場合があります。また、@no__t 既定では、アクセシビリティとして宣言されています。
*  クラスメンバーは、宣言されたアクセシビリティのうち5種類のいずれかを持つことができます。また、既定では @no__t は、アクセシビリティとして宣言されます。 (クラスのメンバーとして宣言された型は、5種類のアクセシビリティを持つことができますが、名前空間のメンバーとして宣言された型には `public` または @no__t が宣言されたアクセシビリティのみを持つことができます)。
*  構造体メンバーは、@no__t 0、`internal`、または @no__t 2 と宣言されたアクセシビリティを持つことができ、既定では、構造体が暗黙的 @no__t にシールされているため、アクセシビリティが宣言されています。 構造体で導入された構造体のメンバー (その構造体によって継承されていない) は、@no__t 0 または @no__t がアクセシビリティとして宣言されていません。 (構造体のメンバーとして宣言されている型は、@no__t 0、`internal`、または `private` と宣言されたアクセシビリティを持つことができますが、名前空間のメンバーとして宣言された型では、`public` または `internal` のみを使用できます)。
*  インターフェイスメンバーは、暗黙的に @no__t 0 と宣言されています。 インターフェイスメンバー宣言でアクセス修飾子を使用することはできません。
*  列挙型のメンバーのアクセシビリティは、暗黙的に @no__t 0 になります。 列挙メンバー宣言でアクセス修飾子を使用することはできません。

### <a name="accessibility-domains"></a>アクセシビリティドメイン

メンバーの***アクセシビリティドメイン***は、プログラムテキストの中で、メンバーへのアクセスが許可されている (不整合の可能性がある) セクションで構成されます。 メンバーのアクセシビリティドメインを定義する目的では、メンバーが型の中で宣言されていない場合は***最上位レベル***と呼ばれ、別の型で宣言されている場合はメンバーが***入れ子になっ***ていると言います。 さらに、プログラムの***プログラムテキスト***は、プログラムのすべてのソースファイルに含まれるすべてのプログラムテキストとして定義されます。また、型のプログラムテキストは、その型の*type_declaration*に含まれるすべてのプログラムテキストとして定義されます (場合によっては、型の中で入れ子になっている型があります。

定義済みの型 (`object`、`int`、`double` など) のアクセシビリティドメインは無制限です。

プログラム @no__t で宣言されている最上位レベルのバインドされていない型 `T` ([バインドおよびバインド](types.md#bound-and-unbound-types)解除された型) のアクセシビリティドメインは、次のように定義されます。

*  @No__t-0 に対して宣言されたアクセシビリティが `public` の場合、`T` のアクセシビリティドメインは、`P` のプログラムテキストと @no__t を参照するすべてのプログラムになります。
*  `T` に対して宣言されているアクセシビリティが `internal` の場合、`T` のアクセシビリティ ドメインは `P` のプログラム テキストになります。

これらの定義から、最上位レベルのバインド解除された型のアクセシビリティドメインは、その型が宣言されているプログラムのプログラムテキスト以上であることに従います。

構築された型のアクセシビリティドメイン `T<A1, ..., An>` は、バインドされていないジェネリック型のアクセシビリティドメインの積集合 `T`、および型引数のアクセシビリティドメイン `A1, ..., An` です。

プログラム @no__t 内の型 `T` で宣言されている入れ子になったメンバー @no__t 0 のアクセシビリティドメインは、次のように定義されます (@no__t 3 自体が型である可能性があります)。

*  `M` に対して宣言されたアクセシビリティが `public` の場合、`M` のアクセシビリティ ドメインは `T` のアクセシビリティ ドメインになります。
*  @No__t-0 に対して宣言されたアクセシビリティが-1 @no__t 場合、`D` は、`P` のプログラムテキストと @no__t から派生した任意の型のプログラムテキストの和集合 (`P` の外部で宣言されている) を使用します。 @No__t-0 のアクセシビリティドメインは、`T` のアクセシビリティドメインと `D` の積集合です。
*  @No__t-0 に対して宣言されたアクセシビリティが-1 @no__t 場合、`D` は `T` のプログラムテキストと、@no__t から派生した任意の型のプログラムテキストの和集合であることを示します。 @No__t-0 のアクセシビリティドメインは、`T` のアクセシビリティドメインと `D` の積集合です。
*  `M` に対して宣言されているアクセシビリティが `internal` の場合、`M` のアクセシビリティ ドメインは、`T` のアクセシビリティ ドメインと `P` のプログラム テキストとの積集合になります。
*  `M` に対して宣言されているアクセシビリティが `private` の場合、`M` のアクセシビリティ ドメインは `T` のプログラム テキストになります。

これらの定義から、入れ子になったメンバーのアクセシビリティドメインは、メンバーが宣言されている型のプログラムテキスト以上であることに従います。 さらに、メンバーのアクセシビリティドメインは、メンバーが宣言されている型のアクセシビリティドメインを超えないようにします。

直感的な用語では、型またはメンバー `M` にアクセスしたときに、アクセスが許可されていることを確認するために次の手順が評価されます。

*  まず、`M` が (コンパイル単位または名前空間ではなく) 型の中で宣言されている場合、その型にアクセスできないと、コンパイル時エラーが発生します。
*  @No__t-0 が `public` の場合は、アクセスが許可されます。
*  それ以外の場合、`M` が `protected internal` の場合、`M` が宣言されているプログラム内でこのアクセスが発生した場合、または `M` が宣言されていて、派生クラスの型 ([Protectedインスタンスメンバーのアクセス](basic-concepts.md#protected-access-for-instance-members)。
*  それ以外の場合、`M` が `protected` の場合、`M` が宣言されているクラス内でアクセスが発生した場合、または `M` が宣言されていて、派生クラスの型 ([Protectedインスタンスメンバーのアクセス](basic-concepts.md#protected-access-for-instance-members)。
*  それ以外の場合、`M` が `internal` の場合、`M` が宣言されているプログラム内でこのアクセスが発生した場合、アクセスが許可されます。
*  それ以外の場合、`M` が `private` の場合、`M` が宣言されている型内でこのアクセスが発生すると、アクセスが許可されます。
*  それ以外の場合は、型またはメンバーにアクセスできないため、コンパイル時エラーが発生します。

この例では、
```csharp
public class A
{
    public static int X;
    internal static int Y;
    private static int Z;
}

internal class B
{
    public static int X;
    internal static int Y;
    private static int Z;

    public class C
    {
        public static int X;
        internal static int Y;
        private static int Z;
    }

    private class D
    {
        public static int X;
        internal static int Y;
        private static int Z;
    }
}
```
クラスとメンバーには、次のアクセシビリティドメインがあります。

*  @No__t-0 および `A.X` のアクセシビリティドメインは無制限です。
*  @No__t-0、`B`、`B.X`、`B.Y`、`B.C`、`B.C.X`、および `B.C.Y` のアクセシビリティドメインは、格納しているプログラムのプログラムテキストです。
*  @No__t-0 のアクセシビリティドメインは、`A` のプログラムテキストです。
*  @No__t-0 および `B.D` のアクセシビリティドメインは `B` のプログラムテキストで、`B.C` および `B.D` のプログラムテキストを含みます。
*  @No__t-0 のアクセシビリティドメインは、`B.C` のプログラムテキストです。
*  @No__t-0 および `B.D.Y` のアクセシビリティドメインは `B` のプログラムテキストで、`B.C` および `B.D` のプログラムテキストを含みます。
*  @No__t-0 のアクセシビリティドメインは、`B.D` のプログラムテキストです。

例に示すように、メンバーのアクセシビリティドメインは、それを含んでいる型のアクセシビリティドメインよりも大きくなることはありません。 たとえば、すべての `X` メンバーがパブリックに宣言されたアクセシビリティを持つ場合でも、すべての `A.X` は、包含する型によって制約されるアクセシビリティドメインを持ちます。

「[メンバー](basic-concepts.md#members)」で説明したように、インスタンスコンストラクター、デストラクター、および静的コンストラクターを除く、基底クラスのすべてのメンバーは、派生型によって継承されます。 これには、基底クラスのプライベートメンバーも含まれます。 ただし、プライベートメンバーのアクセシビリティドメインには、メンバーが宣言されている型のプログラムテキストのみが含まれます。 この例では、
```csharp
class A
{
    int x;

    static void F(B b) {
        b.x = 1;        // Ok
    }
}

class B: A
{
    static void F(B b) {
        b.x = 1;        // Error, x not accessible
    }
}
```
`B` クラスは、`A` クラスから、プライベートメンバー `x` を継承します。 メンバーはプライベートであるため、`A` の*class_body*内でのみアクセスできます。 したがって、`b.x` へのアクセスは `A.F` メソッドで成功しますが、`B.F` メソッドでは失敗します。

### <a name="protected-access-for-instance-members"></a>インスタンスメンバーの保護されたアクセス

@No__t 0 のインスタンスメンバーが宣言されているクラスのプログラムテキストの外部でアクセスされ、@no__t インスタンスのメンバーが、そのメンバーが宣言されているプログラムのプログラムテキストの外部からアクセスされる場合、アクセスはクラス内で行われる必要があります。宣言されたクラスから派生する宣言。 さらに、その派生クラス型のインスタンス、またはそれから構築されたクラス型を使用してアクセスする必要があります。 この制限により、メンバーが同じ基本クラスから継承されている場合でも、1つの派生クラスが他の派生クラスのプロテクトメンバーにアクセスするのを防ぐことができます。

@No__t-0 は、保護されたインスタンスメンバーを宣言する基底クラス `M` で、`D` を `B` から派生したクラスにすることができます。 @No__t-1 の*class_body*内で、@no__t にアクセスするには、次のいずれかの形式を使用する必要があります。

*  @No__t-2 形式の非修飾の*type_name*または*primary_expression* 。
*  @No__t の型が `T`、または `T` から派生したクラス (`T` はクラス型 `D`)、または @no__t から構築されたクラス型である `E.M` という形式の*primary_expression*があります。
*  @No__t-1 の形式の*primary_expression*です。

派生クラスは、これらの形式のアクセスに加えて、 *constructor_initializer* ([コンストラクター初期化子](classes.md#constructor-initializers)) 内の基底クラスの保護されたインスタンスコンストラクターにアクセスできます。

この例では、
```csharp
public class A
{
    protected int x;

    static void F(A a, B b) {
        a.x = 1;        // Ok
        b.x = 1;        // Ok
    }
}

public class B: A
{
    static void F(A a, B b) {
        a.x = 1;        // Error, must access through instance of B
        b.x = 1;        // Ok
    }
}
```
@no__t 0 の場合、`A` と `B` の両方のインスタンスを介して `x` にアクセスできます。どちらの場合も、アクセスは @no__t のインスタンスまたは @no__t から派生したクラスを介して行われるためです。 ただし `B` では、`A` が @no__t から派生していないため、`A` のインスタンスを介して `x` にアクセスすることはできません。

この例では、
```csharp
class C<T>
{
    protected T x;
}

class D<T>: C<T>
{
    static void F() {
        D<T> dt = new D<T>();
        D<int> di = new D<int>();
        D<string> ds = new D<string>();
        dt.x = default(T);
        di.x = 123;
        ds.x = "test";
    }
}
```
`x` への3つの代入は、ジェネリック型から構築されたクラス型のインスタンスを通じてすべての処理が行われるため、許可されます。

### <a name="accessibility-constraints"></a>アクセシビリティの制約

C#言語のいくつかの構造体は、少なくともメンバーまたは別の型***としてアクセスできる***型である必要があります。 @No__t-2 のアクセシビリティドメインが `M` のアクセシビリティドメインのスーパーセットである場合、型 `T` は、少なくともメンバーまたは @no__t 型と同じようにアクセス可能であると言います。 つまり、`M` にアクセスできるすべてのコンテキストで `T` にアクセスできる場合は、`T` に少なくとも @no__t としてアクセスできることになります。

次のアクセシビリティ制約が存在します。

*  クラスの型の直接基底クラスは、少なくとも、クラスの型自体と同程度にアクセス可能である必要があります。
*  インターフェイスの型の明示的な基本インターフェイスは、少なくとも、インターフェイスの型自体と同程度にアクセス可能である必要があります。
*  デリゲート型の戻り値の型およびパラメーターの型は、少なくとも、デリゲート型自体と同程度にアクセス可能である必要があります。
*  定数の型は、少なくとも定数自体と同程度にアクセス可能である必要があります。
*  フィールドの型は、少なくともフィールド自体と同程度にアクセス可能である必要があります。
*  メソッドの戻り値の型およびパラメーターの型は、少なくとも、メソッド自体と同程度にアクセス可能である必要があります。
*  プロパティの型は、少なくともプロパティ自体と同程度にアクセス可能である必要があります。
*  イベントの型は、少なくともイベント自体と同程度にアクセス可能である必要があります。
*  インデクサーの型とパラメーターの型は、少なくとも、インデクサー自体と同程度にアクセス可能である必要があります。
*  演算子の戻り値の型とパラメーターの型は、少なくとも、演算子自体と同程度にアクセス可能である必要があります。
*  インスタンスコンストラクターのパラメーターの型は、少なくともインスタンスコンストラクター自体と同じようにアクセス可能である必要があります。

この例では、
```csharp
class A {...}

public class B: A {...}
```
`A` は少なくとも `B` と同じようにアクセスできないため、`B` クラスはコンパイル時エラーになります。

同様に、例では
```csharp
class A {...}

public class B
{
    A F() {...}

    internal A G() {...}

    public A H() {...}
}
```
戻り値の型 `A` は少なくともメソッドと同じようにアクセスできないため、`B` の `H` メソッドはコンパイル時エラーになります。

## <a name="signatures-and-overloading"></a>署名とオーバーロード

メソッド、インスタンスコンストラクター、インデクサー、および演算子は、***シグネチャ***によって特徴付けられます。

*  メソッドのシグネチャは、メソッドの名前、型パラメーターの数、それぞれの仮パラメーターの型と種類 (値、参照、または出力) で構成されます。順序は左から右になります。 このため、仮パラメーターの型で発生するメソッドの型パラメーターは、その名前ではなく、メソッドの型引数リスト内の序数位置によって識別されます。 メソッドのシグネチャには、戻り値の型、右端のパラメーターに指定できる @no__t 0 修飾子、および省略可能な型パラメーター制約が含まれていません。
*  インスタンスコンストラクターのシグネチャは、それぞれの仮パラメーターの型と種類 (値、参照、または出力) で構成され、左から右の順序で考慮されます。 インスタンスコンストラクターのシグネチャには、右端のパラメーターに指定できる @no__t 0 修飾子が明示的に含まれていません。
*  インデクサーのシグネチャは、それぞれの仮パラメーターの型で構成され、左から右の順序で考慮されます。 インデクサーのシグネチャには、特に要素の型は含まれません。また、右端のパラメーターに指定できる @no__t 0 修飾子も含まれません。
*  演算子のシグネチャは、演算子の名前と、それぞれの仮パラメーターの型で構成されます。順序は左から右になります。 演算子のシグネチャには、結果の型は含まれません。

シグネチャは、クラス、構造体、およびインターフェイスのメンバーを***オーバーロード***するための有効なメカニズムです。

*  メソッドのオーバーロードにより、クラス、構造体、またはインターフェイスは、シグネチャがそのクラス、構造体、またはインターフェイス内で一意である場合に、同じ名前の複数のメソッドを宣言できます。
*  インスタンスコンストラクターのオーバーロードにより、クラスまたは構造体は、そのクラスまたは構造体内で一意のシグネチャを持つ場合に、複数のインスタンスコンストラクターを宣言できます。
*  インデクサーをオーバーロードすると、クラス、構造体、またはインターフェイスは、そのクラス、構造体、またはインターフェイス内で一意のシグネチャを持つことができるので、複数のインデクサーを宣言できます。
*  演算子のオーバーロードにより、クラスまたは構造体は、そのクラスまたは構造体内で一意のシグネチャを持つ場合、同じ名前の複数の演算子を宣言できます。

@No__t-0 および `ref` パラメーター修飾子はシグネチャの一部と見なされますが、1つの型で宣言されたメンバーは、`ref` と `out` だけで署名が異なることはありません。 2つのメンバーが同じ型で宣言されている場合、2つのメンバーが同じ型で宣言されていると、`out` 修飾子を持つ両方のメソッドのすべてのパラメーターが `ref` 修飾子に変更された場合に、コンパイル時エラーが発生します。 署名の一致 (たとえば、非表示またはオーバーライド) のその他の目的については、`ref` および `out` はシグネチャの一部と見なされ、相互に一致しません。 (この制限は、 C#プログラムが共通言語基盤 (CLI) で実行されるように簡単に変換できるようにすることです。これにより、`ref` と `out` のみが異なるメソッドを定義することはできません。)

署名の目的では、-0 および `dynamic` @no__t 型は同じものと見なされます。 したがって、1つの型で宣言されたメンバーは、`object` および `dynamic` だけで署名が異なることはありません。

次の例は、オーバーロードされたメソッド宣言のセットとそのシグネチャを示しています。
```csharp
interface ITest
{
    void F();                        // F()

    void F(int x);                   // F(int)

    void F(ref int x);               // F(ref int)

    void F(out int x);               // F(out int)      error

    void F(int x, int y);            // F(int, int)

    int F(string s);                 // F(string)

    int F(int x);                    // F(int)          error

    void F(string[] a);              // F(string[])

    void F(params string[] a);       // F(string[])     error
}
```

@No__t-0 および `out` パラメーター修飾子 ([メソッドパラメーター](classes.md#method-parameters)) は、シグネチャの一部であることに注意してください。 したがって、`F(int)` および `F(ref int)` は一意の署名です。 ただし、`F(ref int)` と `F(out int)` は、同じインターフェイス内で宣言することはできません。これは、シグネチャが `ref` と `out` だけで異なるためです。 また、戻り値の型と `params` 修飾子はシグネチャの一部ではないことに注意してください。したがって、戻り値の型に基づいて、または `params` 修飾子の包含または除外に基づいてのみオーバーロードすることはできません。 そのため、上記で特定された `F(int)` および `F(params string[])` のメソッドの宣言は、コンパイル時エラーになります。

## <a name="scopes"></a>スコープ

名前の***スコープ***はプログラムテキストの領域であり、名前を修飾することなく、名前で宣言されたエンティティを参照できます。 スコープは***入れ子***にすることができ、内側のスコープは外側のスコープから名前の意味を再宣言することができます (ただし、入れ子になったブロック内の[宣言](basic-concepts.md#declarations)によって課される制約は削除されません)。外側のブロック内のローカル変数と同じ名前です)。 外側のスコープの名前は、内側のスコープによってカバーされるプログラムテキストの領域で***非表示***になると言い、外部名へのアクセスは、名前を修飾することでのみ可能です。

*  外側の*namespace_declaration*がない*namespace_member_declaration* ([名前空間メンバー](namespaces.md#namespace-members)) によって宣言された名前空間メンバーのスコープは、プログラムテキスト全体です。
*  完全修飾名が `N` である*namespace_declaration*内の*namespace_member_declaration*によって宣言された名前空間メンバーのスコープは、すべての*namespace_declaration*の*namespace_body*になります。修飾名が `N` で始まるか、または `N` で始まり、その後にピリオドが続きます。
*  *Extern_alias_directive*によって定義された名前のスコープは、その直後のコンパイル単位または名前空間の本体を含む*using_directive*s、 *global_attributes* 、 *namespace_member_declaration*の範囲を超えています。 *Extern_alias_directive*は、基になる宣言領域に新しいメンバーを提供しません。 つまり、 *extern_alias_directive*は推移的ではありませんが、は、それが発生するコンパイル単位または名前空間の本文にのみ影響します。
*  *Using_directive* ([using ディレクティブ](namespaces.md#using-directives)) によって定義またはインポートされた名前のスコープは、 *compilation_unit*または*namespace_body*の*namespace_member_declaration*を超えています。が発生します。 *Using_directive*は、0個以上の名前空間、型、またはメンバー名を特定の*compilation_unit*または*namespace_body*内で使用できますが、基になる宣言領域に新しいメンバーを提供しません。 言い換えると、 *using_directive*は推移的ではなく、それが発生する*compilation_unit*または*namespace_body*にのみ影響します。
*  *Class_declaration* ([クラス宣言](classes.md#class-declarations)) の*type_parameter_list*によって宣言された型パラメーターのスコープは、その *class_base、type_parameter_constraints_clause s、および class_body です。class_declaration*。
*  *Struct_declaration* ([struct 宣言](structs.md#struct-declarations)) の*type_parameter_list*によって宣言された型パラメーターのスコープは、の*struct_interfaces*、 *type_parameter_constraints_clause*、および*struct_body*です。*struct_declaration*。
*  *Interface_declaration* ([インターフェイス宣言](interfaces.md#interface-declarations)) の*type_parameter_list*によって宣言された型パラメーターのスコープは、 *interface_base*、 *type_parameter_constraints_clause*、および*interface_body です。* この*interface_declaration*。
*  *Delegate_declaration*の*type_parameter_list*によって宣言された型パラメーターのスコープ ([デリゲート宣言](delegates.md#delegate-declarations)) は *、* *formal_parameter_list*および type_parameter_constraints_clause です。その*delegate_declaration*のです。
*  *Class_member_declaration* ([クラス本体](classes.md#class-body)) によって宣言されるメンバーのスコープは、宣言が発生する*class_body*です。 さらに、クラスメンバーのスコープは、メンバーのアクセシビリティドメイン ([アクセシビリティ](basic-concepts.md#accessibility-domains)ドメイン) に含まれている派生クラスの*class_body*にまで拡張されます。
*  *Struct_member_declaration* ([構造体メンバー](structs.md#struct-members)) によって宣言されるメンバーのスコープは、宣言が発生する*struct_body*です。
*  *Enum_member_declaration* ([列挙型メンバー](enums.md#enum-members)) によって宣言されるメンバーのスコープは、宣言が発生する*enum_body*です。
*  *Method_declaration* ([メソッド](classes.md#methods)) で宣言されたパラメーターのスコープは、その*method_declaration*の*method_body*です。
*  *Indexer_declaration* ([インデクサー](classes.md#indexers)) で宣言されたパラメーターのスコープは、その*indexer_declaration*の*accessor_declarations*です。
*  *Operator_declaration* ([Operators](classes.md#operators)) で宣言されたパラメーターのスコープは、その*operator_declaration*の*ブロック*です。
*  *Constructor_declaration* ([インスタンスコンストラクター](classes.md#instance-constructors)) で宣言されたパラメーターのスコープは、その*constructor_declaration*の*constructor_initializer*と*block*です。
*  *Lambda_expression* ([匿名関数式](expressions.md#anonymous-function-expressions)) で宣言されたパラメーターのスコープは、その*lambda_expression*の*anonymous_function_body*です。
*  *Anonymous_method_expression* ([匿名関数式](expressions.md#anonymous-function-expressions)) で宣言されたパラメーターのスコープは、その*anonymous_method_expression*の*ブロック*です。
*  *Labeled_statement* ([ラベル付きステートメント](statements.md#labeled-statements)) で宣言されたラベルのスコープは、宣言が発生する*ブロック*です。
*  *Local_variable_declaration* ([ローカル変数宣言](statements.md#local-variable-declarations)) で宣言されたローカル変数のスコープは、宣言が発生するブロックです。
*  @No__t-1 ステートメント ([switch ステートメント](statements.md#the-switch-statement)) の*switch_block*で宣言されたローカル変数のスコープは、 *switch_block*です。
*  @No__t-1 ステートメントの*for_initializer*で宣言されているローカル変数のスコープ ([for ステートメント](statements.md#the-for-statement)) は、 *for_initializer*、 *for_condition*、 *for_iterator*、およびに含まれる*ステートメント*です。`for` ステートメント。
*  *Local_constant_declaration* ([ローカル定数宣言](statements.md#local-constant-declarations)) で宣言されたローカル定数のスコープは、宣言が発生するブロックです。 *Constant_declarator*の前にあるテキストの位置でローカル定数を参照するコンパイル時エラーです。
*  *Foreach_statement*、 *using_statement*、 *lock_statement* 、または*query_expression*の一部として宣言された変数のスコープは、指定されたコンストラクトの展開によって決まります。

名前空間、クラス、構造体、または列挙型のメンバーのスコープ内では、メンバーの宣言の前にあるテキスト位置でメンバーを参照することができます。 次に例を示します。
```csharp
class A
{
    void F() {
        i = 1;
    }

    int i = 0;
}
```
ここでは、`F` が宣言される前に `i` を参照することが有効です。

ローカル変数のスコープ内では、ローカル変数の*local_variable_declarator*の前にあるテキスト位置でローカル変数を参照するコンパイル時エラーになります。 次に例を示します。
```csharp
class A
{
    int i = 0;

    void F() {
        i = 1;                  // Error, use precedes declaration
        int i;
        i = 2;
    }

    void G() {
        int j = (j = 1);        // Valid
    }

    void H() {
        int a = 1, b = ++a;    // Valid
    }
}
```

上記の @no__t 0 のメソッドでは、`i` への最初の代入は、特に外側のスコープで宣言されたフィールドを参照しません。 代わりに、ローカル変数を参照するので、コンパイル時エラーが発生します。これは、変数の宣言の前にあるためです。 @No__t-0 メソッドでは、`j` の宣言の初期化子で `j` を使用することはできません。これは、 *local_variable_declarator*の前に使用しないためです。 @No__t-0 メソッドでは、後続の*local_variable_declarator*は、同じ*local_variable_declaration*内の前の*local_variable_declarator*で宣言されたローカル変数を正しく参照します。

ローカル変数のスコープ規則は、式のコンテキストで使用される名前の意味が常にブロック内で同じであることを保証するように設計されています。 ローカル変数のスコープがその宣言からブロックの末尾まで拡張される場合、上記の例では、最初の代入がインスタンス変数に割り当てられ、2番目の代入がローカル変数に代入されますが、これはおそらく次のようになります。ブロックのステートメントが後で再配置された場合、コンパイル時エラーが発生します。

ブロック内の名前の意味は、名前が使用されているコンテキストによって異なる場合があります。 この例では、
```csharp
using System;

class A {}

class Test
{
    static void Main() {
        string A = "hello, world";
        string s = A;                            // expression context

        Type t = typeof(A);                      // type context

        Console.WriteLine(s);                    // writes "hello, world"
        Console.WriteLine(t);                    // writes "A"
    }
}
```
名前 `A` は、ローカル @no__t 変数を参照するために式のコンテキストで使用されます。-1、型のコンテキストで、クラス `A` を参照します。

### <a name="name-hiding"></a>名前の非表示

エンティティのスコープには、通常、エンティティの宣言空間よりも多くのプログラムテキストが含まれます。 特に、エンティティのスコープには、同じ名前のエンティティを含む新しい宣言スペースを導入する宣言を含めることができます。 このような宣言を行うと、元のエンティティが***非表示***になります。 逆に、エンティティは非表示になっている場合は***表示***されると言います。

名前の非表示は、スコープが入れ子になっている場合と、スコープが継承によって重複している場合に発生します。 2種類の非表示の特性については、次のセクションで説明します。

#### <a name="hiding-through-nesting"></a>非表示 (入れ子による)

入れ子による名前の隠ぺいは、名前空間内に名前空間または型を入れ子にした結果として発生することがあります。これは、クラスまたは構造体で型を入れ子にした結果として、パラメーターとローカル変数の宣言の結果として発生します。

この例では、
```csharp
class A
{
    int i = 0;

    void F() {
        int i = 1;
    }

    void G() {
        i = 1;
    }
}
```
`F` メソッドでは、インスタンス変数 `i` は、ローカル変数 `i` で非表示になっていますが、`G` メソッドでは、@no__t は引き続きインスタンス変数を参照しています。

内部スコープ内の名前が外側のスコープ内の名前を非表示にすると、その名前のすべてのオーバーロードされた出現が非表示になります。 この例では、
```csharp
class Outer
{
    static void F(int i) {}

    static void F(string s) {}

    class Inner
    {
        void G() {
            F(1);              // Invokes Outer.Inner.F
            F("Hello");        // Error
        }

        static void F(long l) {}
    }
}
```
この @no__t 呼び出しは、`Inner` で宣言された `F` を呼び出します。これは、`F` のすべての外部オカレンスが内部宣言によって非表示になるためです。 同じ理由から、-0 @no__t を呼び出すと、コンパイル時エラーが発生します。

#### <a name="hiding-through-inheritance"></a>隠ぺい (継承による)

継承による名前の隠ぺいは、クラスまたは構造体が基底クラスから継承された名前を再宣言するときに発生します。 この種類の名前の隠ぺいは、次のいずれかの形式になります。

*  クラスまたは構造体で導入された定数、フィールド、プロパティ、イベント、または型は、同じ名前を持つすべての基底クラスメンバーを非表示にします。
*  クラスまたは構造体で導入されたメソッドは、同じ名前を持つすべての非メソッド基底クラスメンバーと、同じシグネチャ (メソッド名とパラメーター数、修飾子、型) を持つすべての基底クラスメソッドを非表示にします。
*  クラスまたは構造体で導入されたインデクサーは、同じシグネチャ (パラメーター数および型) を持つすべての基底クラスインデクサーを非表示にします。

演算子宣言 ([演算子](classes.md#operators)) を制御する規則により、派生クラスは、基底クラスで演算子と同じシグネチャを持つ演算子を宣言できなくなります。 したがって、演算子は相互に隠ぺいすることはありません。

外側のスコープから名前を非表示にする場合とは対照的に、継承されたスコープからアクセス可能な名前を非表示にすると、警告が報告されます。 この例では、
```csharp
class Base
{
    public void F() {}
}

class Derived: Base
{
    public void F() {}        // Warning, hiding an inherited name
}
```
`Derived` の `F` の宣言により、警告が報告されます。 継承された名前を非表示にすることは、特にエラーではありません。これは、基本クラスの個別の進化を防ぐためです。 たとえば、より新しいバージョンの `Base` では、以前のバージョンのクラスには存在しない `F` メソッドが導入されたため、上記の状況が発生する可能性があります。 上記の状況でエラーが発生した場合、個別にバージョン管理されたクラスライブラリの基底クラスに変更が加えられると、派生クラスが無効になる可能性があります。

継承された名前を非表示にすることによって発生する警告は、@no__t 0 修飾子を使用することによって削除できます。
```csharp
class Base
{
    public void F() {}
}

class Derived: Base
{
    new public void F() {}
}
```

@No__t-0 修飾子は、`Derived` の `F` が "new" であり、継承されたメンバーを非表示にすることを意図していることを示します。

新しいメンバーの宣言は、継承されたメンバーを新しいメンバーのスコープ内でのみ非表示にします。

```csharp
class Base
{
    public static void F() {}
}

class Derived: Base
{
    new private static void F() {}    // Hides Base.F in Derived only
}

class MoreDerived: Derived
{
    static void G() { F(); }          // Invokes Base.F
}
```

上記の例では、`Derived` の `F` の宣言によって、`Base` から継承された @no__t 2 が非表示になりますが、`Derived` の新しい @no__t にはプライベートアクセスがあるため、そのスコープは @no__t 6 には拡張されません。 したがって、`MoreDerived.G` の `F()` は有効で、`Base.F` を呼び出します。

## <a name="namespace-and-type-names"></a>名前空間と型名

プログラム内のいくつかのコンテキストでは、 *namespace_name*または type_name を指定する必要があります。 C#

```antlr
namespace_name
    : namespace_or_type_name
    ;

type_name
    : namespace_or_type_name
    ;

namespace_or_type_name
    : identifier type_argument_list?
    | namespace_or_type_name '.' identifier type_argument_list?
    | qualified_alias_member
    ;
```

*Namespace_name*は、名前空間を参照する*namespace_or_type_name*です。 以下で説明するように、 *namespace_name*の*namespace_or_type_name*は名前空間を参照する必要があり、それ以外の場合はコンパイル時エラーが発生します。 型[引数 (型引数)](types.md#type-arguments)は、 *namespace_name*には存在できません (型引数を持つことができるのは型だけです)。

*Type_name*は、型を参照する*namespace_or_type_name*です。 以下で説明するように、 *type_name*の*namespace_or_type_name*は型を参照する必要があり、それ以外の場合はコンパイル時のエラーが発生します。

*Namespace_or_type_name*が修飾名である場合は、「[名前空間エイリアスの修飾子](namespaces.md#namespace-alias-qualifiers)」で説明されているように意味があります。 それ以外の場合、 *namespace_or_type_name*には次の4つの形式があります。

*  `I`
*  `I<A1, ..., Ak>`
*  `N.I`
*  `N.I<A1, ..., Ak>`

`I` は1つの識別子、`N` は*namespace_or_type_name* 、`<A1, ..., Ak>` は省略可能な*type_argument_list*です。 No *type_argument_list*が指定されている場合は、-1 を0に @no__t ことを検討してください。

*Namespace_or_type_name*の意味は、次のように決定されます。

*   *Namespace_or_type_name*の形式が-1 またはフォーム `I<A1, ..., Ak>` の場合は、次のように @no__t ます。
    * @No__t-0 がゼロで、 *namespace_or_type_name*がジェネリックメソッド宣言 ([メソッド](classes.md#methods)) 内に存在し、その宣言に @ no__t-4 という名前の型パラメーター ([型](classes.md#type-parameters)パラメーター) が含まれている場合は、 *namespace_or_type_名前*は、その型パラメーターを参照します。
    * それ以外の場合、 *namespace_or_type_name*が型宣言内に存在する場合は、各インスタンスの型 @ no__t ([インスタンス型](classes.md#the-instance-type)) に対して、その型宣言のインスタンス型から開始し、それぞれのインスタンスの型を続行します。外側のクラスまたは構造体の宣言 (存在する場合):
        * @No__t-0 が0で `T` の宣言に @ no__t-2 という名前の型パラメーターが含まれている場合、 *namespace_or_type_name*はその型パラメーターを参照します。
        * それ以外の場合、 *namespace_or_type_name*が型宣言の本体に含まれており、`T` またはその基本型のいずれかに、名前が @ no__t-2、@no__t が 3 @ no__t の型パラメーターを持つ入れ子になったアクセス可能な型が含まれている場合、 *namespace_or_type_name*は、指定された型引数を使用して構築されたその型を参照します。 このような型が複数ある場合は、より多くの派生型で宣言された型が選択されます。 非型メンバー (定数、フィールド、メソッド、プロパティ、インデクサー、演算子、インスタンスコンストラクター、デストラクター、および静的コンストラクター) と型パラメーターの数が異なる型のメンバーは、の意味を判断するときに無視されることに注意してください。*namespace_or_type_name*。
    * 前の手順が失敗した場合は、各名前空間 @ no__t-0 に対して、 *namespace_or_type_name*が発生する名前空間で開始し、外側の各名前空間 (存在する場合) を続けて、次のようにします。手順は、エンティティが見つかるまで評価されます。
        * @No__t-0 が0で `I` が @ no__t-2 の名前空間の名前である場合は、次のようになります。
            * *Namespace_or_type_name*が発生した場所が `N` の名前空間宣言によって囲まれていて、名前空間の宣言に名前 @ no を関連付ける*extern_alias_directive*または*using_alias_directive*が含まれている場合__ t-4 名前空間または型の場合、 *namespace_or_type_name*があいまいになり、コンパイル時エラーが発生します。
            * それ以外の場合、 *namespace_or_type_name*は `N` の `I` という名前空間を参照します。
        * それ以外の場合、`N` に、名前が @ no__t-1、@no__t が @ no__t の型パラメーターを持つアクセス可能な型が含まれている場合は、次のようになります。
            * @No__t-0 が0で、 *namespace_or_type_name*が発生した場所が @no__t の名前空間宣言によって囲まれており、名前空間の宣言に*extern_alias_directive*または*using_alias_directive*が含まれている場合名前に @ no__t-5 を名前空間または型と関連付けると、 *namespace_or_type_name*があいまいになり、コンパイル時エラーが発生します。
            * それ以外の場合、 *namespace_or_type_name*は、指定された型引数を使用して構築された型を参照します。
        * それ以外の場合、 *namespace_or_type_name*が発生した場所が `N` の名前空間宣言によって囲まれている場合は、次のようになります。
            * @No__t-0 が0で、名前空間の宣言に、インポートされた名前空間または型に @ no__t-3 を関連付ける*extern_alias_directive*または*using_alias_directive*が含まれている場合、 *namespace_or_type_name*はそれを参照します。名前空間または型。
            * それ以外の場合は、名前空間宣言の*using_namespace_directive*s および*using_alias_directive*s によってインポートされた名前空間と型宣言に、名前が @ no__t-2 で、@no__t が-3 @ no__t-4type のアクセス可能な型が1つだけ含まれている場合。パラメーターを指定すると、 *namespace_or_type_name*は、指定された型引数を使用して構築されたその型を参照します。
            * それ以外の場合は、名前空間宣言の*using_namespace_directive*s および*using_alias_directive*s によってインポートされた名前空間と型宣言に、名前が @ no__t-2 で、@no__t が-3 @ no__t-4type の複数のアクセス可能な型が含まれている場合。パラメーターの場合、 *namespace_or_type_name*はあいまいで、エラーが発生します。
    * それ以外の場合、 *namespace_or_type_name*は定義されていないため、コンパイル時エラーが発生します。
*  それ以外の場合、 *namespace_or_type_name*は-1 またはフォーム `N.I<A1, ..., Ak>` の形式 @no__t ます。 `N` は最初に*namespace_or_type_name*として解決されます。 @No__t-0 の解決に失敗した場合は、コンパイル時にエラーが発生します。 それ以外の場合、`N.I` または `N.I<A1, ..., Ak>` は次のように解決されます。
    * @No__t-0 が0で `N` が名前空間を参照し、`N` に名前が `I` の入れ子になった名前空間が含まれている場合、 *namespace_or_type_name*はその入れ子になった名前空間を参照します。
    * それ以外の場合、`N` は名前空間を参照し、@no__t には、@ no__t-2 および `K` @ no__t の型パラメーターを持つアクセス可能な型が含まれます。その場合、 *namespace_or_type_name*は、指定された型引数を使用して構築されたその型を参照します。
    * それ以外の場合、`N` が (構築された) クラスまたは構造体型を参照し、`N` またはその基本クラスに、@ no__t-2 および `K` @ no__t-4type パラメーターという名前の入れ子になったアクセス可能な型が含まれている場合、 *namespace_or_type_name*はを参照します。指定した型引数を使用して構築された型。 このような型が複数ある場合は、より多くの派生型で宣言された型が選択されます。 @No__t-0 の意味が `N` の基底クラスの指定の解決の一部として決定される場合、`N` の直接の基底クラスは object ([基底クラス](classes.md#base-classes)) と見なされます。
    * それ以外の場合、`N.I` は無効な*namespace_or_type_name*であり、コンパイル時エラーが発生します。

*Namespace_or_type_name*は、静的クラス ([静的クラス](classes.md#static-classes)) を参照することが許可されているのは、

*  *Namespace_or_type_name*は、`T.I` の形式の*namespace_or_type_name*の `T` です。
*  *Namespace_or_type_name*は、`typeof(T)` の形式の*typeof_expression* ([引数リスト](expressions.md#argument-lists)1) の `T` です。

### <a name="fully-qualified-names"></a>完全修飾名

すべての名前空間と型には、すべての名前空間または型を一意に識別する***完全修飾名***があります。 名前空間の完全修飾名または型 `N` は、次のように決定されます。

*  @No__t-0 がグローバル名前空間のメンバーである場合、その完全修飾名は `N` になります。
*  それ以外の場合、その完全修飾名は 0 @no__t になります。ここで `S` は、`N` が宣言されている名前空間または型の完全修飾名です。

つまり、`N` の完全修飾名は、グローバル名前空間から始まる `N` になる識別子の完全な階層パスです。 名前空間または型のすべてのメンバーは一意の名前を持つ必要があるため、名前空間または型の完全修飾名は常に一意であることに従います。

次の例では、いくつかの名前空間と型の宣言と、それに関連付けられた完全修飾名を示します。
```csharp
class A {}                // A

namespace X               // X
{
    class B               // X.B
    {
        class C {}        // X.B.C
    }

    namespace Y           // X.Y
    {
        class D {}        // X.Y.D
    }
}

namespace X.Y             // X.Y
{
    class E {}            // X.Y.E
}
```

## <a name="automatic-memory-management"></a>自動メモリ管理

C#自動メモリ管理を使用します。これにより、開発者は、オブジェクトによって占有されるメモリを手動で割り当てたり解放したりすることができます。 自動メモリ管理ポリシーは、***ガベージコレクター***によって実装されます。 オブジェクトのメモリ管理ライフサイクルは次のとおりです。

1. オブジェクトが作成されると、メモリが割り当てられ、コンストラクターが実行され、オブジェクトがライブと見なされます。
2. オブジェクト (またはその一部) が、デストラクターを実行するのではなく、実行の継続によってアクセスできない場合、オブジェクトは使用されなくなったと見なされ、破棄の対象になります。 C#コンパイラとガベージコレクターは、コードを分析して、オブジェクトへの参照を将来使用できるかどうかを判断することができます。 たとえば、スコープ内にあるローカル変数がオブジェクトへの既存の参照であるが、そのローカル変数が、プロシージャの現在の実行ポイントからの実行の継続で参照されていない場合、ガベージコレクターが発生する可能性があります (ただし、必須) オブジェクトは使用されなくなったものとして扱います。
3. オブジェクトが破棄されるようになると、指定されていない場合は、そのオブジェクトのデストラクター ([デストラクター](classes.md#destructors)) が実行されます。 通常の状況下では、オブジェクトのデストラクターが1回だけ実行されます。ただし、実装固有の Api では、この動作がオーバーライドされる可能性があります。
4. オブジェクトのデストラクターが実行されると、そのオブジェクト、またはその一部が、デストラクターの実行など、実行の継続によってアクセスできなくなると、オブジェクトはアクセス不可能と見なされ、オブジェクトがコレクションの対象になります。
5. 最後に、オブジェクトがコレクションの対象になると、そのオブジェクトに関連付けられているメモリがガベージコレクターによって解放されます。

ガベージコレクターは、オブジェクトの使用状況に関する情報を保持し、この情報を使用してメモリ管理の決定を行います。たとえば、新しく作成されたオブジェクトをメモリ内に配置する場所、オブジェクトを再配置するタイミング、オブジェクトが使用されていない場合やアクセスできない場合などです。

ガベージコレクターの存在を想定している他の言語C#と同様に、は、ガベージコレクターが幅広いメモリ管理ポリシーを実装できるように設計されています。 たとえば、でC#は、デストラクターを実行する必要はありません。また、オブジェクトが適格であるか、またはそのデストラクターが特定の順序または特定のスレッドで実行されることもありません。

ガベージコレクターの動作は、クラスの静的メソッドを使用して、ある程度制御できます `System.GC`。 このクラスを使用して、コレクションの発生を要求したり、デストラクターを実行 (または実行しない) したりすることができます。

ガベージコレクターでは、オブジェクトを収集してデストラクターを実行するタイミングを決定する際に、ワイド緯度が許可されるため、次のコードに示されているものとは異なる出力が、準拠する実装によって生成される場合があります。 プログラム
```csharp
using System;

class A
{
    ~A() {
        Console.WriteLine("Destruct instance of A");
    }
}

class B
{
    object Ref;

    public B(object o) {
        Ref = o;
    }

    ~B() {
        Console.WriteLine("Destruct instance of B");
    }
}

class Test
{
    static void Main() {
        B b = new B(new A());
        b = null;
        GC.Collect();
        GC.WaitForPendingFinalizers();
    }
}
```
クラス `A` およびクラス `B` のインスタンスを作成します。 変数 `b` に @no__t 値が割り当てられている場合、これらのオブジェクトはガベージコレクションの対象になります。この時間が経過すると、ユーザーが記述したコードにアクセスできなくなるためです。 出力は、

```console
Destruct instance of A
Destruct instance of B
```
または
```console
Destruct instance of B
Destruct instance of A
```
この言語では、オブジェクトがガベージコレクションされる順序に制約はありません。

軽微なケースとして、"破棄の対象" と "コレクションの対象" の区別が重要になる場合があります。 例を次に示します。
```csharp
using System;

class A
{
    ~A() {
        Console.WriteLine("Destruct instance of A");
    }

    public void F() {
        Console.WriteLine("A.F");
        Test.RefA = this;
    }
}

class B
{
    public A Ref;

    ~B() {
        Console.WriteLine("Destruct instance of B");
        Ref.F();
    }
}

class Test
{
    public static A RefA;
    public static B RefB;

    static void Main() {
        RefB = new B();
        RefA = new A();
        RefB.Ref = RefA;
        RefB = null;
        RefA = null;

        // A and B now eligible for destruction
        GC.Collect();
        GC.WaitForPendingFinalizers();

        // B now eligible for collection, but A is not
        if (RefA != null)
            Console.WriteLine("RefA is not null");
    }
}
```

上記のプログラムでは、ガベージコレクターが `B` のデストラクターの前に `A` のデストラクターを実行するように選択した場合、このプログラムの出力は次のようになります。
```console
Destruct instance of A
Destruct instance of B
A.F
RefA is not null
```

@No__t-0 のインスタンスは使用されておらず、`A` のデストラクターが実行されていましたが、`A` (この場合は `F`) のメソッドが別のデストラクターから呼び出される可能性もあります。 また、デストラクターを実行すると、メインラインプログラムからオブジェクトが再び使用できるようになる可能性があることに注意してください。 この場合、`B` のデストラクターを実行すると、以前に使用されていなかった `A` のインスタンスが、ライブ参照 @no__t からアクセスできるようになりました。 @No__t-0 の呼び出しの後、`B` のインスタンスは、コレクションの対象になりますが、`A` のインスタンスは、参照 `Test.RefA` によるものではありません。

混乱や予期しない動作を避けるため、一般に、デストラクターは、オブジェクトの独自のフィールドに格納されているデータに対してのみクリーンアップを実行し、参照先のオブジェクトや静的フィールドに対してアクションを実行しないようにすることをお勧めします。

デストラクターを使用する代わりに、クラスが @no__t 0 インターフェイスを実装できるようにすることもできます。 これにより、オブジェクトのクライアントは、オブジェクトのリソースを解放するタイミングを決定できます。通常は、オブジェクトに @no__t 0 のステートメント ([using ステートメント](statements.md#the-using-statement)) のリソースとしてアクセスします。

## <a name="execution-order"></a>実行順序

C#プログラムの実行は、実行中の各スレッドの副作用が重要な実行ポイントで保持されるようになります。 ***副作用***は、volatile フィールドの読み取りまたは書き込み、不揮発性の変数への書き込み、外部リソースへの書き込み、および例外のスローとして定義されます。 これらの副作用の順序を維持する必要がある重要な実行ポイントは、volatile フィールド ([volatile フィールド](classes.md#volatile-fields)) への参照、@no__t 1 つのステートメント ([lock ステートメント](statements.md#the-lock-statement))、およびスレッドの作成と終了です。 実行環境では、 C#プログラムの実行順序を自由に変更できます。次の制約が適用されます。

*  データ依存は、実行スレッド内で保持されます。 つまり、各変数の値は、スレッド内のすべてのステートメントが元のプログラムの順序で実行されたかのように計算されます。
*  初期化の順序付け規則が保持されます ([フィールド初期化](classes.md#field-initialization)と[変数初期化子](classes.md#variable-initializers))。
*  副作用の順序は、揮発性の読み取りと書き込み ([volatile フィールド](classes.md#volatile-fields)) に関して保持されます。 さらに、式の値が使用されていないことを推測し、必要な副作用が生成されない場合 (メソッドの呼び出しや volatile フィールドへのアクセスによって発生する問題を含む)、実行環境は式の一部を評価する必要がありません。 非同期イベント (別のスレッドによってスローされた例外など) によってプログラムの実行が中断された場合、観測可能な副作用が元のプログラムの順序で表示される保証はありません。
