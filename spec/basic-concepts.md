---
ms.openlocfilehash: ff31585520c9090ad92893a930327112743c8e77
ms.sourcegitcommit: 892af9016b3317a8fae12d195014dc38ba51cf16
ms.translationtype: MT
ms.contentlocale: ja-JP
ms.lasthandoff: 10/01/2019
ms.locfileid: "71704004"
---
# <a name="basic-concepts"></a>基本的な概念

## <a name="application-startup"></a>アプリケーションの起動

***エントリポイント***を持つアセンブリは、***アプリケーション***と呼ばれます。 アプリケーションを実行すると、新しい***アプリケーションドメイン***が作成されます。 アプリケーションの複数の異なるインスタンス化が同時に同じコンピューター上に存在し、それぞれに独自のアプリケーションドメインが存在する場合があります。

アプリケーションドメインは、アプリケーションの状態のコンテナーとして機能することによって、アプリケーションの分離を可能にします。 アプリケーションドメインは、アプリケーションで定義されている型とそれが使用するクラスライブラリのコンテナーおよび境界として機能します。 1つのアプリケーションドメインに読み込まれる型は、別のアプリケーションドメインに読み込まれる同じ型とは異なり、オブジェクトのインスタンスはアプリケーションドメイン間で直接共有されません。 たとえば、各アプリケーションドメインには、これらの型の静的変数の独自のコピーがあり、型の静的コンストラクターはアプリケーションドメインごとに1回だけ実行されます。 実装には、アプリケーションドメインの作成と破棄を行うための実装固有のポリシーやメカニズムを無料で用意しています。

***アプリケーションの起動***は、実行環境が、アプリケーションのエントリポイントと呼ばれる指定されたメソッドを呼び出すと発生します。 このエントリポイントメソッドは常に `Main`という名前で、次のいずれかのシグネチャを持つことができます。

```csharp
static void Main() {...}

static void Main(string[] args) {...}

static int Main() {...}

static int Main(string[] args) {...}
```

示されているように、エントリポイントは必要に応じて `int` 値を返すことができます。 この戻り値は、アプリケーションの終了 ([アプリケーションの終了](basic-concepts.md#application-termination)) で使用されます。

エントリポイントには、必要に応じて、1つの仮パラメーターを指定できます。 パラメーターには任意の名前を指定できますが、パラメーターの型は `string[]`である必要があります。 仮パラメーターが存在する場合、実行環境は、アプリケーションの起動時に指定されたコマンドライン引数を含む `string[]` 引数を作成して渡します。 `string[]` 引数が null になることはありませんが、コマンドライン引数が指定されていない場合、長さが0になることがあります。

でC#はメソッドのオーバーロードがサポートされているため、クラスまたは構造体には、それぞれ異なるシグネチャを持つメソッドの複数の定義を含めることができます。 ただし、1つのプログラム内では、クラスまたは構造体に、アプリケーションのエントリポイントとして使用されることを修飾する `Main` と呼ばれる複数のメソッドを含めることができます。 ただし、複数のパラメーターがある場合、またはその唯一のパラメーターが型 `string[]`以外の場合は、`Main` の他のオーバーロードされたバージョンを使用できます。

アプリケーションは、複数のクラスまたは構造体で構成できます。 これらのクラスまたは構造体の1つに、アプリケーションのエントリポイントとして使用することが定義されている `Main` という名前のメソッドを含めることができます。 このような場合は、外部機構 (コマンドラインコンパイラオプションなど) を使用して、これらの `Main` メソッドのいずれかをエントリポイントとして選択する必要があります。

でC#は、すべてのメソッドをクラスまたは構造体のメンバーとして定義する必要があります。 通常、メソッドの宣言されたアクセシビリティ ([アクセシビリティ](basic-concepts.md#declared-accessibility)) は、宣言で指定されたアクセス修飾子 ([アクセス](classes.md#access-modifiers)修飾子) によって決まります。同様に、型の宣言されたアクセシビリティは、宣言で指定されたアクセス修飾子によって決まります。 特定の型の特定のメソッドを呼び出し可能にするためには、型とメンバーの両方にアクセスできる必要があります。 ただし、アプリケーションのエントリポイントは特殊なケースです。 具体的には、実行環境は、宣言されたアクセシビリティに関係なく、それを囲む型宣言のアクセシビリティに関係なく、アプリケーションのエントリポイントにアクセスできます。

アプリケーションエントリポイントメソッドがジェネリッククラス宣言に含まれていない可能性があります。

それ以外の点では、エントリポイントメソッドはエントリポイントではないもののように動作します。

## <a name="application-termination"></a>アプリケーションの終了

***アプリケーションの終了***では、実行環境に制御が戻ります。

アプリケーションの***エントリポイント***メソッドの戻り値の型が `int`場合、返される値はアプリケーションの***終了ステータスコード***として機能します。 このコードの目的は、実行環境への成功または失敗の通信を許可することです。

エントリポイントメソッドの戻り値の型が `void`である場合、そのメソッドを終了する右中かっこ (`}`) に到達するか、式のない `return` ステートメントを実行すると、終了ステータスコード `0`が生成されます。

アプリケーションが終了する前は、ガベージコレクションされていないすべてのオブジェクトのデストラクターが呼び出されます。ただし、そのようなクリーンアップが抑制されている場合 (ライブラリメソッド `GC.SuppressFinalize`の呼び出しによって) は呼び出されません。

## <a name="declarations"></a>宣言

C#プログラムの宣言は、プログラムの構成要素を定義します。 C#プログラムは名前空間 ([名前空間](namespaces.md)) を使用して編成され、型宣言と入れ子になった名前空間宣言を含めることができます。 型宣言 ([型宣言](namespaces.md#type-declarations)) は、クラス ([クラス](classes.md))、構造体 ([構造体](structs.md))、インターフェイス ([インターフェイス](interfaces.md))、列挙型 ([列挙](enums.md)型)、およびデリゲート ([デリゲート](delegates.md)) を定義するために使用されます。 型宣言で許可されるメンバーの種類は、型宣言の形式によって異なります。 たとえば、クラス宣言には、定数 ([定数](classes.md#constants))、フィールド ([フィールド](classes.md#fields))、メソッド ([メソッド](classes.md#methods))、プロパティ ([プロパティ](classes.md#properties))、イベント ([イベント](classes.md#events))、インデクサー ([インデクサー](classes.md#indexers))、演算子 ([演算子](classes.md#operators))、インスタンスコンストラクター ([インスタンスコンストラクター](classes.md#instance-constructors))、静的コンストラクター ([静的コンストラクター](classes.md#static-constructors))、デストラクター ([デストラクター](classes.md#destructors))、および入れ子にされた型 (入れ子にされた[型](classes.md#nested-types)) の宣言を含める

宣言は、宣言が属する宣言***空間***内の名前を定義します。 オーバーロードされたメンバー ([シグネチャおよびオーバーロード](basic-concepts.md#signatures-and-overloading)) を除き、宣言空間で同じ名前のメンバーを導入する2つ以上の宣言があると、コンパイル時にエラーになります。 宣言空間には、同じ名前を持つ異なる種類のメンバーを含めることはできません。 たとえば、宣言空間には、同じ名前のフィールドとメソッドを含めることはできません。

次に示すように、さまざまな種類の宣言スペースがあります。

*  プログラムのすべてのソースファイル内で、を囲む*namespace_declaration*を持たない*namespace_member_declaration*は、***グローバル宣言空間***と呼ばれる1つの結合された宣言空間のメンバーになります。
*  プログラムのすべてのソースファイル内で、 *namespace_declaration*内の*namespace_member_declaration*は、完全修飾された同じ名前空間名を持つ1つの組み合わせの宣言空間のメンバーになります。
*  クラス、構造体、またはインターフェイスの宣言ごとに、新しい宣言領域が作成されます。 名前は、 *class_member_declaration*s、 *struct_member_declaration*s、 *interface_member_declaration*s、または*type_parameter*s を介してこの宣言領域に導入されます。 オーバーロードされたインスタンスコンストラクター宣言と静的コンストラクター宣言を除き、クラスまたは構造体には、クラスまたは構造体と同じ名前を持つメンバー宣言を含めることはできません。 クラス、構造体、またはインターフェイスは、オーバーロードされたメソッドとインデクサーの宣言を許可します。 さらに、クラスまたは構造体は、オーバーロードされたインスタンスコンストラクターと演算子の宣言を許可します。 たとえば、クラス、構造体、またはインターフェイスには、同じ名前を持つ複数のメソッド宣言が含まれている場合があります。これらのメソッド宣言がシグネチャ ([シグネチャとオーバーロード](basic-concepts.md#signatures-and-overloading)) で異なる場合に限ります。 基底クラスはクラスの宣言空間に関与しないことに注意してください。基本インターフェイスは、インターフェイスの宣言空間に関与しません。 したがって、派生クラスまたはインターフェイスは、継承されたメンバーと同じ名前を持つメンバーを宣言できます。 このようなメンバーは、継承されたメンバーを***非表示***にすると言います。
*  各デリゲート宣言によって、新しい宣言空間が作成されます。 名前は、仮パラメーター (*fixed_parameter*s および*parameter_array*s) と*type_parameter*s を使用して、この宣言領域に導入されます。
*  列挙型の宣言ごとに、新しい宣言空間が作成されます。 名前は、 *enum_member_declarations*によってこの宣言領域に導入されます。
*  各メソッド宣言、インデクサー宣言、演算子宣言、インスタンスコンストラクター宣言、および匿名関数は、***ローカル変数宣言空間***と呼ばれる新しい宣言領域を作成します。 名前は、仮パラメーター (*fixed_parameter*s および*parameter_array*s) と*type_parameter*s を使用して、この宣言領域に導入されます。 関数メンバーまたは匿名関数 (存在する場合) の本体は、ローカル変数宣言領域内で入れ子になっていると見なされます。 ローカル変数宣言空間と入れ子になったローカル変数宣言空間が同じ名前の要素を含むようにすると、エラーになります。 したがって、入れ子になった宣言領域内では、ローカル変数または定数を、外側の宣言空間内のローカル変数または定数と同じ名前で宣言することはできません。 2つの宣言空間に、同じ名前の要素を含めることができます。ただし、宣言領域に他方の要素が含まれている必要はありません。
*  各*ブロック*または*switch_block* 、および*for*、 *foreach* 、および*using*ステートメントでは、ローカル変数とローカル定数のローカル変数宣言空間が作成されます。 名前は*local_variable_declaration*s および*local_constant_declaration*s を介してこの宣言領域に導入されます。 関数メンバーまたは匿名関数の本体内またはその内部で発生するブロックは、それらのパラメーターの関数によって宣言されたローカル変数宣言領域内で入れ子になっています。 したがって、ローカル変数を持つメソッドや、同じ名前のパラメーターを使用すると、エラーになります。
*  各*ブロック*または*switch_block*は、ラベル用に個別の宣言領域を作成します。 名前は*labeled_statement*s を介してこの宣言領域に導入され、名前は*goto_statement*s を介して参照されます。 ブロックの***ラベル宣言領域***には、入れ子になったブロックが含まれます。 したがって、入れ子になったブロック内では、外側のブロックでラベルと同じ名前のラベルを宣言することはできません。

名前が宣言される文字列の順序は、一般に意味がありません。 特に、名前空間、定数、メソッド、プロパティ、イベント、インデクサー、演算子、インスタンスコンストラクター、デストラクター、静的コンストラクター、および型の宣言と使用については、テキストの順序は重要ではありません。 宣言の順序は、次の点で重要です。

*  フィールド宣言とローカル変数宣言の宣言順序によって、初期化子 (存在する場合) が実行される順序が決まります。
*  ローカル変数は、使用する前に定義する必要があります ([スコープ](basic-concepts.md#scopes))。
*  列挙メンバー宣言 ([列挙メンバー](enums.md#enum-members)) の宣言順序は、 *constant_expression*値を省略した場合に重要になります。

名前空間の宣言領域は "open 終了" であり、同じ完全修飾名を持つ2つの名前空間宣言は、同じ宣言空間に関与します。 次に例を示します。
```csharp
namespace Megacorp.Data
{
    class Customer
    {
        ...
    }
}

namespace Megacorp.Data
{
    class Order
    {
        ...
    }
}
```

上記の2つの名前空間宣言は同じ宣言領域に寄与します。この例では、完全修飾名を持つ2つのクラスを宣言し `Megacorp.Data.Customer` および `Megacorp.Data.Order`ます。 2つの宣言は同じ宣言領域に関与するため、それぞれに同じ名前のクラスの宣言が含まれていると、コンパイル時エラーが発生します。

前述のように、ブロックの宣言空間には、入れ子になったブロックが含まれます。 したがって、次の例では、`F` メソッドと `G` メソッドによってコンパイル時エラーが発生します。これは、名前 `i` が外側のブロックで宣言され、内部ブロックで再宣言できないためです。 ただし、2つの `i`が入れ子になっていない個別のブロックで宣言されているため、`H` メソッドと `I` メソッドは有効です。

```csharp
class A
{
    void F() {
        int i = 0;
        if (true) {
            int i = 1;            
        }
    }

    void G() {
        if (true) {
            int i = 0;
        }
        int i = 1;                
    }

    void H() {
        if (true) {
            int i = 0;
        }
        if (true) {
            int i = 1;
        }
    }

    void I() {
        for (int i = 0; i < 10; i++)
            H();
        for (int i = 0; i < 10; i++)
            H();
    }
}
```

## <a name="members"></a>メンバー

名前空間と型には***メンバー***があります。 エンティティのメンバーは、エンティティへの参照で始まる修飾名を使用し、その後に "`.`" トークンを続け、その後にメンバーの名前を指定することで、一般に使用できます。

型のメンバーは、型宣言で宣言されているか、型の基底クラスから***継承***されています。 型が基本クラスから継承する場合、インスタンスコンストラクター、デストラクター、および静的コンストラクターを除く、基本クラスのすべてのメンバーが派生型のメンバーになります。 基底クラスのメンバーに対して宣言されたアクセシビリティでは、メンバーが継承されるかどうかは制御されません。継承は、インスタンスコンストラクター、静的コンストラクター、またはデストラクターではない任意のメンバーに及びます。 ただし、継承されたメンバーは、アクセシビリティが宣言されている ([アクセシビリティが宣言](basic-concepts.md#declared-accessibility)されている) か、型自体の宣言によって非表示になっている (継承によって[隠ぺい](basic-concepts.md#hiding-through-inheritance)されている) ため、派生型ではアクセスできない可能性があります。

### <a name="namespace-members"></a>名前空間のメンバー

外側の名前空間を持たない名前空間と型は、***グローバル名前空間***のメンバーです。 これは、グローバル宣言領域で宣言されている名前に直接対応します。

名前空間内で宣言された名前空間と型は、その名前空間のメンバーになります。 これは、名前空間の宣言空間で宣言されている名前に直接対応します。

名前空間には、アクセス制限がありません。 プライベート、プロテクト、または内部の名前空間を宣言することはできません。また、名前空間名には常にパブリックにアクセスできます。

### <a name="struct-members"></a>構造体のメンバー

構造体のメンバーは、構造体で宣言されたメンバーと、構造体の直接基底クラス `System.ValueType` から継承されたメンバー、および間接基底クラス `object`です。

単純型のメンバーは、単純型によってエイリアス化された構造体型のメンバーに直接対応します。

*  `sbyte` のメンバーは、`System.SByte` 構造体のメンバーです。
*  `byte` のメンバーは、`System.Byte` 構造体のメンバーです。
*  `short` のメンバーは、`System.Int16` 構造体のメンバーです。
*  `ushort` のメンバーは、`System.UInt16` 構造体のメンバーです。
*  `int` のメンバーは、`System.Int32` 構造体のメンバーです。
*  `uint` のメンバーは、`System.UInt32` 構造体のメンバーです。
*  `long` のメンバーは、`System.Int64` 構造体のメンバーです。
*  `ulong` のメンバーは、`System.UInt64` 構造体のメンバーです。
*  `char` のメンバーは、`System.Char` 構造体のメンバーです。
*  `float` のメンバーは、`System.Single` 構造体のメンバーです。
*  `double` のメンバーは、`System.Double` 構造体のメンバーです。
*  `decimal` のメンバーは、`System.Decimal` 構造体のメンバーです。
*  `bool` のメンバーは、`System.Boolean` 構造体のメンバーです。

### <a name="enumeration-members"></a>列挙型のメンバー

列挙体のメンバーは、列挙体で宣言された定数と、列挙体の direct 基底クラス `System.Enum` から継承されたメンバー、および `System.ValueType` と `object`の間接的な基本クラスです。

### <a name="class-members"></a>クラス メンバー

クラスのメンバーは、クラスで宣言されたメンバーと、基本クラスから継承されたメンバー (基底クラスを持たないクラス `object` を除く) です。 基本クラスから継承されたメンバーには、基本クラスの定数、フィールド、メソッド、プロパティ、イベント、インデクサー、演算子、および型が含まれますが、インスタンスコンストラクター、デストラクター、および基底クラスの静的コンストラクターは含まれません。 基底クラスのメンバーは、アクセシビリティに関係なく継承されます。

クラス宣言には、定数、フィールド、メソッド、プロパティ、イベント、インデクサー、演算子、インスタンスコンストラクター、デストラクター、静的コンストラクター、および型の宣言を含めることができます。

`object` と `string` のメンバーは、そのエイリアスを持つクラス型のメンバーに直接対応します。

*  `object` のメンバーは、`System.Object` クラスのメンバーです。
*  `string` のメンバーは、`System.String` クラスのメンバーです。

### <a name="interface-members"></a>インターフェイスのメンバー

インターフェイスのメンバーは、インターフェイス内で宣言されたメンバーと、インターフェイスのすべての基本インターフェイスで宣言されています。 `object` クラスのメンバーは、厳密に言えば、インターフェイス ([インターフェイスメンバー](interfaces.md#interface-members)) のメンバーではありません。 ただし、クラス `object` のメンバーは、任意のインターフェイス型 ([メンバー参照](expressions.md#member-lookup)) でメンバー参照を介して使用できます。

### <a name="array-members"></a>配列のメンバー

配列のメンバーは、クラス `System.Array`から継承されたメンバーです。

### <a name="delegate-members"></a>デリゲートメンバー

デリゲートのメンバーは、クラス `System.Delegate`から継承されたメンバーです。

## <a name="member-access"></a>メンバー アクセス。

メンバーの宣言によって、メンバーアクセスを制御できます。 メンバーのアクセシビリティは、メンバーのアクセシビリティ ([宣言](basic-concepts.md#declared-accessibility)されたアクセシビリティ) によって、すぐに含まれる型のアクセシビリティ (存在する場合) と組み合わせて確立されます。

特定のメンバーへのアクセスが許可されている場合、そのメンバーは***アクセス可能***であると言われます。 逆に、特定のメンバーへのアクセスが許可されていない場合、そのメンバーはアクセス***不可能***と見なされます。 メンバーへのアクセスが許可されるのは、アクセスが行われるテキストの場所が、メンバーのアクセシビリティドメイン ([アクセシビリティ](basic-concepts.md#accessibility-domains)ドメイン) に含まれている場合です。

### <a name="declared-accessibility"></a>アクセシビリティの宣言

メンバーに対して宣言された***アクセシビリティ***は、次のいずれかになります。

*  Public。メンバー宣言に `public` 修飾子を含めることによって選択されます。 `public` の直感的な意味は、"アクセスが制限されていません" です。
*  Protected。メンバー宣言に `protected` 修飾子を含めることによって選択されます。 `protected` の直感的な意味は、"含まれるクラスに対してアクセスが制限されているか、そのクラスから派生した型" です。
*  Internal。メンバー宣言に `internal` 修飾子を含めることによって選択されます。 `internal` の直感的な意味は、"このプログラムに対するアクセスが制限されています" ということです。
*  Protected internal (protected または internal)。メンバー宣言に `protected` と `internal` 修飾子の両方を含めることによって選択されます。 `protected internal` の直感的な意味は、"このプログラムにはアクセスが制限されます。または、包含クラスから派生した型" です。
*  Private。メンバー宣言に `private` 修飾子を含めることによって選択されます。 `private` の直感的な意味は、"含まれる型に制限されたアクセス" です。

メンバー宣言が行われるコンテキストによっては、特定の種類のアクセシビリティのみが許可されます。 さらに、メンバー宣言にアクセス修飾子が含まれていない場合、宣言が実行されるコンテキストによって、既定で宣言されたアクセシビリティが決まります。

*  名前空間は、宣言されたアクセシビリティを暗黙的に `public` します。 名前空間宣言でアクセス修飾子を使用することはできません。
*  コンパイル単位または名前空間で宣言された型は、`public` または `internal` 宣言されたアクセシビリティを持つことができ、宣言されたアクセシビリティを `internal` に既定値を持つ
*  クラスメンバーは、宣言されたアクセシビリティの5種類のいずれかを持つことができ、既定で宣言されたアクセシビリティ `private` に設定できます。 (クラスのメンバーとして宣言された型は、5種類のアクセシビリティを持つことができますが、名前空間のメンバーとして宣言された型は、`public` または `internal` 宣言されたアクセシビリティのみを持つことができます)。
*  構造体メンバーは、`public`、`internal`、または `private` として宣言されたアクセシビリティを持つことができ、構造体は暗黙的にシールされるため、宣言されたアクセシビリティを既定で `private` 構造体で導入された構造体のメンバー (その構造体によって継承されない) は、`protected` または `protected internal` によって宣言されたアクセシビリティを持つことはできません。 (構造体のメンバーとして宣言された型は、`public`、`internal`、または `private` アクセシビリティを宣言できますが、名前空間のメンバーとして宣言されている型は、`public` または `internal` のアクセシビリティのみを持つことができます)。
*  インターフェイスのメンバーは、宣言されたアクセシビリティを暗黙的に `public` します。 インターフェイスメンバー宣言でアクセス修飾子を使用することはできません。
*  列挙型のメンバーは、宣言されたアクセシビリティを暗黙的に `public` します。 列挙メンバー宣言でアクセス修飾子を使用することはできません。

### <a name="accessibility-domains"></a>アクセシビリティドメイン

メンバーの***アクセシビリティドメイン***は、プログラムテキストの中で、メンバーへのアクセスが許可されている (不整合の可能性がある) セクションで構成されます。 メンバーのアクセシビリティドメインを定義する目的では、メンバーが型の中で宣言されていない場合は***最上位レベル***と呼ばれ、別の型で宣言されている場合はメンバーが***入れ子になっ***ていると言います。 さらに、プログラムの***プログラムテキスト***は、プログラムのすべてのソースファイルに含まれるすべてのプログラムテキストとして定義されます。また、型のプログラムテキストは、その型の*type_declaration*s に含まれるすべてのプログラムテキストとして定義されます (場合によっては、型の中で入れ子になっている型を含みます)。

定義済みの型 (`object`、`int`、`double`など) のアクセシビリティドメインは無制限です。

プログラム `P` で宣言されている最上位レベルのバインドさ[れてい](types.md#bound-and-unbound-types)ない型 `T` のアクセシビリティドメインは、次のように定義されています。

*  宣言された `T` のアクセシビリティが `public`場合、`T` のアクセシビリティドメインは `P` のプログラムテキストと `P`を参照するすべてのプログラムになります。
*  `T` に対して宣言されているアクセシビリティが `internal` の場合、`T` のアクセシビリティ ドメインは `P` のプログラム テキストになります。

これらの定義から、最上位レベルのバインド解除された型のアクセシビリティドメインは、その型が宣言されているプログラムのプログラムテキスト以上であることに従います。

構築された型 `T<A1, ..., An>` のアクセシビリティドメインは、バインドされていないジェネリック型 `T` のアクセシビリティドメインと、`A1, ..., An`型引数のアクセシビリティドメインの積集合です。

入れ子になったメンバーのアクセシビリティドメインは、プログラム内で `T` 型で宣言されている `M` `P` 次のように定義されます (`M` 自体が型である場合もあります)。

*  `M` に対して宣言されたアクセシビリティが `public` の場合、`M` のアクセシビリティ ドメインは `T` のアクセシビリティ ドメインになります。
*  宣言された `M` のアクセシビリティが `protected internal`場合は、`P` のプログラムテキストと `T`から派生した任意の型のプログラムテキストの和集合に `D` します。これは `P`の外部で宣言されます。 `M` のアクセシビリティドメインは、`T` のアクセシビリティドメインと `D`の共通部分です。
*  宣言された `M` のアクセシビリティが `protected`場合は、`T` のプログラムテキストと `T`から派生した任意の型のプログラムテキストの和集合を `D` ます。 `M` のアクセシビリティドメインは、`T` のアクセシビリティドメインと `D`の共通部分です。
*  `M` に対して宣言されているアクセシビリティが `internal` の場合、`M` のアクセシビリティ ドメインは、`T` のアクセシビリティ ドメインと `P` のプログラム テキストとの積集合になります。
*  `M` に対して宣言されているアクセシビリティが `private` の場合、`M` のアクセシビリティ ドメインは `T` のプログラム テキストになります。

これらの定義から、入れ子になったメンバーのアクセシビリティドメインは、メンバーが宣言されている型のプログラムテキスト以上であることに従います。 さらに、メンバーのアクセシビリティドメインは、メンバーが宣言されている型のアクセシビリティドメインを超えないようにします。

直感的な用語では、型またはメンバーの `M` にアクセスするときに、アクセスが許可されていることを確認するために次の手順が評価されます。

*  1つ目の方法として `M` が (コンパイル単位または名前空間ではなく) 型の中で宣言されている場合、その型にアクセスできないと、コンパイル時エラーが発生します。
*  `M` が `public`場合は、アクセスが許可されます。
*  それ以外の場合、`M` が `protected internal`場合、`M` が宣言されているプログラム内でアクセスが発生した場合、または `M` が宣言され、派生クラスの型 ([インスタンスメンバーの保護されたアクセス](basic-concepts.md#protected-access-for-instance-members)) を介して実行されるクラスの内部にある場合は、アクセスが許可されます。
*  それ以外の場合、`M` が `protected`場合、`M` が宣言されているクラス内でアクセスが発生した場合、または `M` が宣言されていて、派生クラスの型 ([インスタンスメンバーの保護されたアクセス](basic-concepts.md#protected-access-for-instance-members)) を介して実行されるクラスの内部にある場合は、アクセスが許可されます。
*  それ以外の場合、`M` が `internal`場合、`M` が宣言されているプログラム内でアクセスが行われると、アクセスが許可されます。
*  それ以外の場合、`M` が `private`場合、`M` が宣言されている型内でアクセスが許可されていると、アクセスが許可されます。
*  それ以外の場合は、型またはメンバーにアクセスできないため、コンパイル時エラーが発生します。

この例では、
```csharp
public class A
{
    public static int X;
    internal static int Y;
    private static int Z;
}

internal class B
{
    public static int X;
    internal static int Y;
    private static int Z;

    public class C
    {
        public static int X;
        internal static int Y;
        private static int Z;
    }

    private class D
    {
        public static int X;
        internal static int Y;
        private static int Z;
    }
}
```
クラスとメンバーには、次のアクセシビリティドメインがあります。

*  `A` と `A.X` のアクセシビリティドメインは無制限です。
*  `A.Y`、`B`、`B.X`、`B.Y`、`B.C`、`B.C.X`、`B.C.Y` のアクセシビリティドメインは、格納しているプログラムのプログラムテキストです。
*  `A.Z` のアクセシビリティドメインは、`A`のプログラムテキストです。
*  `B.Z` と `B.D` のアクセシビリティドメインは `B`のプログラムテキストであり、`B.C` および `B.D`のプログラムテキストを含みます。
*  `B.C.Z` のアクセシビリティドメインは、`B.C`のプログラムテキストです。
*  `B.D.X` と `B.D.Y` のアクセシビリティドメインは `B`のプログラムテキストであり、`B.C` および `B.D`のプログラムテキストを含みます。
*  `B.D.Z` のアクセシビリティドメインは、`B.D`のプログラムテキストです。

例に示すように、メンバーのアクセシビリティドメインは、それを含んでいる型のアクセシビリティドメインよりも大きくなることはありません。 たとえば、すべての `X` メンバーがパブリックに宣言されたアクセシビリティを持つ場合でも、それ `A.X` 以外のすべてのメンバーには、包含する型によって制約されるアクセシビリティドメインがあります。

「[メンバー](basic-concepts.md#members)」で説明したように、インスタンスコンストラクター、デストラクター、および静的コンストラクターを除く、基底クラスのすべてのメンバーは、派生型によって継承されます。 これには、基底クラスのプライベートメンバーも含まれます。 ただし、プライベートメンバーのアクセシビリティドメインには、メンバーが宣言されている型のプログラムテキストのみが含まれます。 この例では、
```csharp
class A
{
    int x;

    static void F(B b) {
        b.x = 1;        // Ok
    }
}

class B: A
{
    static void F(B b) {
        b.x = 1;        // Error, x not accessible
    }
}
```
`B` クラスは、`A` クラスからプライベートメンバー `x` を継承します。 メンバーはプライベートであるため、`A`の*class_body*内でのみアクセスできます。 したがって、`b.x` へのアクセスは `A.F` メソッドで成功しますが、`B.F` メソッドでは失敗します。

### <a name="protected-access-for-instance-members"></a>インスタンスメンバーの保護されたアクセス

`protected` インスタンスメンバーが宣言されているクラスのプログラムテキストの外部でアクセスされ、`protected internal` インスタンスメンバーが宣言されているプログラムのプログラムテキストの外部にアクセスする場合、アクセスは、宣言されているクラスから派生したクラス宣言内で実行する必要があります。 さらに、その派生クラス型のインスタンス、またはそれから構築されたクラス型を使用してアクセスする必要があります。 この制限により、メンバーが同じ基本クラスから継承されている場合でも、1つの派生クラスが他の派生クラスのプロテクトメンバーにアクセスするのを防ぐことができます。

`M`保護されたインスタンスメンバーを宣言する基底クラスとして `B` し、`B`から派生したクラスに `D` できるようにします。 `D`の*class_body*内で `M` へのアクセスには、次のいずれかの形式を使用できます。

*  `M`フォームの修飾されていない*type_name*または*primary_expression* 。
*  フォーム `E.M`の*primary_expression* 。 `E` の型が `T` であるか、`T`から派生したクラス (`T` がクラス型 `D`、またはから構築されたクラス型である場合) `D`
*  フォーム `base.M`の*primary_expression* 。

派生クラスは、これらの形式のアクセスに加えて、 *constructor_initializer*内の基底クラスの保護されたインスタンスコンストラクターにアクセスできます ([コンストラクター初期化子](classes.md#constructor-initializers))。

この例では、
```csharp
public class A
{
    protected int x;

    static void F(A a, B b) {
        a.x = 1;        // Ok
        b.x = 1;        // Ok
    }
}

public class B: A
{
    static void F(A a, B b) {
        a.x = 1;        // Error, must access through instance of B
        b.x = 1;        // Ok
    }
}
```
`A`内では、`A` と `B`の両方のインスタンスを介して `x` にアクセスすることができます。どちらの場合も、アクセスは `A` のインスタンスまたは `A`から派生したクラスによって行われるためです。 ただし `B`内では、`A` は `B`から派生していないため、`A`のインスタンスを介して `x` にアクセスすることはできません。

この例では、
```csharp
class C<T>
{
    protected T x;
}

class D<T>: C<T>
{
    static void F() {
        D<T> dt = new D<T>();
        D<int> di = new D<int>();
        D<string> ds = new D<string>();
        dt.x = default(T);
        di.x = 123;
        ds.x = "test";
    }
}
```
`x` に対する3つの割り当ては、ジェネリック型から構築されたクラス型のインスタンスを通じてすべての処理が行われるため、許可されます。

### <a name="accessibility-constraints"></a>アクセシビリティの制約

C#言語のいくつかの構造体は、少なくともメンバーまたは別の型***としてアクセスできる***型である必要があります。 `T` のアクセシビリティドメインが `M`のアクセシビリティドメインのスーパーセットである場合、`T` 型は少なくともメンバーまたは型 `M` と同じようにアクセス可能であると言います。 つまり、`M` にアクセスできるすべてのコンテキストで `T` にアクセスできる場合、`T` は少なくとも `M` と同じようにアクセスできます。

次のアクセシビリティ制約が存在します。

*  クラスの型の直接基底クラスは、少なくとも、クラスの型自体と同程度にアクセス可能である必要があります。
*  インターフェイスの型の明示的な基本インターフェイスは、少なくとも、インターフェイスの型自体と同程度にアクセス可能である必要があります。
*  デリゲート型の戻り値の型およびパラメーターの型は、少なくとも、デリゲート型自体と同程度にアクセス可能である必要があります。
*  定数の型は、少なくとも定数自体と同程度にアクセス可能である必要があります。
*  フィールドの型は、少なくともフィールド自体と同程度にアクセス可能である必要があります。
*  メソッドの戻り値の型およびパラメーターの型は、少なくとも、メソッド自体と同程度にアクセス可能である必要があります。
*  プロパティの型は、少なくともプロパティ自体と同程度にアクセス可能である必要があります。
*  イベントの型は、少なくともイベント自体と同程度にアクセス可能である必要があります。
*  インデクサーの型とパラメーターの型は、少なくとも、インデクサー自体と同程度にアクセス可能である必要があります。
*  演算子の戻り値の型とパラメーターの型は、少なくとも、演算子自体と同程度にアクセス可能である必要があります。
*  インスタンスコンストラクターのパラメーターの型は、少なくともインスタンスコンストラクター自体と同じようにアクセス可能である必要があります。

この例では、
```csharp
class A {...}

public class B: A {...}
```
`B` クラスは、`A` に少なくとも `B`としてアクセスできないため、コンパイル時エラーが発生します。

同様に、例では
```csharp
class A {...}

public class B
{
    A F() {...}

    internal A G() {...}

    public A H() {...}
}
```
`B` の `H` メソッドは、戻り値の型 `A` がメソッドとは少なくともアクセス可能ではないため、コンパイル時エラーが発生します。

## <a name="signatures-and-overloading"></a>署名とオーバーロード

メソッド、インスタンスコンストラクター、インデクサー、および演算子は、***シグネチャ***によって特徴付けられます。

*  メソッドのシグネチャは、メソッドの名前、型パラメーターの数、それぞれの仮パラメーターの型と種類 (値、参照、または出力) で構成されます。順序は左から右になります。 このため、仮パラメーターの型で発生するメソッドの型パラメーターは、その名前ではなく、メソッドの型引数リスト内の序数位置によって識別されます。 メソッドのシグネチャには、戻り値の型、右端のパラメーターに指定できる `params` 修飾子、および省略可能な型パラメーター制約は含まれません。
*  インスタンスコンストラクターのシグネチャは、それぞれの仮パラメーターの型と種類 (値、参照、または出力) で構成され、左から右の順序で考慮されます。 インスタンスコンストラクターのシグネチャには、右端のパラメーターに指定できる `params` 修飾子が明示的に含まれていません。
*  インデクサーのシグネチャは、それぞれの仮パラメーターの型で構成され、左から右の順序で考慮されます。 インデクサーのシグネチャには、特に要素の型は含まれません。また、右端のパラメーターに指定できる `params` 修飾子も含まれません。
*  演算子のシグネチャは、演算子の名前と、それぞれの仮パラメーターの型で構成されます。順序は左から右になります。 演算子のシグネチャには、結果の型は含まれません。

シグネチャは、クラス、構造体、およびインターフェイスのメンバーを***オーバーロード***するための有効なメカニズムです。

*  メソッドのオーバーロードにより、クラス、構造体、またはインターフェイスは、シグネチャがそのクラス、構造体、またはインターフェイス内で一意である場合に、同じ名前の複数のメソッドを宣言できます。
*  インスタンスコンストラクターのオーバーロードにより、クラスまたは構造体は、そのクラスまたは構造体内で一意のシグネチャを持つ場合に、複数のインスタンスコンストラクターを宣言できます。
*  インデクサーをオーバーロードすると、クラス、構造体、またはインターフェイスは、そのクラス、構造体、またはインターフェイス内で一意のシグネチャを持つことができるので、複数のインデクサーを宣言できます。
*  演算子のオーバーロードにより、クラスまたは構造体は、そのクラスまたは構造体内で一意のシグネチャを持つ場合、同じ名前の複数の演算子を宣言できます。

`out` および `ref` パラメーター修飾子はシグネチャの一部と見なされますが、1つの型で宣言されたメンバーは、`ref` と `out`だけでシグネチャが異なることはありません。 2つのメンバーが同じ型で宣言されている場合に、`out` 修飾子を持つ両方のメソッドのすべてのパラメーターが `ref` 修飾子に変更された場合、コンパイル時エラーが発生します。 署名の一致 (たとえば、非表示またはオーバーライド) のその他の目的では、`ref` と `out` はシグネチャの一部と見なされ、相互に一致しません。 (この制限は、 C#プログラムを共通言語基盤 (CLI) で実行するために簡単に変換できるようにすることです。これにより、`ref` と `out`のみが異なるメソッドを定義することはできません)。

署名のために、型 `object` と `dynamic` は同じものと見なされます。 したがって、1つの型で宣言されたメンバーは、`object` と `dynamic`だけでシグネチャが異なることがあります。

次の例は、オーバーロードされたメソッド宣言のセットとそのシグネチャを示しています。
```csharp
interface ITest
{
    void F();                        // F()

    void F(int x);                   // F(int)

    void F(ref int x);               // F(ref int)

    void F(out int x);               // F(out int)      error

    void F(int x, int y);            // F(int, int)

    int F(string s);                 // F(string)

    int F(int x);                    // F(int)          error

    void F(string[] a);              // F(string[])

    void F(params string[] a);       // F(string[])     error
}
```

`ref` および `out` パラメーター修飾子 ([メソッドパラメーター](classes.md#method-parameters)) は、シグネチャの一部であることに注意してください。 したがって、`F(int)` と `F(ref int)` は一意の署名です。 ただし、`F(ref int)` と `F(out int)` は、`ref` と `out`のみが異なるため、同じインターフェイス内で宣言することはできません。 また、戻り値の型と `params` 修飾子はシグネチャの一部ではないことに注意してください。したがって、戻り値の型、または `params` 修飾子の包含または除外に基づいてのみオーバーロードすることはできません。 そのため、上記で特定されたメソッド `F(int)` および `F(params string[])` の宣言では、コンパイル時エラーが発生します。

## <a name="scopes"></a>スコープ

名前の***スコープ***はプログラムテキストの領域であり、名前を修飾することなく、名前で宣言されたエンティティを参照できます。 スコープは***入れ子***にすることができます。また、内側のスコープは、外側のスコープから名前の意味を再宣言することができます (ただし、入れ子になったブロック内の[宣言](basic-concepts.md#declarations)によって課される制限はなく、外側のブロック内のローカル変数と同じ名前のローカル変数を宣言することはできません)。 外側のスコープの名前は、内側のスコープによってカバーされるプログラムテキストの領域で***非表示***になると言い、外部名へのアクセスは、名前を修飾することでのみ可能です。

*  *Namespace_declaration*を含まない*namespace_member_declaration* ([名前空間メンバー](namespaces.md#namespace-members)) によって宣言された名前空間メンバーのスコープは、プログラムテキスト全体です。
*  完全修飾名が `N` の*namespace_declaration*内の*namespace_member_declaration*によって宣言された名前空間メンバーのスコープは、完全修飾名が namespace_declaration であるか `N` で始まり、その後にピリオドが続くすべての *`N`* の*namespace_body*です。
*  *Extern_alias_directive*によって定義された名前のスコープは、その直後にコンパイル単位または名前空間の本体が含まれている*using_directive*s、 *global_attributes*および*namespace_member_declaration*を超えています。 *Extern_alias_directive*は、基になる宣言領域に新しいメンバーを提供しません。 つまり、 *extern_alias_directive*は推移的ではありませんが、は、それが発生するコンパイル単位または名前空間の本文にのみ影響します。
*  *Using_directive*によって定義またはインポートされた名前のスコープ ([ディレクティブを使用](namespaces.md#using-directives)) は、 *using_directive*が発生する*compilation_unit*または*namespace_body*の*namespace_member_declaration*を超えています。 *Using_directive*は、0個以上の名前空間、型、またはメンバーの名前を特定の*compilation_unit*または*namespace_body*内で使用できるようにすることはできますが、基になる宣言領域に新しいメンバーを追加することはできません。 つまり、 *using_directive*は推移的ではなく、それが発生する*compilation_unit*または*namespace_body*のみに影響します。
*  *Class_declaration* ([クラス宣言](classes.md#class-declarations)) の*type_parameter_list*によって宣言された型パラメーターのスコープは、その*class_body*の*class_base*、 *type_parameter_constraints_clause*s、および*class_declaration*です。
*  *Struct_declaration* ([構造体宣言](structs.md#struct-declarations)) の*type_parameter_list*によって宣言された型パラメーターのスコープは、その*struct_body*の*struct_interfaces*、 *type_parameter_constraints_clause*s、および*struct_declaration*です。
*  *Interface_declaration* ([インターフェイス宣言](interfaces.md#interface-declarations)) の*type_parameter_list*によって宣言された型パラメーターのスコープは、その*interface_body*の*interface_base*、 *type_parameter_constraints_clause*s、および*interface_declaration*です。
*  *Delegate_declaration* ([デリゲート宣言](delegates.md#delegate-declarations)) の*type_parameter_list*によって宣言された型パラメーターのスコープは、その*type_parameter_constraints_clause*の*return_type*、 *formal_parameter_list*、および*delegate_declaration*です。
*  *Class_member_declaration* ([クラス本体](classes.md#class-body)) によって宣言されるメンバーのスコープは、宣言が行われる*class_body*です。 さらに、クラスメンバーのスコープは、メンバーのアクセシビリティドメイン ([アクセシビリティ](basic-concepts.md#accessibility-domains)ドメイン) に含まれている派生クラスの*class_body*まで拡張されます。
*  *Struct_member_declaration* ([構造体メンバー](structs.md#struct-members)) によって宣言されるメンバーのスコープは、宣言が行われる*struct_body*です。
*  *Enum_member_declaration* ([列挙型メンバー](enums.md#enum-members)) によって宣言されたメンバーのスコープは、宣言が行われる*enum_body*です。
*  *Method_declaration* ([メソッド](classes.md#methods)) で宣言されたパラメーターのスコープは、その*method_declaration*の*method_body*です。
*  *Indexer_declaration* ([インデクサー](classes.md#indexers)) で宣言されたパラメーターのスコープは、その*indexer_declaration*の*accessor_declarations*です。
*  *Operator_declaration* ([Operators](classes.md#operators)) で宣言されたパラメーターのスコープは、その*operator_declaration*の*ブロック*です。
*  *Constructor_declaration* ([インスタンスコンストラクター](classes.md#instance-constructors)) で宣言されたパラメーターのスコープは、その*constructor_declaration*の*constructor_initializer*および*ブロック*です。
*  *Lambda_expression* ([匿名関数式](expressions.md#anonymous-function-expressions)) で宣言されたパラメーターのスコープは、その*anonymous_function_body*です*lambda_expression*
*  *Anonymous_method_expression* ([匿名関数式](expressions.md#anonymous-function-expressions)) で宣言されたパラメーターのスコープは、その*anonymous_method_expression*の*ブロック*です。
*  *Labeled_statement* ([ラベル付きステートメント](statements.md#labeled-statements)) で宣言されたラベルのスコープは、宣言が発生する*ブロック*です。
*  *Local_variable_declaration* ([ローカル変数宣言](statements.md#local-variable-declarations)) で宣言されたローカル変数のスコープは、宣言が発生するブロックです。
*  `switch` ステートメント ([switch ステートメント](statements.md#the-switch-statement)) の*switch_block*で宣言されたローカル変数のスコープは*switch_block*です。
*  `for` ステートメント ([for ステートメント](statements.md#the-for-statement)) の*for_initializer*で宣言されたローカル変数のスコープは、 *for_initializer*、 *for_condition*、 *for_iterator*、および `for` ステートメントの含まれている*ステートメント*です。
*  *Local_constant_declaration* ([ローカル定数宣言](statements.md#local-constant-declarations)) で宣言されたローカル定数のスコープは、宣言が発生するブロックです。 *Constant_declarator*の前にあるテキストの位置でローカル定数を参照するコンパイル時エラーです。
*  *Foreach_statement*、 *using_statement*、 *lock_statement*または*query_expression*の一部として宣言された変数のスコープは、指定されたコンストラクトの展開によって決まります。

名前空間、クラス、構造体、または列挙型のメンバーのスコープ内では、メンバーの宣言の前にあるテキスト位置でメンバーを参照することができます。 次に例を示します。
```csharp
class A
{
    void F() {
        i = 1;
    }

    int i = 0;
}
```
ここでは、`F` が宣言される前に `i` を参照することが有効です。

ローカル変数のスコープ内では、ローカル変数の*local_variable_declarator*の前にあるテキスト位置でローカル変数を参照するコンパイル時エラーになります。 次に例を示します。
```csharp
class A
{
    int i = 0;

    void F() {
        i = 1;                  // Error, use precedes declaration
        int i;
        i = 2;
    }

    void G() {
        int j = (j = 1);        // Valid
    }

    void H() {
        int a = 1, b = ++a;    // Valid
    }
}
```

上記の `F` メソッドでは、`i` への最初の代入は、外側のスコープで宣言されたフィールドを参照しません。 代わりに、ローカル変数を参照するので、コンパイル時エラーが発生します。これは、変数の宣言の前にあるためです。 `G` メソッドでは、`j` の宣言の初期化子で `j` を使用することは、 *local_variable_declarator*の前に使用されていないため、有効です。 `H` メソッドでは、後続の*local_variable_declarator*は、同じ*local_variable_declaration*内の以前の*local_variable_declarator*で宣言されたローカル変数を正しく参照します。

ローカル変数のスコープ規則は、式のコンテキストで使用される名前の意味が常にブロック内で同じであることを保証するように設計されています。 ローカル変数のスコープがその宣言からブロックの末尾まで拡張される場合、上記の例では、最初の代入がインスタンス変数に割り当てられ、2番目の代入がローカル変数に代入されますが、これはおそらく次のようになります。ブロックのステートメントが後で再配置された場合、コンパイル時エラーが発生します。

ブロック内の名前の意味は、名前が使用されているコンテキストによって異なる場合があります。 この例では、
```csharp
using System;

class A {}

class Test
{
    static void Main() {
        string A = "hello, world";
        string s = A;                            // expression context

        Type t = typeof(A);                      // type context

        Console.WriteLine(s);                    // writes "hello, world"
        Console.WriteLine(t);                    // writes "A"
    }
}
```
`A` 名前は、クラス `A`を参照するために、式のコンテキストで使用され、ローカル変数 `A` と型コンテキストで参照されます。

### <a name="name-hiding"></a>名前の非表示

エンティティのスコープには、通常、エンティティの宣言空間よりも多くのプログラムテキストが含まれます。 特に、エンティティのスコープには、同じ名前のエンティティを含む新しい宣言スペースを導入する宣言を含めることができます。 このような宣言を行うと、元のエンティティが***非表示***になります。 逆に、エンティティは非表示になっている場合は***表示***されると言います。

名前の非表示は、スコープが入れ子になっている場合と、スコープが継承によって重複している場合に発生します。 2種類の非表示の特性については、次のセクションで説明します。

#### <a name="hiding-through-nesting"></a>非表示 (入れ子による)

入れ子による名前の隠ぺいは、名前空間内に名前空間または型を入れ子にした結果として発生することがあります。これは、クラスまたは構造体で型を入れ子にした結果として、パラメーターとローカル変数の宣言の結果として発生します。

この例では、
```csharp
class A
{
    int i = 0;

    void F() {
        int i = 1;
    }

    void G() {
        i = 1;
    }
}
```
`F` メソッドでは、インスタンス変数 `i` はローカル変数 `i`によって非表示にされますが、`G` メソッド内では、`i` は引き続きインスタンス変数を参照します。

内部スコープ内の名前が外側のスコープ内の名前を非表示にすると、その名前のすべてのオーバーロードされた出現が非表示になります。 この例では、
```csharp
class Outer
{
    static void F(int i) {}

    static void F(string s) {}

    class Inner
    {
        void G() {
            F(1);              // Invokes Outer.Inner.F
            F("Hello");        // Error
        }

        static void F(long l) {}
    }
}
```
呼び出し `F(1)` は `Inner` で宣言された `F` を呼び出します。これは、`F` のすべての外部オカレンスが内部宣言によって非表示になるためです。 同じ理由から、`F("Hello")` を呼び出すと、コンパイル時エラーが発生します。

#### <a name="hiding-through-inheritance"></a>隠ぺい (継承による)

継承による名前の隠ぺいは、クラスまたは構造体が基底クラスから継承された名前を再宣言するときに発生します。 この種類の名前の隠ぺいは、次のいずれかの形式になります。

*  クラスまたは構造体で導入された定数、フィールド、プロパティ、イベント、または型は、同じ名前を持つすべての基底クラスメンバーを非表示にします。
*  クラスまたは構造体で導入されたメソッドは、同じ名前を持つすべての非メソッド基底クラスメンバーと、同じシグネチャ (メソッド名とパラメーター数、修飾子、型) を持つすべての基底クラスメソッドを非表示にします。
*  クラスまたは構造体で導入されたインデクサーは、同じシグネチャ (パラメーター数および型) を持つすべての基底クラスインデクサーを非表示にします。

演算子宣言 ([演算子](classes.md#operators)) を制御する規則により、派生クラスは、基底クラスで演算子と同じシグネチャを持つ演算子を宣言できなくなります。 したがって、演算子は相互に隠ぺいすることはありません。

外側のスコープから名前を非表示にする場合とは対照的に、継承されたスコープからアクセス可能な名前を非表示にすると、警告が報告されます。 この例では、
```csharp
class Base
{
    public void F() {}
}

class Derived: Base
{
    public void F() {}        // Warning, hiding an inherited name
}
```
`Derived` の `F` を宣言すると、警告が報告されます。 継承された名前を非表示にすることは、特にエラーではありません。これは、基本クラスの個別の進化を防ぐためです。 たとえば、より新しいバージョンの `Base` では、以前のバージョンのクラスには存在しない `F` メソッドが導入されたため、上記の状況が発生する可能性があります。 上記の状況でエラーが発生した場合、個別にバージョン管理されたクラスライブラリの基底クラスに変更が加えられると、派生クラスが無効になる可能性があります。

継承された名前を非表示にすることによって発生する警告は、`new` 修飾子を使用することによって削除できます。
```csharp
class Base
{
    public void F() {}
}

class Derived: Base
{
    new public void F() {}
}
```

`new` 修飾子は `Derived` 内の `F` が "new" であり、継承されたメンバーを非表示にすることを意図していることを示します。

新しいメンバーの宣言は、継承されたメンバーを新しいメンバーのスコープ内でのみ非表示にします。

```csharp
class Base
{
    public static void F() {}
}

class Derived: Base
{
    new private static void F() {}    // Hides Base.F in Derived only
}

class MoreDerived: Derived
{
    static void G() { F(); }          // Invokes Base.F
}
```

上の例では、`Derived` 内の `F` の宣言によって `Base`から継承された `F` が非表示になりますが、`F` の新しい `Derived` にはプライベートアクセスがあるため、そのスコープは `MoreDerived`には拡張されません。 したがって、`MoreDerived.G` 内の `F()` 呼び出しは有効で、`Base.F`を呼び出します。

## <a name="namespace-and-type-names"></a>名前空間と型名

プログラム内のいくつかのコンテキストでは、 *namespace_name*または type_name を指定する必要があります。 C#

```antlr
namespace_name
    : namespace_or_type_name
    ;

type_name
    : namespace_or_type_name
    ;

namespace_or_type_name
    : identifier type_argument_list?
    | namespace_or_type_name '.' identifier type_argument_list?
    | qualified_alias_member
    ;
```

*Namespace_name*は、名前空間を参照する*namespace_or_type_name*です。 以下で説明するように、 *namespace_name*の*namespace_or_type_name*は名前空間を参照する必要があり、それ以外の場合はコンパイル時のエラーが発生します。 型[引数 (型引数)](types.md#type-arguments)を*namespace_name*に含めることはできません (型引数を持つことができるのは型だけです)。

*Type_name*は、型を参照する*namespace_or_type_name*です。 以下で説明するように、 *type_name*の*namespace_or_type_name*は型を参照する必要があり、それ以外の場合はコンパイル時のエラーが発生します。

*Namespace_or_type_name*が修飾エイリアスメンバーである場合は、「[名前空間エイリアス修飾子](namespaces.md#namespace-alias-qualifiers)」で説明されているように意味があります。 それ以外の場合、 *namespace_or_type_name*には次の4つの形式があります。

*  `I`
*  `I<A1, ..., Ak>`
*  `N.I`
*  `N.I<A1, ..., Ak>`

`I` が1つの識別子であり、`N` は*namespace_or_type_name*であり、`<A1, ..., Ak>` は省略可能な*type_argument_list*です。 *Type_argument_list*が指定されていない場合は、`k` を0にすることを検討してください。

*Namespace_or_type_name*の意味は、次のように決定されます。

*   *Namespace_or_type_name*の形式が `I` または `I<A1, ..., Ak>`の場合は、次のようになります。
    * `K` がゼロで、 *namespace_or_type_name*がジェネリックメソッド宣言 ([メソッド](classes.md#methods)) 内に存在し、その宣言に `I`という名前の型パラメーター ([型](classes.md#type-parameters)パラメーター) が含まれている場合、 *namespace_or_type_name*はその型パラメーターを参照します。
    * それ以外の場合、 *namespace_or_type_name*が型宣言内に出現する場合は、各インスタンス型 `T` ([インスタンス型](classes.md#the-instance-type)) に対して、その型宣言のインスタンス型から開始し、外側の各クラスまたは構造体宣言 (存在する場合) のインスタンス型を続行します。
        * `K` がゼロで、`T` の宣言に `I`という名前の型パラメーターが含まれている場合、 *namespace_or_type_name*はその型パラメーターを参照します。
        * それ以外の場合、 *namespace_or_type_name*が型宣言の本体に含まれていて、`T` またはその基本型のいずれかに、名前 `I` および `K`の型パラメーターを持つ入れ子になったアクセス可能な型が含まれている場合、 * * は、指定された型引数を使用して構築されたその型を参照します。 このような型が複数ある場合は、より多くの派生型で宣言された型が選択されます。 非型メンバー (定数、フィールド、メソッド、プロパティ、インデクサー、演算子、インスタンスコンストラクター、デストラクター、および静的コンストラクター) と、型パラメーターの数が異なる型メンバーは、 *namespace_or_type_name*の意味を判断する際に無視されることに注意してください。
    * 前の手順が正常に完了しなかった場合は、各名前空間 `N`、 *namespace_or_type_name*が発生する名前空間から開始し、外側の名前空間 (存在する場合) を続けて、グローバル名前空間で終わるまで、次の手順はエンティティが見つかるまで評価されます。
        * `K` がゼロで、`I` が `N`内の名前空間の名前である場合は、次のようになります。
            * *Namespace_or_type_name*が発生した場所が `N` の名前空間宣言によって囲まれていて、名前空間に名前空間または型が関連付けられている*extern_alias_directive*または*using_alias_directive*が名前空間宣言に含まれている場合、 * `I`* はあいまいで、コンパイル時エラーが発生します。
            * それ以外の場合、 *namespace_or_type_name*は `N`内の `I` という名前空間を参照します。
        * それ以外の場合、`N` に名前 `I` と `K` 型パラメーターを持つアクセス可能な型が含まれている場合は、次のようになります。
            * `K` がゼロで、 *namespace_or_type_name*が発生した場所が `N` の名前空間宣言によって囲まれており、名前空間を名前空間または型に関連付ける*extern_alias_directive*または*using_alias_directive*が名前空間宣言に含まれている場合、 * `I`* はあいまいで、コンパイル時エラーが発生します。
            * それ以外の場合、 *namespace_or_type_name*は、指定された型引数を使用して構築された型を参照します。
        * それ以外の場合、 *namespace_or_type_name*が発生した場所が `N`の名前空間宣言によって囲まれている場合は、次のようになります。
            * `K` がゼロで、名前空間の宣言に、名前 `I` をインポートした名前空間または型に関連付ける*extern_alias_directive*または*using_alias_directive*が含まれている場合、 *namespace_or_type_name*はその名前空間または型を参照します。
            * それ以外の場合、 *using_namespace_directive*s および名前空間宣言の*using_alias_directive*によってインポートされた名前空間と型の宣言に、name `I` および `K`の型パラメーターを持つアクセス可能な型が1つだけ含まれる場合、 * * は、指定された型引数を使用して構築されたその型を参照します。
            * それ以外の場合、 *using_namespace_directive*s および名前空間宣言の*using_alias_directive*によってインポートされた名前空間と型の宣言に、名前 `I` および `K`の型パラメーターを持つアクセス可能な型が複数含まれていると、 * * があいまいになり、エラーが発生します。
    * それ以外の場合、 *namespace_or_type_name*は定義されていないため、コンパイル時エラーが発生します。
*  それ以外の場合、 *namespace_or_type_name*はフォーム `N.I` または `N.I<A1, ..., Ak>`の形式になります。 `N` は、まず*namespace_or_type_name*として解決されます。 `N` の解決に失敗した場合は、コンパイル時エラーが発生します。 それ以外の場合、`N.I` または `N.I<A1, ..., Ak>` は次のように解決されます。
    * `K` がゼロで、`N` が名前空間を参照し、`N` が `I`名前の入れ子になった名前空間を含んでいる場合、 *namespace_or_type_name*はその入れ子になった名前空間を参照します。
    * それ以外の場合、`N` が名前空間を参照し、`N` 名前 `I` および `K`型パラメーターを持つアクセス可能な型が含まれている場合、 * * は、指定された型引数を使用して構築されたその型を参照します。
    * それ以外の場合、`N` が (構築された) クラスまたは構造体型を参照し、`N` またはその基本クラスに、名前 `I` および `K`型パラメーターを持つ入れ子になったアクセス可能な型が含まれている場合、 * * は、指定された型引数を使用して構築された型を参照します。 このような型が複数ある場合は、より多くの派生型で宣言された型が選択されます。 `N.I` の意味が `N` の基底クラスの指定の解決の一部として決定される場合、`N` の直接の基底クラスは object ([基底クラス](classes.md#base-classes)) と見なされます。
    * それ以外の場合、`N.I` は無効な*namespace_or_type_name*であり、コンパイル時エラーが発生します。

*Namespace_or_type_name*は、静的クラス ([静的クラス](classes.md#static-classes)) を参照することが許可されています。

*  *Namespace_or_type_name*は `T.I`フォームの*namespace_or_type_name*の `T` です。
*  *Namespace_or_type_name*は、`typeof(T)`フォームの*typeof_expression* ([引数リスト](expressions.md#argument-lists)1) の `T` です。

### <a name="fully-qualified-names"></a>完全修飾名

すべての名前空間と型には、すべての名前空間または型を一意に識別する***完全修飾名***があります。 名前空間または型 `N` の完全修飾名は、次のように決定されます。

*  `N` がグローバル名前空間のメンバーである場合、その完全修飾名は `N`になります。
*  それ以外の場合、その完全修飾名は `S.N`になります。 `S` は `N` が宣言されている名前空間または型の完全修飾名です。

つまり、`N` の完全修飾名は、グローバル名前空間から始まる、`N`につながる識別子の完全な階層パスです。 名前空間または型のすべてのメンバーは一意の名前を持つ必要があるため、名前空間または型の完全修飾名は常に一意であることに従います。

次の例では、いくつかの名前空間と型の宣言と、それに関連付けられた完全修飾名を示します。
```csharp
class A {}                // A

namespace X               // X
{
    class B               // X.B
    {
        class C {}        // X.B.C
    }

    namespace Y           // X.Y
    {
        class D {}        // X.Y.D
    }
}

namespace X.Y             // X.Y
{
    class E {}            // X.Y.E
}
```

## <a name="automatic-memory-management"></a>自動メモリ管理

C#自動メモリ管理を使用します。これにより、開発者は、オブジェクトによって占有されるメモリを手動で割り当てたり解放したりすることができます。 自動メモリ管理ポリシーは、***ガベージコレクター***によって実装されます。 オブジェクトのメモリ管理ライフサイクルは次のとおりです。

1. オブジェクトが作成されると、メモリが割り当てられ、コンストラクターが実行され、オブジェクトがライブと見なされます。
2. オブジェクト (またはその一部) が、デストラクターを実行するのではなく、実行の継続によってアクセスできない場合、オブジェクトは使用されなくなったと見なされ、破棄の対象になります。 C#コンパイラとガベージコレクターは、コードを分析して、オブジェクトへの参照を将来使用できるかどうかを判断することができます。 たとえば、スコープ内にあるローカル変数がオブジェクトへの既存の参照であるが、そのローカル変数が、プロシージャの現在の実行ポイントからの実行の継続で参照されていない場合、ガベージコレクターが発生する可能性があります (ただし、必須) オブジェクトは使用されなくなったものとして扱います。
3. オブジェクトが破棄されるようになると、指定されていない場合は、そのオブジェクトのデストラクター ([デストラクター](classes.md#destructors)) が実行されます。 通常の状況下では、オブジェクトのデストラクターが1回だけ実行されます。ただし、実装固有の Api では、この動作がオーバーライドされる可能性があります。
4. オブジェクトのデストラクターが実行されると、そのオブジェクト、またはその一部が、デストラクターの実行など、実行の継続によってアクセスできなくなると、オブジェクトはアクセス不可能と見なされ、オブジェクトがコレクションの対象になります。
5. 最後に、オブジェクトがコレクションの対象になると、そのオブジェクトに関連付けられているメモリがガベージコレクターによって解放されます。

ガベージコレクターは、オブジェクトの使用状況に関する情報を保持し、この情報を使用してメモリ管理の決定を行います。たとえば、新しく作成されたオブジェクトをメモリ内に配置する場所、オブジェクトを再配置するタイミング、オブジェクトが使用されていない場合やアクセスできない場合などです。

ガベージコレクターの存在を想定している他の言語C#と同様に、は、ガベージコレクターが幅広いメモリ管理ポリシーを実装できるように設計されています。 たとえば、でC#は、デストラクターを実行する必要はありません。また、オブジェクトが適格であるか、またはそのデストラクターが特定の順序または特定のスレッドで実行されることもありません。

ガベージコレクターの動作は、クラス `System.GC`の静的メソッドを使用して、ある程度制御できます。 このクラスを使用して、コレクションの発生を要求したり、デストラクターを実行 (または実行しない) したりすることができます。

ガベージコレクターでは、オブジェクトを収集してデストラクターを実行するタイミングを決定する際に、ワイド緯度が許可されるため、次のコードに示されているものとは異なる出力が、準拠する実装によって生成される場合があります。 プログラム
```csharp
using System;

class A
{
    ~A() {
        Console.WriteLine("Destruct instance of A");
    }
}

class B
{
    object Ref;

    public B(object o) {
        Ref = o;
    }

    ~B() {
        Console.WriteLine("Destruct instance of B");
    }
}

class Test
{
    static void Main() {
        B b = new B(new A());
        b = null;
        GC.Collect();
        GC.WaitForPendingFinalizers();
    }
}
```
クラス `A` のインスタンスと `B`クラスのインスタンスを作成します。 変数 `b` に値 `null`が割り当てられている場合、これらのオブジェクトはガベージコレクションの対象になります。この時間が経過すると、ユーザーが記述したコードにアクセスできなくなるためです。 出力は、

```console
Destruct instance of A
Destruct instance of B
```
、または
```console
Destruct instance of B
Destruct instance of A
```
この言語では、オブジェクトがガベージコレクションされる順序に制約はありません。

軽微なケースとして、"破棄の対象" と "コレクションの対象" の区別が重要になる場合があります。 次に例を示します。
```csharp
using System;

class A
{
    ~A() {
        Console.WriteLine("Destruct instance of A");
    }

    public void F() {
        Console.WriteLine("A.F");
        Test.RefA = this;
    }
}

class B
{
    public A Ref;

    ~B() {
        Console.WriteLine("Destruct instance of B");
        Ref.F();
    }
}

class Test
{
    public static A RefA;
    public static B RefB;

    static void Main() {
        RefB = new B();
        RefA = new A();
        RefB.Ref = RefA;
        RefB = null;
        RefA = null;

        // A and B now eligible for destruction
        GC.Collect();
        GC.WaitForPendingFinalizers();

        // B now eligible for collection, but A is not
        if (RefA != null)
            Console.WriteLine("RefA is not null");
    }
}
```

上記のプログラムでは、ガベージコレクターが `B`のデストラクターの前に `A` のデストラクターを実行するように選択した場合、このプログラムの出力は次のようになります。
```console
Destruct instance of A
Destruct instance of B
A.F
RefA is not null
```

`A` のインスタンスは使用されておらず、`A`のデストラクターが実行されていましたが、`A` (この場合は `F`) のメソッドが別のデストラクターから呼び出される可能性があることに注意してください。 また、デストラクターを実行すると、メインラインプログラムからオブジェクトが再び使用できるようになる可能性があることに注意してください。 この場合、`B`のデストラクターの実行により、以前に使用されていなかった `A` のインスタンスがライブ参照 `Test.RefA`からアクセスできるようになりました。 `WaitForPendingFinalizers`の呼び出しの後、`B` のインスタンスはコレクションの対象になりますが、`A` のインスタンスは、参照 `Test.RefA`によっては使用できません。

混乱や予期しない動作を避けるため、一般に、デストラクターは、オブジェクトの独自のフィールドに格納されているデータに対してのみクリーンアップを実行し、参照先のオブジェクトや静的フィールドに対してアクションを実行しないようにすることをお勧めします。

デストラクターを使用する代わりに、クラスが `System.IDisposable` インターフェイスを実装できるようにすることもできます。 これにより、オブジェクトのクライアントは、オブジェクトのリソースを解放するタイミングを決定できます。通常は、オブジェクトに `using` ステートメント ([using ステートメント](statements.md#the-using-statement)) のリソースとしてアクセスします。

## <a name="execution-order"></a>実行順序

C#プログラムの実行は、実行中の各スレッドの副作用が重要な実行ポイントで保持されるようになります。 ***副作用***は、volatile フィールドの読み取りまたは書き込み、不揮発性の変数への書き込み、外部リソースへの書き込み、および例外のスローとして定義されます。 これらの副作用の順序を保持する必要がある重要な実行ポイントは、volatile フィールド ([volatile フィールド](classes.md#volatile-fields))、`lock` ステートメント ([lock ステートメント](statements.md#the-lock-statement))、およびスレッドの作成と終了を参照することです。 実行環境では、 C#プログラムの実行順序を自由に変更できます。次の制約が適用されます。

*  データ依存は、実行スレッド内で保持されます。 つまり、各変数の値は、スレッド内のすべてのステートメントが元のプログラムの順序で実行されたかのように計算されます。
*  初期化の順序付け規則が保持されます ([フィールド初期化](classes.md#field-initialization)と[変数初期化子](classes.md#variable-initializers))。
*  副作用の順序は、揮発性の読み取りと書き込み ([volatile フィールド](classes.md#volatile-fields)) に関して保持されます。 さらに、式の値が使用されていないことを推測し、必要な副作用が生成されない場合 (メソッドの呼び出しや volatile フィールドへのアクセスによって発生する問題を含む)、実行環境は式の一部を評価する必要がありません。 非同期イベント (別のスレッドによってスローされた例外など) によってプログラムの実行が中断された場合、観測可能な副作用が元のプログラムの順序で表示される保証はありません。
