---
ms.openlocfilehash: 3df21c5816be90387a6cd9242e99ba11f43dfd1c
ms.sourcegitcommit: f61a06970fa0562d2e40363fae3948eb168624ca
ms.translationtype: MT
ms.contentlocale: ja-JP
ms.lasthandoff: 01/14/2020
ms.locfileid: "79484070"
---
# <a name="pattern-matching-for-c-7"></a>7のC#パターンマッチング

パターンマッチング拡張機能C#を使用すると、代数データ型と関数型言語のパターンマッチングの多くの利点が得られますが、基になる言語の感覚とスムーズに統合されます。 基本的な機能は、[レコード型](https://github.com/dotnet/csharplang/blob/master/proposals/records.md)です。これは、データの形によって記述される意味を持つ型です。また、パターンマッチングは、これらのデータ型を大幅に簡潔に分解できる新しい式の形式です。 このアプローチの要素は、プログラミング言語[F#](https://www.microsoft.com/en-us/research/wp-content/uploads/2016/02/p29-syme.pdf "軽量言語を使用した拡張可能なパターンマッチング")の関連機能と、[スケール a](https://infoscience.epfl.ch/record/98468/files/MatchingObjectsWithPatterns-TR.pdf "オブジェクトとパターンの一致")によって実現されています。

## <a name="is-expression"></a>Is 式

`is` 演算子は、*パターン*に対して式をテストするために拡張されています。

```antlr
relational_expression
    : relational_expression 'is' pattern
    ;
```

この形式の*relational_expression*は、 C#仕様に含まれる既存のフォームに追加されます。 `is` トークンの左側の*relational_expression*が値を指定していないか、型を持たない場合、コンパイル時エラーになります。

パターンのすべての*識別子*は、`is` 演算子が `true` た後に*確実に割り当てら*れる新しいローカル変数を導入します (つまり、 *true の場合は確実に割り当て*られます)。

> メモ: 厳密には、`is-expression` と*constant_pattern*の*型*の間にあいまいさがあります。どちらも、修飾された識別子の有効な解析である可能性があります。 以前のバージョンの言語との互換性のために、型としてバインドしようとしています。失敗した場合にのみ、他のコンテキストの場合と同様に、最初に見つかったもの (定数または型のいずれかである必要があります) に解決されます。 このあいまいさは、`is` 式の右辺にのみ存在します。

## <a name="patterns"></a>パターン

パターンは、`is` 演算子および*switch_statement*内で使用され、受信データの比較対象となるデータの構造を表します。 パターンは再帰的であるため、データの一部がサブパターンと照合される可能性があります。

```antlr
pattern
    : declaration_pattern
    | constant_pattern
    | var_pattern
    ;

declaration_pattern
    : type simple_designation
    ;

constant_pattern
    : shift_expression
    ;

var_pattern
    : 'var' simple_designation
    ;
```

> メモ: 厳密には、`is-expression` と*constant_pattern*の*型*の間にあいまいさがあります。どちらも、修飾された識別子の有効な解析である可能性があります。 以前のバージョンの言語との互換性のために、型としてバインドしようとしています。失敗した場合にのみ、他のコンテキストの場合と同様に、最初に見つかったもの (定数または型のいずれかである必要があります) に解決されます。 このあいまいさは、`is` 式の右辺にのみ存在します。

### <a name="declaration-pattern"></a>宣言パターン

*Declaration_pattern*は、式が特定の型であるかどうかをテストし、テストが成功した場合はその型にキャストします。 *Simple_designation*が識別子の場合は、指定された識別子によって指定された型のローカル変数を導入します。 このローカル変数は、パターン一致操作の結果が true の場合に*確実に割り当てら*れます。

```antlr
declaration_pattern
    : type simple_designation
    ;
```

この式のランタイムセマンティックは、パターンの*型*に対して左辺の*relational_expression*オペランドのランタイム型をテストすることです。 そのランタイム型 (または一部のサブタイプ) の場合、`is operator` の結果は `true`ます。 これは、結果が `true`ときに左側のオペランドの値が割り当てられた*識別子*によって指定された新しいローカル変数を宣言します。

左側の静的な型と指定された型の特定の組み合わせは互換性がないと見なされ、コンパイル時エラーが発生します。 静的な型 `E` の値は、id 変換、暗黙の参照変換、ボックス化変換、明示的な参照変換、または `E` から `T`へのアンボックス変換が存在する場合に、型 `T` との*パターン互換性*があると言われます。 `E` 型の式が、照合される型パターンの型と互換性のあるパターンでない場合、コンパイル時エラーになります。

> 注: [7.1 C#で](../csharp-7.1/generics-pattern-match.md)は、入力型または型 `T` がオープン型である場合に、パターンマッチング操作を許可するようにこれを拡張します。 この段落は、次のように置き換えられます。
> 
> 左側の静的な型と指定された型の特定の組み合わせは互換性がないと見なされ、コンパイル時エラーが発生します。 静的な型 `E` の値は、id 変換、暗黙の参照変換、ボックス変換、明示的な参照変換、または `E` から `T`へのアンボックス変換、または **`E` または `T` のいずれかがオープン型**である場合に、型 `T` との*パターン互換性*があると言われます。 `E` 型の式が、照合される型パターンの型と互換性のあるパターンでない場合、コンパイル時エラーになります。

宣言パターンは、参照型のランタイム型テストを実行する場合に便利です。

```csharp
var v = expr as Type;
if (v != null) { // code using v }
```

少し簡潔に

```csharp
if (expr is Type v) { // code using v }
```

*型*が null 許容値型の場合、エラーになります。

宣言パターンは、null 許容型の値をテストするために使用できます。値が null 以外で、`T2` の型が `T`である場合、または `T`の基本型またはインターフェイスである場合は、型 `Nullable<T>` (またはボックス化された `T`) の値が型 `T2 id` パターンと一致します。 たとえば、コード片で

```csharp
int? x = 3;
if (x is int v) { // code using v }
```

`if` ステートメントの条件は実行時に `true` され `v` 変数は、ブロック内の `int` 型の値 `3` を保持します。

### <a name="constant-pattern"></a>定数パターン

```antlr
constant_pattern
    : shift_expression
    ;
```

定数パターンは、定数値に対して式の値をテストします。 定数には、リテラル、宣言された `const` 変数の名前、列挙定数、`typeof` 式など、任意の定数式を指定できます。

*E*と*c*の両方が整数型の場合、`e == c` 式の結果が `true`場合は、パターンが一致したと見なされます。

それ以外の場合、`object.Equals(e, c)` が `true`を返す場合、パターンは一致と見なされます。 この場合、 *e*の静的な型が定数の型と互換性のある*パターン*でない場合、コンパイル時エラーになります。

### <a name="var-pattern"></a>Var パターン

```antlr
var_pattern
    : 'var' simple_designation
    ;
```

式*e*は常に*var_pattern*と一致します。 言い換えると、 *var パターン*との一致は常に成功します。 *Simple_designation*が識別子の場合は、実行時に*e*の値が新しく導入されたローカル変数にバインドされます。 ローカル変数の型は、 *e*の静的な型です。

名前 `var` 型にバインドされている場合、エラーになります。

## <a name="switch-statement"></a>Switch ステートメント

`switch` ステートメントは、 *switch 式*と一致するパターンが関連付けられた最初のブロックを実行するために選択するように拡張されています。

```antlr
switch_label
    : 'case' complex_pattern case_guard? ':'
    | 'case' constant_expression case_guard? ':'
    | 'default' ':'
    ;

case_guard
    : 'when' expression
    ;
```

パターンが一致する順序は定義されていません。 コンパイラは、パターンを順序どおりに一致させ、既に一致したパターンの結果を再利用して、他のパターンとの照合結果を計算することができます。

*ケースガード*が存在する場合、その式は `bool`型になります。 これは、満たされた場合に満たす必要がある追加の条件として評価されます。

*Switch_label*が実行時に影響を与えない場合、これはエラーになります。これは、そのパターンが前のケースで包括されているためです。 [TODO: この判断に至るためにコンパイラが使用する必要がある手法について、より正確に指定する必要があります。]

*Switch_label*で宣言されたパターン変数は、その case ブロックに1つの*switch_label*が含まれている場合にのみ、その case ブロックで確実に割り当てられます。

[TODO:*スイッチブロック*に到達できる場合は、を指定する必要があります。]

### <a name="scope-of-pattern-variables"></a>パターン変数のスコープ

パターンで宣言された変数のスコープは次のとおりです。

- パターンが case ラベルの場合、変数のスコープは*case ブロック*になります。

それ以外の場合、変数は*is_pattern*式で宣言され、そのスコープは、次のように*is_pattern*式を含む式をすぐに囲むコンストラクトに基づいています。

- 式が式形式のラムダ内にある場合、そのスコープはラムダの本体です。
- 式が式形式のメソッドまたはプロパティに含まれている場合、そのスコープはメソッドまたはプロパティの本体です。
- 式が `catch` 句の `when` 句に含まれている場合、そのスコープは `catch` 句になります。
- 式が*iteration_statement*内にある場合、そのスコープはそのステートメントにすぎません。
- それ以外の場合、式が他のステートメント形式に含まれていると、そのスコープがステートメントを含むスコープになります。

スコープを決定するために、 *embedded_statement*は独自のスコープ内にあると見なされます。 たとえば、 *if_statement*の文法は次のようになります。

``` antlr
if_statement
    : 'if' '(' boolean_expression ')' embedded_statement
    | 'if' '(' boolean_expression ')' embedded_statement 'else' embedded_statement
    ;
```

したがって、 *if_statement*の制御されたステートメントがパターン変数を宣言している場合、そのスコープはその*embedded_statement*に制限されます。

```csharp
if (x) M(y is var z);
```

この場合、`z` のスコープは、埋め込みステートメント `M(y is var z);`です。

その他の理由 (たとえば、パラメーターの既定値や属性など) でエラーが発生した場合は、これらのコンテキストには定数式が必要であるため、どちらもエラーになります。

> [7.3 C#では、](../csharp-7.3/expression-variables-in-initializers.md) pattern 変数が宣言される次のコンテキストを追加しました。
> - 式が*コンストラクター初期化子*内にある場合、そのスコープは*コンストラクター初期化子*とコンストラクターの本体になります。
> - 式がフィールド初期化子に含まれている場合、そのスコープは、その式が表示される*equals_value_clause*になります。
> - ラムダの本体に変換するように指定されているクエリ句に式が含まれている場合、その式のスコープはその式にすぎません。

## <a name="changes-to-syntactic-disambiguation"></a>構文のあいまいさを解消するための変更

ジェネリックにはC#文法があいまいであり、言語仕様によってあいまいさを解決する方法が示されています。

> #### <a name="7652-grammar-ambiguities"></a>7.6.5.2 文法のあいまい性
> *単純名*(7.6.3) と*メンバーアクセス*(7.6.5 を参照) の生産によって、式の文法があいまいになる可能性があります。 たとえば、ステートメントは次のようになります。
> ```csharp
> F(G<A,B>(7));
> ```
> は、`G < A` と `B > (7)`の2つの引数を持つ `F` の呼び出しとして解釈される可能性があります。 または、1つの引数を持つ `F` の呼び出しとして解釈することもできます。これは、2つの型引数と1つの標準引数を持つジェネリックメソッド `G` の呼び出しです。

> トークンのシーケンスを*単純な名前*(7.6.3)、*メンバーアクセス*(§ 7.6.5)、または*ポインターメンバーアクセス*(18.5.2 を参照) として解析できる場合は、終わりの `>` トークンの直後にあるトークンが調べられます (「4.4.1)」と*入力*します。 のいずれかである場合
> ```none
> (  )  ]  }  :  ;  ,  .  ?  ==  !=  |  ^
> ```
> その後、*型引数リスト*は、*単純名*、*メンバーアクセス*、または*ポインターメンバーアクセス*の一部として保持され、トークンのシーケンスのその他の可能な解析はすべて破棄されます。 それ以外の場合、トークンのシーケンスを解析できない場合でも、*型引数リスト*は、*単純名*、*メンバーアクセス*、または >*ポインターメンバーアクセス*の一部とは見なされません。 *名前空間または型名*で*型引数リスト*を解析する場合、これらの規則は適用されないことに注意してください (3.8 を参照)。 次のステートメント、
> ```csharp
> F(G<A,B>(7));
> ```
> は、この規則に従って、1つの引数を持つ `F` の呼び出しとして解釈されます。これは、2つの型引数と1つの標準引数を持つジェネリックメソッド `G` の呼び出しです。 ステートメント
> ```csharp
> F(G < A, B > 7);
> F(G < A, B >> 7);
> ```
> は、2つの引数を持つ `F` の呼び出しとして解釈されます。 次のステートメント、
> ```csharp
> x = F < A > +y;
> ```
> は、ステートメントが `x = (F < A) > (+y)`記述されているかのように、小なり演算子、大なり演算子、および単項プラス演算子として解釈されます。これは、*型引数リスト*の後に二項プラス演算子が続く*単純な名前*ではありません。 ステートメント内
> ```csharp
> x = y is C<T> + z;
> ```
> `C<T>` トークンは、*型引数リスト*を持つ*名前空間または型名*として解釈されます。

7では、このようなあいまいさC#を解消するために、言語の複雑さを処理するのに十分ではないいくつかの変更が導入されています。

### <a name="out-variable-declarations"></a>out 変数宣言

Out 引数で変数を宣言できるようになりました。

```csharp
M(out Type name);
```

ただし、型はジェネリックである場合があります。 

```csharp
M(out A<B> name);
```

引数の言語文法では*式*が使用されるため、このコンテキストにはあいまいさの排除規則が適用されます。 この場合、終了 `>` の後に識別子が続きます。この*識別子*は、*型引数リスト*として扱うことを許可するトークンの1つではありません。 そのため、あいまいさを解消する**トークンのセットに*識別子*を追加すること*type-argument-list*** を提案します。

### <a name="tuples-and-deconstruction-declarations"></a>タプルと分解宣言

組リテラルは、まったく同じ問題に実行されます。 タプル式を考えます。

```csharp
(A < B, C > D, E < F, G > H)
```

前C#の6つの規則で引数リストを解析する場合、これは、最初の要素として `A < B` から始まる4つの要素を持つタプルとして解析されます。 ただし、分解の左側にこれが表示される場合は、前述のように、*識別子*トークンによってトリガーされるあいまいさを解消する必要があります。

```csharp
(A<B,C> D, E<F,G> H) = e;
```

これは、2つの変数を宣言する分解宣言です。最初の変数は `A<B,C>` 型で、名前付き `D`です。 言い換えると、組リテラルには2つの式が含まれ、それぞれが宣言式です。

仕様とコンパイラを簡単にするために、このタプルリテラルを (代入式の左側に表示するかどうかにかかわらず) 任意の場所に2要素のタプルとして解析することを提案します。 これは、前のセクションで説明した非不明瞭の自然な結果になります。

### <a name="pattern-matching"></a>パターンマッチング

パターンマッチングでは、式型のあいまいさが発生する新しいコンテキストが導入されます。 以前は、`is` 演算子の右辺は型でした。 これで、型または式にすることができます。型である場合は、識別子の後に指定できます。 これにより、技術的には既存のコードの意味を変更できます。

```csharp
var x = e is T < A > B;
```

これは、次のように C# 6 規則で解析できます。

```csharp
var x = ((e is T) < A) > B;
```

ただし、C# 7 の規則 (上記のあいまいさを排除したもの) は、として解析されます。

```csharp
var x = e is T<A> B;
```

`T<A>`型の変数 `B` を宣言します。 さいわい、ネイティブコンパイラと Roslyn コンパイラには、C# 6 コードに構文エラーが発生するというバグがあります。 そのため、このような重大な変更は考慮されません。

パターンマッチングでは、型の選択に向けたあいまいさの解決を推進する必要がある追加のトークンが導入されます。 次の例では、既存の有効な C# 6 コードは、その他のあいまいさを排除する規則なしに分割されます。

```csharp
var x = e is A<B> && f;            // &&
var x = e is A<B> || f;            // ||
var x = e is A<B> & f;             // &
var x = e is A<B>[];               // [
```

### <a name="proposed-change-to-the-disambiguation-rule"></a>排除規則に対する変更の提案

明確化トークンの一覧を変更するように仕様を修正することを提案します。

>
```none
(  )  ]  }  :  ;  ,  .  ?  ==  !=  |  ^
```

から

>
```none
(  )  ]  }  :  ;  ,  .  ?  ==  !=  |  ^  &&  ||  &  [
```

また、特定のコンテキストでは、*識別子*を明確化トークンとして扱います。 これらのコンテキストは、明確、`case`、`out`のいずれかの `is`キーワードが直後にあるか、またはタプルリテラルの最初の要素を解析するときに発生します (この場合、トークンの前には `(` または `:`、識別子の後に `,`)、またはタプルリテラルの後続の要素が含まれます。

### <a name="modified-disambiguation-rule"></a>変更されたあいまいさの排除ルール

修正されていないあいまいさの規則は次のようになります。

> トークンのシーケンスを*単純な名前*(7.6.3 を参照)、*メンバーアクセス*(§ 7.6.5)、または*ポインターメンバーアクセス*(参照 18.5.2) で終わる*場合 (4.4.1*を参照)、終了 `>` トークンの直後にあるトークンが検査され、次のように表示されます。
> - `(  )  ]  }  :  ;  ,  .  ?  ==  !=  |  ^  &&  ||  &  [`のいずれかです。もしくは
> - 関係演算子の1つ `<  >  <=  >=  is as`;もしくは
> - クエリ式の内部に表示されるコンテキストクエリキーワードもしくは
> - 特定のコンテキストでは、*識別子*を明確化トークンとして扱います。 これらのコンテキストは、明確、`case` または `out`のいずれかの `is`キーワードが直後にあるか、またはタプルリテラルの最初の要素を解析するときに発生します (この場合、トークンの前に `(` または `:`、識別子の後に `,`) またはタプルリテラルの後続の要素が含まれます。
> 
> 次のトークンがこのリストまたはこのようなコンテキストの識別子の中にある場合、*型引数リスト*は*単純名*、*メンバーアクセス*、または*ポインターメンバーアクセス*の一部として保持され、その他のトークンシーケンスの解析はすべて破棄されます。  それ以外の場合、トークンのシーケンスを解析できない場合でも、*型引数リスト*は、*単純名*、*メンバーアクセス*、または*ポインターメンバーアクセス*の一部とは見なされません。 *名前空間または型名*で*型引数リスト*を解析する場合、これらの規則は適用されないことに注意してください (3.8 を参照)。

### <a name="breaking-changes-due-to-this-proposal"></a>この提案による重大な変更

この修正候補の規則により、互換性に影響する変更は認識されません。

### <a name="interesting-examples"></a>興味深い例

これらの非不明瞭な規則の興味深い結果を次に示します。

`(A < B, C > D)` 式は2つの要素を持つ組で、それぞれが比較されます。

`(A<B,C> D, E)` 式は2つの要素を持つタプルで、最初の要素は宣言式です。

呼び出し `M(A < B, C > D, E)` には3つの引数があります。

呼び出し `M(out A<B,C> D, E)` には2つの引数があり、最初の引数は `out` 宣言です。

式 `e is A<B> C` は宣言式を使用します。

Case ラベル `case A<B> C:` は宣言式を使用します。

## <a name="some-examples-of-pattern-matching"></a>パターンマッチングの例

### <a name="is-as"></a>は

表現を置き換えることができます。

```csharp
var v = expr as Type;   
if (v != null) {
    // code using v
}
```

少し簡潔で、直接

```csharp
if (expr is Type v) {
    // code using v
}
```

### <a name="testing-nullable"></a>テスト (null 許容)

表現を置き換えることができます。

```csharp
Type? v = x?.y?.z;
if (v.HasValue) {
    var value = v.GetValueOrDefault();
    // code using value
}
```

少し簡潔で、直接

```csharp
if (x?.y?.z is Type value) {
    // code using value
}
```

### <a name="arithmetic-simplification"></a>算術単純化

(別の提案に従って) 式を表す一連の再帰型を定義するとします。

```csharp
abstract class Expr;
class X() : Expr;
class Const(double Value) : Expr;
class Add(Expr Left, Expr Right) : Expr;
class Mult(Expr Left, Expr Right) : Expr;
class Neg(Expr Value) : Expr;
```

これで、式の (縮小されていない) 派生を計算する関数を定義できます。

```csharp
Expr Deriv(Expr e)
{
  switch (e) {
    case X(): return Const(1);
    case Const(*): return Const(0);
    case Add(var Left, var Right):
      return Add(Deriv(Left), Deriv(Right));
    case Mult(var Left, var Right):
      return Add(Mult(Deriv(Left), Right), Mult(Left, Deriv(Right)));
    case Neg(var Value):
      return Neg(Deriv(Value));
  }
}
```

位置指定パターンを示す式 simplifier を次に示します。

```csharp
Expr Simplify(Expr e)
{
  switch (e) {
    case Mult(Const(0), *): return Const(0);
    case Mult(*, Const(0)): return Const(0);
    case Mult(Const(1), var x): return Simplify(x);
    case Mult(var x, Const(1)): return Simplify(x);
    case Mult(Const(var l), Const(var r)): return Const(l*r);
    case Add(Const(0), var x): return Simplify(x);
    case Add(var x, Const(0)): return Simplify(x);
    case Add(Const(var l), Const(var r)): return Const(l+r);
    case Neg(Const(var k)): return Const(-k);
    default: return e;
  }
}
```
