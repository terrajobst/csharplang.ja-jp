---
ms.openlocfilehash: ecdad8c863d0695bc901e4d96d9ca3decbc248eb
ms.sourcegitcommit: 94a3d151c438d34ede1d99de9eb4ebdc07ba4699
ms.translationtype: MT
ms.contentlocale: ja-JP
ms.lasthandoff: 04/25/2019
ms.locfileid: "79483596"
---
# <a name="nullable-reference-types-in-c"></a>での null 値が許容される参照型C# #

この機能の目的は次のとおりです。

* 変数、パラメーター、または参照型の結果が null であるかどうかを開発者が表すことができるようにします。
* このような変数、パラメーター、および結果がその目的に従って使用されない場合は、警告を表示します。

## <a name="expression-of-intent"></a>インテントの式

この言語には、値型の `T?` 構文が既に含まれています。 参照型にこの構文を拡張するのは簡単です。

非修飾参照型 `T` の目的は、null 以外にする必要があることを前提としています。

## <a name="checking-of-nullable-references"></a>Null 許容参照のチェック

フロー分析は、null 許容の参照変数を追跡します。 分析では、null ではないと判断された場合 (たとえば、チェックや代入の後)、その値は null 以外の参照と見なされます。

また、null 許容参照は、後置 `x!` 演算子 ("dammit" 演算子) を使用して null 以外の値として明示的に処理することもできます。これは、フロー分析が、開発者が知っている null 以外の状況を確立できない場合に使用します。

それ以外の場合、null 許容参照が逆参照されるか、null 以外の型に変換されると、警告が示されます。

`S[]` から `T?[]`、`S?[]` から `T[]`に変換するときに警告が通知されます。

型パラメーターが共変 (`out`) である場合や、型パラメーターが反変 (`C<T>`) の場合を除き、`C<S?>` から`in`に変換する場合を除き、`C<S>` から `C<T?>` への変換時に警告が通知されます。

型パラメーターに null 以外の制約がある場合、`C<T?>` で警告が示されます。 

## <a name="checking-of-non-null-references"></a>Null 以外の参照のチェック

Null リテラルが null 以外の変数に割り当てられているか、null 以外のパラメーターとして渡された場合、警告が返されます。

コンストラクターが null 以外の参照フィールドを明示的に初期化しない場合も、警告が示されます。

Null 以外の参照の配列のすべての要素が初期化されていることを適切に追跡することはできません。 ただし、新しく作成された配列の要素が割り当てられる前に、配列の読み取りまたは書き込みが行われる前に、警告を発行することができます。 これは、ノイズが発生することなく、一般的なケースを処理する可能性があります。

`default(T)` が警告を生成するかどうか、または単に `T?`型として処理するかどうかを決定する必要があります。

## <a name="metadata-representation"></a>メタデータ表現

Null 値許容要素は、メタデータで属性として表す必要があります。 これは、ダウンレベルコンパイラによって無視されることを意味します。

Null 値を許容する注釈だけを含めるかどうかを判断する必要があります。または、アセンブリ内で null 以外が "on" であるかどうかを示すこともできます。

## <a name="generics"></a>ジェネリック

型パラメーター `T` に null 非許容の制約がある場合、そのスコープ内で null 非許容として扱われます。

型パラメーターに制約がない場合、または null 値を許容する制約がある場合、状況は少し複雑になります。これは、対応する型引数が null 許容または null 非許容の*どちらか*になる可能性があることを意味します。 そのような場合の安全な方法は、型パラメーターを null 許容型と null 非許容型の*両方*として扱い、いずれかの違反があったときに警告を発することです。 

明示的に null 許容の参照制約を許可するかどうかを検討してください。 ただし、null 値を許容する参照型を使用することは、特定のケース (継承された制約) の制約として*暗黙的*に避けることができないことに注意してください。

`class` 制約が null ではありません。 `class?` が "nullable reference type" を示す有効な null 許容制約であるかどうかを検討できます。

## <a name="type-inference"></a>型の推論

型推論では、貢献する型が null 許容の参照型である場合、結果の型は nullable である必要があります。 言い換えると、null 性伝達されます。

`null` リテラルを参加式として含めるかどうかを検討する必要があります。 現在のところ、値型の場合はエラーが発生しますが、参照型の場合は null がプレーン型に正常に変換されます。 

```csharp
string? n = "world";
var x = b ? "Hello" : n; // string?
var y = b ? "Hello" : null; // string? or error
var z = b ? 7 : null; // Error today, could be int?
```

## <a name="breaking-changes"></a>重大な変更

Null 以外の警告は、既存のコードでは明らかに互換性に影響する変更であり、オプトインメカニズムを使用する必要があります。

当然ながら、null 許容型からの警告 (前述のように) は、null 値の許容属性が暗黙的である特定のシナリオでは、既存のコードの互換性に影響する変更です。

* 制約のない型パラメーターは暗黙的に null 値が許容されるものとして扱われるので、`object` に割り当てたり、`ToString` にアクセスしたりすると、警告が生成されます。
* 型の推定によって `null` 式から null 値が推測される場合、既存のコードで null 非許容型ではなく null 許容型が生成され、新しい警告が発生する可能性があります。

Null 許容の警告も省略可能である必要があります。

最後に、既存の API に注釈を追加すると、警告が表示されたユーザーがライブラリをアップグレードしたときに重大な変更が発生します。 これは、オプトインまたはオプトアウトする機能にもメリットがあります。「バグを修正する必要がありますが、新しい注釈を処理する準備ができていません」

要約すると、以下をオプトインできる必要があります。
* Null 値を許容する警告
* Null 以外の警告
* 他のファイルの注釈からの警告

オプトインの粒度により、アナライザーに似たモデルが提案されます。ここでは、コードの膨大がプラグマと重大度レベルを選択し、ユーザーが選択できます。 さらに、ライブラリごとのオプション (「JSON.NET の注釈を無視する準備ができないようにする」) は、コード内で属性として表現される可能性があります。

オプトイン/移行エクスペリエンスの設計は、この機能の成功と有用性に不可欠です。 次のことを確認する必要があります。

* ユーザーは、必要に応じて、null 値を許容するかどうかを段階的に確認できます。
* ライブラリ作成者は、顧客の侵入を心配することなく、null 値を許容する注釈を追加できます。
* このような場合でも、"構成の悪夢" は意味がありません。

## <a name="tweaks"></a>改変

ローカルでは `?` 注釈を使用しないことを検討できますが、割り当てられている内容に従って使用されているかどうかを観察するだけです。 これを優先しません。私たちは、その意図を明確に表現する必要があると考えています。

パラメーターの短縮形 `T! x` を検討し、ランタイムの null チェックを自動生成します。

`FirstOrDefault` や `TryGet`など、ジェネリック型の特定のパターンでは、特定の状況で既定値が明示的に生成されるため、null 非許容型引数と若干奇妙な動作があります。 これらの改善に対応するために、型システムの機能を強化することができます。 たとえば、型引数が既に null 値を許容できる場合でも、制約のない型パラメーターに対して `?` を許可することができます。 これは価値があると思います。 null 許容*値*型との対話に関連する weirdness につながります。 

## <a name="nullable-value-types"></a>null 許容値型

Null 許容値型に対しても上記のセマンティクスの一部を採用することを検討できます。

型の推定については既に説明しました。ここでは、エラーを提供するだけでなく、`(7, null)`から `int?` を推測できます。

また、フロー分析を null 許容の値型に適用することもできます。 Null 以外と見なされる場合は、特定の方法 (メンバーアクセスなど) で null 非許容型としてを使用できるようにすることができます。 これは、戻り値の型に対して*既に*実行できるものが、バック互換性の理由で優先されることを気にする必要があるだけです。
