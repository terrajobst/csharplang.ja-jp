---
ms.openlocfilehash: 6cf489595654236c18edee94c0af380e605c9571
ms.sourcegitcommit: f61a06970fa0562d2e40363fae3948eb168624ca
ms.translationtype: MT
ms.contentlocale: ja-JP
ms.lasthandoff: 01/14/2020
ms.locfileid: "79484076"
---
# <a name="private-protected"></a>private protected

* [x] が提案されています
* [x] プロトタイプ:[完了](https://github.com/dotnet/roslyn/blob/master/docs/features/private-protected.md)
* [x] 実装:[完了](https://github.com/dotnet/roslyn/blob/master/docs/features/private-protected.md)
* [x] 仕様:[完了](#detailed-design)

## <a name="summary"></a>まとめ
[summary]: #summary

CLR `protectedAndInternal` アクセシビリティレベルを `private protected`C#として公開します。

## <a name="motivation"></a>目的
[motivation]: #motivation

API には、型を提供するアセンブリに含まれるサブクラスで実装および使用することのみを目的としたメンバーが含まれています。 CLR では、その目的のアクセシビリティレベルが提供されますが、 C#では使用できません。 その結果、API 所有者は `internal` 保護と自己統制またはカスタムアナライザーを使用するか、または `protected` を使用して、その型のパブリックドキュメントにメンバーが表示されるのに対し、パブリック API の一部としては使用しません。  後者の例については、「`Common`で始まる名前を持つ Roslyn の `CSharpCompilationOptions` のメンバー」を参照してください。

でC#このアクセスレベルのサポートを直接指定すると、このような状況を言語で自然に表現できるようになります。

## <a name="detailed-design"></a>詳細なデザイン
[design]: #detailed-design

### <a name="private-protected-access-modifier"></a>`private protected` アクセス修飾子

新しいアクセス修飾子の組み合わせ `private protected` を追加することを提案します (これは、修飾子の中で任意の順序で表示できます)。 これは、protectedAndInternal の CLR の概念にマップされ、 [ C++/cli](https://docs.microsoft.com/cpp/dotnet/how-to-define-and-consume-classes-and-structs-cpp-cli#BKMK_Member_visibility)で現在使用されているのと同じ構文をではします。

`private protected` として宣言されたメンバーは、そのサブクラスがメンバーと同じアセンブリ内にある場合に、そのコンテナーのサブクラス内でアクセスできます。

言語仕様は次のように変更されます (太字で追加)。 セクション番号は、統合されている仕様のバージョンによって異なる場合があるため、以下には記載されていません。

-----

> メンバーに対して宣言されたアクセシビリティは、次のいずれかになります。
- Public。メンバー宣言に public 修飾子を含めることによって選択されます。 パブリックの直感的な意味は、"アクセスが制限されない" ということです。
- Protected。メンバー宣言に protected 修飾子を含めることによって選択されます。 Protected の直感的な意味は、"コンテナークラスに対するアクセス制限" または "含んでいるクラスから派生した型" です。
- Internal。メンバー宣言に内部修飾子を含めることによって選択されます。 内部の直感的な意味は、"this assembly に限定されたアクセス" です。
- Protected internal。プロテクトと内部修飾子の両方をメンバー宣言に含めることによって選択されます。 Protected internal の直感的な意味は、"このアセンブリ内でアクセスできます。また、それを含んでいるクラスから派生した型" です。
- **Private protected。メンバー宣言に private 修飾子と protected 修飾子の両方を含めることによって選択されます。Private protected の直感的な意味は、"親クラスから派生した型によって、このアセンブリ内でアクセスできる" ということです。**

-----

> メンバー宣言が行われるコンテキストによっては、特定の種類のアクセシビリティのみが許可されます。 さらに、メンバー宣言にアクセス修飾子が含まれていない場合、宣言が実行されるコンテキストによって、既定で宣言されたアクセシビリティが決まります。 
- 名前空間は、暗黙的にパブリックに宣言されたアクセシビリティを持ちます。 名前空間宣言でアクセス修飾子を使用することはできません。
- コンパイル単位または名前空間で直接宣言された型 (他の型の内部ではない) は、パブリックまたは内部で宣言されたアクセシビリティを持つことができます。
- クラスメンバーは、5種類の宣言されたアクセシビリティを持つことができ、既定でプライベートに宣言されたアクセシビリティを持つことができます。 [注: クラスのメンバーとして宣言された型は、5種類のアクセシビリティを持つことができますが、名前空間のメンバーとして宣言された型は、パブリックまたは内部で宣言されたアクセシビリティのみを持つことができます。 メモを終了する
- 構造体メンバーは、public、internal、または private として宣言されたアクセシビリティを持つことができます。また、構造体は暗黙的にシールされるので、アクセシビリティは既定でプライベート 構造体で導入された構造体メンバー (その構造体によって継承されない) は、protected、protected internal **、または private protected** ~~で宣言~~されたアクセシビリティ*を*持つことはできません。 [注: 構造体のメンバーとして宣言された型では、public、internal、または private として宣言されたアクセシビリティを持つことができますが、名前空間のメンバーとして宣言された型は、パブリックまたは内部で宣言されたアクセシビリティのみを持つことができます。 メモを終了する
- インターフェイスメンバーは、暗黙的にパブリックに宣言されたアクセシビリティを持ちます。 インターフェイスメンバー宣言でアクセス修飾子を使用することはできません。
- 列挙型のメンバーは、暗黙的にパブリックに宣言されたアクセシビリティを持ちます。 列挙メンバー宣言でアクセス修飾子を使用することはできません。

-----

> プログラム P 内の T 型で宣言された入れ子になったメンバー M のアクセシビリティドメインは、次のように定義されます (M 自体は型である可能性があります)。
- 宣言された M のアクセシビリティがパブリックの場合、M のアクセシビリティドメインは T のアクセシビリティドメインになります。
- 宣言された M のアクセシビリティが内部で保護されている場合、D は、p のプログラムテキストと、P 以外で宣言されている T から派生した任意の型のプログラムテキストの和集合として使用します。M のアクセシビリティドメインは、T のアクセシビリティドメインと D の積集合です。
- **宣言された M のアクセシビリティがプライベートで保護されている場合、D は、P のプログラムテキストと、T から派生した任意の型のプログラムテキストとの積集合として使用します。M のアクセシビリティドメインは、T のアクセシビリティドメインと D の積集合です。**
- 宣言された M のアクセシビリティが保護されている場合、D は T のプログラムテキストと、T から派生した任意の型のプログラムテキストの和集合になります。M のアクセシビリティドメインは、T のアクセシビリティドメインと D の積集合です。
- 宣言された M のアクセシビリティが内部の場合、M のアクセシビリティドメインは、T のアクセシビリティドメインと、P のプログラムテキストとの積集合になります。
- 宣言された M のアクセシビリティがプライベートである場合、M のアクセシビリティドメインは T のプログラムテキストになります。

-----

> 保護されている、**またはプライベートに保護さ**れたインスタンスメンバーが、そのメンバーが宣言されているクラスのプログラムテキストの外部からアクセスされ、保護された内部インスタンスのメンバーが、宣言されているプログラムのプログラムテキストの外部でアクセスされた場合、アクセスは、宣言されたクラスから派生したクラス宣言内 さらに、その派生クラス型のインスタンス、またはそれから構築されたクラス型を使用してアクセスする必要があります。 この制限により、メンバーが同じ基本クラスから継承されている場合でも、1つの派生クラスが他の派生クラスのプロテクトメンバーにアクセスするのを防ぐことができます。

-----

> 許可されるアクセス修飾子と型宣言の既定のアクセスは、宣言が行われるコンテキスト (9.5.2 を参照) によって異なります。
- コンパイル単位または名前空間で宣言された型は、パブリックまたは内部アクセスを持つことができます。 既定値は 内部アクセスです。
- クラスで宣言された型は、public、protected internal、 **private protected**、protected、internal、または private アクセスを持つことができます。 既定値はプライベートアクセスです。
- 構造体で宣言された型は、パブリック、内部、またはプライベートアクセスを持つことができます。 既定値はプライベートアクセスです。

-----

> 静的クラスの宣言には、次の制限があります。
- 静的クラスに sealed または abstract 修飾子を含めることはできません。 (ただし、静的クラスはインスタンス化したり、から派生させたりすることはできません。そのため、シールドと抽象の両方であるかのように動作します)。
- 静的クラスには、クラスベースの仕様 (16.2.5 を参照) を含めないでください。基底クラスまたは実装されたインターフェイスのリストを明示的に指定することはできません。 静的クラスは、型オブジェクトから暗黙的に継承します。
- 静的クラスには静的メンバーのみを含める必要があります (16.4.8 を参照)。 [注: すべての定数と入れ子になった型は、静的メンバーとして分類されます。 メモを終了する
- 静的クラスには **、protected、private protected、** または protected internal で宣言されたアクセシビリティを持つメンバーを含めることはできません。

> これらの制限に違反すると、コンパイル時にエラーが発生します。 

-----

> クラスメンバー宣言は、宣言されたアクセシビリティの~~5~~**つの**種類 (9.5.2) のうちのいずれか1つを持つことができます。 public、 **private protected**、protected internal、protected、internal、または private。 Protected internal**と private protected**の組み合わせを除き、**複数のアクセス**修飾子を指定するコンパイル時エラーになります。 クラスメンバー宣言にアクセス修飾子が含まれていない場合、private が想定されます。

-----

> 入れ子になっていない型は、パブリックまたは内部で宣言されたアクセシビリティを持つことができ、既定で内部で宣言されたアクセシビリティを持ちます。 入れ子にされた型には、これらの形式のアクセシビリティを含めることができます。また、包含する型がクラスまたは構造体であるかどうかによって、宣言されたアクセシビリティの1つ以上の追加の形式を使用できます。
- クラス内で宣言されている入れ子にされた型は、 ~~5~~**つの任意の形式 (** public、 **private protected**、protected internal、protected、internal、または private) を持つことができ、他のクラスメンバーと同様に、既定でプライベートに宣言されたアクセシビリティを持つことができます。
- 構造体で宣言されている入れ子にされた型は、3つの形式のアクセシビリティ (public、internal、または private) を持つことができ、他の構造体メンバーと同様に、既定でプライベートに宣言されたアクセシビリティを持つことができます。

-----

> オーバーライド宣言によってオーバーライドされるメソッドは、クラス C で宣言されているオーバーライドメソッド M のオーバーライドされた基本メソッドと呼ばれます。オーバーライドされた基本メソッドは、c の基底クラス型 (c の直接基底クラス型から始まります) を調べることによって決定されます。連続した各直接基底クラスの型を続けて、特定の基底クラスの型で、型引数の代入後に M と同じシグネチャを持つアクセス可能なメソッドが少なくとも1つあることを示します。 オーバーライドされた基本メソッドを検索するために、メソッドは、パブリックである場合、保護されている場合、内部で保護**されて**いる場合、または内部または**プライベートに保護**され、C と同じプログラムで宣言されている場合に、アクセス可能と見なされます。

-----

> アクセサー修飾子の使用には、次の制限が適用されます。
- アクセサー修飾子は、インターフェイスまたは明示的なインターフェイスメンバーの実装では使用できません。
- オーバーライド修飾子を持たないプロパティまたはインデクサーの場合、アクセサー修飾子は、プロパティまたはインデクサーに get アクセサーと set アクセサーの両方がある場合にのみ許可されます。その後、これらのアクセサーのいずれかに対してのみ許可されます。
- オーバーライド修飾子を含むプロパティまたはインデクサーの場合、アクセサーは、オーバーライドされるアクセサーのアクセサー修飾子 (存在する場合) と一致させる必要があります。
- アクセサー修飾子は、プロパティまたはインデクサー自体の宣言されたアクセシビリティより厳密に制限されたアクセシビリティを宣言する必要があります。 正確である必要があります。
  - プロパティまたはインデクサーが public のアクセシビリティとして宣言されている場合、アクセサー修飾子は**private protected**、、protected internal、internal、protected、または private のいずれかになります。
  - プロパティまたはインデクサーが protected internal のアクセシビリティとして宣言されている場合、アクセサー修飾子は**private protected**、internal、protected、または private のいずれかになります。
  - プロパティまたはインデクサーが internal または protected として宣言されたアクセシビリティを持っている場合、アクセサー修飾子は**プライベートに保護**されているか、プライベートである必要があります。
  - **プロパティまたはインデクサーに private protected のアクセシビリティが宣言されている場合、アクセサー修飾子は private である必要があります。**
  - プロパティまたはインデクサーに private として宣言されたアクセシビリティがある場合、アクセサー修飾子は使用できません。

-----

> 構造体では継承がサポートされていないため、宣言された構造体メンバーのアクセシビリティを protected、 **private protected**、または protected internal にすることはできません。

-----

## <a name="drawbacks"></a>短所
[drawbacks]: #drawbacks

他の言語機能と同様に、この機能の恩恵を受けるプログラムのC#本文に対して、さらに複雑な言語を端的にする必要があるかどうかを質問する必要があります。

## <a name="alternatives"></a>代替
[alternatives]: #alternatives

別の方法として、属性とアナライザーを組み合わせた API をプロビジョニングすることもできます。 属性は `internal` メンバーに対してプログラマによって設定されます。これは、メンバーがサブクラスでのみ使用されることを示すために、アナライザーはそれらの制限が cache-control であることを確認します。 

## <a name="unresolved-questions"></a>未解決の質問
[unresolved]: #unresolved-questions

実装の大部分は完全です。 開かれている作業項目は、VB に対応する仕様の下書きです。

## <a name="design-meetings"></a>会議のデザイン

TBD
