---
ms.openlocfilehash: 77c9ffda3a59cc5f3dcc3ec9848600c6c5e03eed
ms.sourcegitcommit: 27487fa0294f4cdb7e5f2478884149e05314fd8a
ms.translationtype: MT
ms.contentlocale: ja-JP
ms.lasthandoff: 07/23/2019
ms.locfileid: "79483902"
---
# <a name="primary-constructors"></a>プライマリコンストラクター

* [x] が提案されています
* [] プロトタイプ: 開始されていません
* [] の実装: 開始されていません
* [] 仕様: 開始されていません

## <a name="summary"></a>まとめ
[summary]: #summary

クラスはパラメーターリストを持つことができ、その場合、基底クラスの指定は引数リストを持つことができます。
プライマリコンストラクターのパラメーターは、クラス宣言全体を通じてスコープ内にあり、関数メンバーまたは匿名関数によってキャプチャされると、クラスにプライベートフィールドとして格納されます。

## <a name="motivation"></a>目的
[motivation]: #motivation

プログラム初期化コードに多くの定型句があることは一般的です。 一般的なケースでは、特定のデータ `x` が何度も記述されています。

- プライベートフィールドとして `_x`
- コンストラクターに `x` パラメーターとして
- コンストラクターのパラメーターからのフィールドの割り当て `_x = x;`
- プロパティとして `X`
- プロパティ set アクセス操作子 `x = value;`
- プロパティの getter `return x;`

``` c#
class C
{
    private string _x;
    
    public C(string x)
    {
        _x = x;
    }
    public string X
    {
        get => _x;
        set { if (value == null) throw new NullArgumentException(nameof(X)); _x = value; }
    }
}
```

検証や計算を必要としないプロパティの場合は、自動プロパティを使用して面倒な作業を減らすことができます。これにより、プロパティの明示的なバッキングフィールドを宣言する必要がなくなります。 ただし、プロパティが自動プロパティで提供されるもの以外のロジックの種類を必要とする場合は、上記の方法をお勧めします。

プライマリコンストラクターでは、コンストラクターの引数をクラスのスコープ内に直接配置することによってオーバーヘッドを軽減し、バッキングフィールドを明示的に宣言する必要が習得ます。 したがって、上記の例は次のようになります。

``` c#
class C(string x)
{
    public string X
    {
        get => x;
        set { if (value == null) throw new NullArgumentException(nameof(X)); x = value; }
    }
}
```

この例では、プライマリコンストラクターによって、`x` の名前付きエンティティの数が3から2に減り、`_x` バッキングフィールドが習得されます。 このメソッドは、3つのメンバー宣言 (プロパティ宣言自体のみを保持) のうちの2つを削除し、`x`/`_x`/`X` の合計数を8から5に減らします。


## <a name="detailed-design"></a>詳細なデザイン
[design]: #detailed-design

クラスにはパラメーターリストを含めることができます。

``` c#
public class C(int i, string s)
{
    ...
}
```

パラメーターリストを使用すると、クラス自体と同じアクセシビリティで、クラスに対してコンストラクターが暗黙的に宣言されます。

``` c#
new C(5, "Hello");
```

プライマリコンストラクターのパラメーターは、クラス本体全体でスコープ内にあります。 関数メンバーまたは匿名関数によってキャプチャされた場合は、クラスのプライベートフィールドとして格納されます。 初期化中にのみ使用される場合は、オブジェクトに格納されません。

``` c#
public class C(int i, string s)
{
    int[] a = new int[i]; // i not captured
    public int S => s;    // s captured
}
```

プライマリコンストラクターを持つクラスに基底クラスの指定がある場合、そのクラスは引数リストを持つことができます。 これは、暗黙的に宣言されたコンストラクターの `base(...)` 初期化子の引数リストとして機能します。 引数リストが指定されていない場合は、空のものが想定されます。

``` c#
public class C(int i, string s) : B(s)
{
    ...
}
```
クラスは、明示的に定義されたコンストラクターも持つことができますが、これらはすべて `this(...)` 初期化子を使用する必要があります。 これにより、新しいインスタンスが構築されるときに、常にプライマリコンストラクターが呼び出されるようになります。

クラス本体内のすべての初期化子は、生成されたコンストラクター内の割り当てになります。 これは、他のクラスとは異なり、初期化子は、前ではなく、基本コンストラクターが呼び出され*た後*に実行されることを意味します。 また、生成されたクラスには、メンバーによってキャプチャされたプライマリコンストラクターパラメーターを格納するために生成されたプライベートフィールドを初期化するための割り当てが含まれます。 これらのメンバーは、ラムダ式のクロージャと同様の方法で、パラメーターの代わりにプライベートフィールドを使用するように書き換えられます。 生成されたプライマリフィールドが最初に初期化された後、初期化子によって生成された割り当てがクラス内の外観の順序で実行されます。

上記の例では、クラス宣言の効果は次のように書き換えられます。

``` c#
public class C : B
{
    public C(int i, string s) : base(s)
    {
        __s = s;        // store parameter s for captured use
        a = new int[i]; // initialize a
    }
    int __s; // generated field for capture of s
    
    int[] a;
    public int S => __s; // s replaced with captured __s
}
```

キャプチャには、ラムダ式によってローカル変数をキャプチャする場合と同様の制限があります。 たとえば、`ref` パラメーターと `out` パラメーターは、プライマリコンストラクターで許可されますが、メンバー本体をキャプチャすることはできません。


## <a name="drawbacks"></a>短所
[drawbacks]: #drawbacks

重要度の大まかな順序。

* この提案では、位置指定レコードに対しても提示された構文を使用します。 両方の機能が必要な場合は、いくつかの設備が必要です。 例: レコードの `data` 修飾子が指定されました。
* 構築されたオブジェクトの割り当てサイズは、クラスのフルテキストに基づいてプライマリコンストラクターパラメーターのフィールドを割り当てるかどうかをコンパイラが決定するため、あまり明確ではありません。 このリスクは、ラムダ式による変数の暗黙的なキャプチャに似ています。
* 一般的な誘惑 (または偶発的なパターン) は、複数の継承レベルで "同じ" パラメーターをキャプチャする場合があります。これは、基底クラスで保護されたフィールドを明示的に割り当てて、重複する割り当てを行うのではなく、コンストラクターチェーンが渡されるためです。オブジェクトの同じデータに対して。 これは、自動プロパティを使用して自動プロパティをオーバーライドする現在のリスクとよく似ています。 
* 前述のように、通常はコンストラクター本体で表現される追加のロジックを使用する場所はありません。 以下の "プライマリコンストラクター本体" 拡張機能は、それに対応しています。
* 提案されたように、実行順序のセマンティクスは、通常のコンストラクターとはわずかに異なります。 これは、一部の拡張機能の提案 (特に "プライマリコンストラクター本体") を犠牲にする可能性があります。
* この提案は、単一のコンストラクターをプライマリとして指定できる場合にのみ機能します。
* クラスとプライマリコンストラクターのアクセシビリティを個別に設定する方法はありません。 たとえば、パブリックコンストラクターがすべて、必要となる1つのプライベート "build-all" コンストラクターにデリゲートする場合などです。 必要に応じて、後で構文を提示することもできます。


## <a name="alternatives"></a>代替
[alternatives]: #alternatives

詳細については、完全な位置指定レコードを代わりに使用することも、プライマリコンストラクターと共存させることもできます。 これにより、より*少ない*省略形で*より多く*のシナリオを実現できます。 そのため、どちらも役に立つ可能性がありますが、両方を使用することは、互いに多少の統合が可能でない限り、過剰になる可能性があります。


## <a name="possible-extensions"></a>拡張の可能性
[extensions]: #possible-extensions

これらは、それと共に検討される可能性があるコア提案のバリエーションや追加、または有用であると思われる場合は後の段階で使用されます。

### <a name="primary-constructor-bodies"></a>プライマリコンストラクター本体

多くの場合、コンストラクター自体には、初期化子として表現できないパラメーター検証ロジックや、その他の重要な初期化コードが含まれています。

プライマリコンストラクターを拡張して、ステートメントブロックをクラス本体に直接表示できるようにすることができます。 これらのステートメントは、生成されたコンストラクターに挿入されます。これらのステートメントは初期化の初期化の間に出現します。そのため、初期化子と共に実行されます。 次に例を示します。

``` c#
public class C(int i, string s) : B(s)
{
    {
        if (i < 0) throw new ArgumentOutOfRangeException(nameof(i));
    }
    int[] a = new int[i];
    public int S => s;
}
```

### <a name="initializer-fields-and-initializer-functions"></a>初期化子フィールドおよび初期化子関数

プライマリコンストラクターを持つクラスでは、ローカル変数やローカル関数のように、アクセシビリティ修飾子のないフィールド宣言とメソッド宣言を検討できます。

* プライマリコンストラクターのパラメーターと同様に、"初期化子フィールド" は、関数メンバーで使用されていた場合にのみ実際のプライベートフィールドにキャプチャされます。
* "初期化子関数" は、プライマリコンストラクターのパラメーターと初期化子フィールドが他の関数メンバーで使用されていた場合にのみ、それらをキャプチャすることを検討します。 キャプチャされていない場合は、ローカル関数のように、より最適化された方法で生成される可能性があります。
* プライマリコンストラクターパラメーターと同様に、メンバーアクセスでは使用できませんが、単純な名前としてのみ使用できます。

これは、初期化にのみ関連する一時変数およびヘルパー関数に使用できます。

``` c#
public class C(string s)
{
    int size = s.Length;             // not captured
    int[] Create() => new int[size]; // not captured
    int[] a = Create();
    ...
}
```

特に、アクセシビリティ修飾子がない場合は、`private`を意味します。 

### <a name="initializer-statements"></a>初期化子ステートメント

上の例と拡張機能の組み合わせでは、単にステートメントをクラス本体で直接許可するだけです。 このようなステートメントは、上記で示したように、厳密に指定されたコンストラクター本体とまったく同じですが、`{ }`で囲む必要がない点が異なります。 これを十分に活用するには、"ローカル" 変数およびヘルパー関数をクラスの最上位レベルで表現する必要もあります。これについては、上記の拡張機能の "初期化子フィールドと初期化子関数" で調査します。


### <a name="member-access"></a>メンバー アクセス。

コア提案では、プライマリコンストラクターパラメーターを、単純な名前としてのみ参照できるパラメーターとして扱います。 別の方法としては、フィールドとして生成されない場合*でも*、メンバーアクセスを使用して、プライベートフィールドであるかのように参照できるようにする方法があります。 これにより、ローカル変数によってシャドウされた場合に `this.x` として参照したり、`other.x`とは異なるインスタンスからアクセスしたりできます。

"初期化子フィールドおよび初期化子関数" 拡張機能に適用されている場合、通常のプライベートメンバーとは異なる程度になります。 唯一の違いは、初期化中に使用された場合にのみ、コンパイラがオブジェクトから除外できることです。

